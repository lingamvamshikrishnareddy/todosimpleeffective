{"ast":null,"code":"import axios from 'axios';\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\n\n// Create axios instance with defaults\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  timeout: 15000,\n  // Increased timeout for network congestion\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true // Send cookies with cross-origin requests\n});\n\n// Request interceptor for adding auth token\napiClient.interceptors.request.use(config => {\n  const token = localStorage.getItem('authToken');\n  if (token) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Enhanced response interceptor with better retry logic and rate limiting handling\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\napiClient.interceptors.response.use(response => response.data, async error => {\n  var _error$response2, _error$response3, _error$response3$data, _error$response4;\n  const originalRequest = error.config;\n\n  // Skip retry for certain endpoints to avoid duplication\n  const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\n  const shouldSkipRetry = skipRetryEndpoints.some(endpoint => originalRequest.url.includes(endpoint));\n  if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\n    var _error$response;\n    const status = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status;\n\n    // Retry on network errors or specific status codes\n    if (!error.response || RETRY_CODES.includes(status)) {\n      originalRequest._retry = (originalRequest._retry || 0) + 1;\n\n      // Calculate backoff delay with jitter to prevent thundering herd\n      const jitter = Math.random() * 0.3;\n      const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10);\n      const delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\n      console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms`);\n\n      // Special handling for rate limiting\n      if (status === 429) {\n        // Extract retry-after header if available or use our calculated delay\n        const retryAfter = error.response.headers['retry-after'];\n        const retryDelay = retryAfter ? parseInt(retryAfter, 10) * 1000 : delay;\n        console.log(`Rate limited. Retrying after ${retryDelay}ms`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n      } else {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n      return apiClient(originalRequest);\n    }\n  }\n\n  // Handle 401 Unauthorized - refresh token or redirect to login\n  if (error.response && error.response.status === 401) {\n    // Skip refresh token attempt if already in progress\n    if (originalRequest.url.includes('/auth/refresh') || originalRequest._hasRefreshed || originalRequest.url.includes('/auth/login')) {\n      // <-- Add this check\n      throw new Error('Token refresh failed');\n    }\n\n    // Flag to prevent infinite refresh loop\n    originalRequest._hasRefreshed = true;\n    try {\n      // Attempt to refresh token\n      const refreshToken = localStorage.getItem('refreshToken');\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n\n      // Call refresh token endpoint\n      const response = await axios.post(`${API_URL}/auth/refresh`, {\n        refreshToken\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        withCredentials: true // Send cookies\n      });\n\n      // Update tokens\n      const {\n        token\n      } = response.data;\n      localStorage.setItem('authToken', token);\n\n      // Update authorization header and retry\n      originalRequest.headers['Authorization'] = `Bearer ${token}`;\n      return apiClient(originalRequest);\n    } catch (refreshError) {\n      // If refresh fails, clean up tokens and redirect to login\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('refreshToken');\n\n      // Don't redirect for background API calls\n      if (window.location.pathname !== '/login') {\n        window.location.href = '/login';\n      }\n      throw refreshError; // Re-throw to properly handle the error\n    }\n  }\n\n  // Create a standardized error object\n  const errorResponse = {\n    status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status,\n    message: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || error.message,\n    data: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data\n  };\n  return Promise.reject(errorResponse);\n});\n\n// Authentication utilities\n// Check if user is authenticated\nconst isAuthenticated = () => {\n  const token = localStorage.getItem('authToken');\n  if (!token) return false;\n\n  // Optional: Check if token is expired\n  try {\n    // Get payload from JWT (token structure: header.payload.signature)\n    const payload = token.split('.')[1];\n    if (!payload) return false;\n    const decodedData = JSON.parse(atob(payload));\n    const expirationTime = decodedData.exp * 1000; // Convert to milliseconds\n\n    return expirationTime > Date.now();\n  } catch (error) {\n    console.error('Error checking token validity:', error);\n    return false;\n  }\n};\n\n// Get current user ID from token\nconst getCurrentUserId = () => {\n  const token = localStorage.getItem('authToken');\n  if (!token) return null;\n  try {\n    const payload = token.split('.')[1];\n    if (!payload) return null;\n    const decodedData = JSON.parse(atob(payload));\n    return decodedData.id;\n  } catch (error) {\n    console.error('Error extracting user ID from token:', error);\n    return null;\n  }\n};\n\n// Logout helper\nconst logout = () => {\n  localStorage.removeItem('authToken');\n  localStorage.removeItem('refreshToken');\n\n  // If you're using cookies for refresh tokens, you would also clear them here\n  // via the logout API endpoint\n  return apiClient.post('/auth/logout').catch(error => {\n    console.warn('Error during logout API call:', error);\n    // Continue with client-side logout even if server logout fails\n  });\n};\n\n// Login helper\nconst login = async credentials => {\n  const data = await apiClient.post('/auth/login', credentials);\n  if (data.token) {\n    localStorage.setItem('authToken', data.token);\n  }\n  if (data.refreshToken) {\n    localStorage.setItem('refreshToken', data.refreshToken);\n  }\n  return data;\n};\n\n// Enhanced Task API with better request management and queuing\nclass TaskAPI {\n  constructor() {\n    this.cache = new Map();\n    this.pendingRequests = new Map();\n    this.requestQueue = [];\n    this.processing = false;\n    this.activeRequests = 0;\n    this.MAX_CONCURRENT = 6; // Maximum concurrent requests\n\n    // Rate limiting parameters\n    this.rateLimitPerSecond = 10;\n    this.requestTimestamps = [];\n\n    // Cache config with adaptive expiration\n    this.cacheConfig = {\n      defaultExpiry: 30000,\n      // 30 seconds\n      longExpiry: 5 * 60 * 1000,\n      // 5 minutes for static resources\n      shortExpiry: 10000 // 10 seconds for frequently changing data\n    };\n  }\n\n  // Check if we should apply rate limiting\n  shouldRateLimit() {\n    const now = Date.now();\n\n    // Remove timestamps older than 1 second\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\n\n    // Check if we've reached our limit\n    return this.requestTimestamps.length >= this.rateLimitPerSecond;\n  }\n\n  // Track request for rate limiting\n  trackRequest() {\n    this.requestTimestamps.push(Date.now());\n  }\n\n  // Enhanced cache management with expiration policies\n  getCachedData(key, fetchFn, options = {}) {\n    const cached = this.cache.get(key);\n    const expiryTime = options.longCache ? this.cacheConfig.longExpiry : options.shortCache ? this.cacheConfig.shortExpiry : this.cacheConfig.defaultExpiry;\n\n    // If we have valid cached data, use it\n    if (cached && Date.now() - cached.timestamp < expiryTime) {\n      return Promise.resolve(cached.data);\n    }\n\n    // If there's already a pending request for this data\n    if (this.pendingRequests.has(key)) {\n      return this.pendingRequests.get(key);\n    }\n\n    // Make a new request and cache the promise\n    const request = this.enqueueRequest(() => fetchFn()).then(data => {\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now()\n      });\n      this.pendingRequests.delete(key);\n      return data;\n    }).catch(error => {\n      this.pendingRequests.delete(key);\n      throw error;\n    });\n    this.pendingRequests.set(key, request);\n    return request;\n  }\n\n  // Clear cache for a specific key or entire cache\n  invalidateCache(key = null) {\n    if (key === null) {\n      this.cache.clear();\n    } else if (typeof key === 'string') {\n      this.cache.delete(key);\n    } else if (typeof key === 'function') {\n      // Handle function-based invalidation\n      for (const cacheKey of this.cache.keys()) {\n        if (key(cacheKey)) {\n          this.cache.delete(cacheKey);\n        }\n      }\n    }\n  }\n\n  // Improved request queuing with priority support\n  enqueueRequest(fn, priority = 'normal') {\n    return new Promise((resolve, reject) => {\n      const request = {\n        fn,\n        resolve,\n        reject,\n        priority,\n        timestamp: Date.now()\n      };\n\n      // Insert by priority (high, normal, low)\n      if (priority === 'high') {\n        this.requestQueue.unshift(request);\n      } else if (priority === 'low') {\n        this.requestQueue.push(request);\n      } else {\n        // Insert normal priority requests at the front of normal/low section\n        const index = this.requestQueue.findIndex(r => r.priority === 'low');\n        if (index === -1) {\n          this.requestQueue.push(request);\n        } else {\n          this.requestQueue.splice(index, 0, request);\n        }\n      }\n\n      // Start processing the queue if not already running\n      if (!this.processing) {\n        this.processQueue();\n      }\n    });\n  }\n\n  // Process request queue with improved concurrency management\n  async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n    const processNext = async () => {\n      // Stop if queue is empty or we've reached max concurrent requests\n      if (this.requestQueue.length === 0 || this.activeRequests >= this.MAX_CONCURRENT) {\n        if (this.requestQueue.length === 0 && this.activeRequests === 0) {\n          this.processing = false;\n        }\n        return;\n      }\n\n      // Check rate limiting\n      if (this.shouldRateLimit()) {\n        // Wait a bit before trying again\n        setTimeout(() => processNext(), 100);\n        return;\n      }\n\n      // Dequeue request\n      const request = this.requestQueue.shift();\n      this.activeRequests++;\n      this.trackRequest();\n      try {\n        const result = await request.fn();\n        request.resolve(result);\n      } catch (error) {\n        request.reject(error);\n      } finally {\n        this.activeRequests--;\n        // Process next item\n        processNext();\n      }\n    };\n\n    // Start multiple processors up to MAX_CONCURRENT\n    const processors = Array(Math.min(this.MAX_CONCURRENT, this.requestQueue.length)).fill().map(() => processNext());\n    await Promise.allSettled(processors);\n\n    // If there are still items in the queue, continue processing\n    if (this.requestQueue.length > 0 && this.activeRequests < this.MAX_CONCURRENT) {\n      this.processQueue();\n    } else if (this.requestQueue.length === 0 && this.activeRequests === 0) {\n      this.processing = false;\n    }\n  }\n\n  // Enhanced API methods with better error handling and caching\n\n  getTasks(params = {}) {\n    const queryParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        queryParams.append(key, value);\n      }\n    });\n    const queryString = queryParams.toString();\n    const cacheKey = `tasks_${queryString}`;\n\n    // Short expiry for task lists as they change frequently\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks?${queryString}`), {\n      shortCache: true\n    });\n  }\n  getTaskById(taskId) {\n    const cacheKey = `task_${taskId}`;\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/${taskId}`));\n  }\n  createTask(taskData) {\n    // Invalidate task list cache on create\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.post('/tasks', taskData), 'high');\n  }\n  updateTask(taskId, taskData) {\n    // Invalidate specific task cache and task lists\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.put(`/tasks/${taskId}`, taskData));\n  }\n  deleteTask(taskId) {\n    // Invalidate specific task cache and task lists\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.delete(`/tasks/${taskId}`));\n  }\n  toggleTaskStatus(taskId) {\n    // Invalidate specific task cache and task lists\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.patch(`/tasks/${taskId}/toggle`));\n  }\n\n  // Bulk operations with optimized handling\n  bulkUpdateTasks(taskIds, updateData) {\n    // Invalidate all affected task caches and task lists\n    taskIds.forEach(id => {\n      this.invalidateCache(`task_${id}`);\n    });\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.put('/tasks/bulk-update', {\n      taskIds,\n      updateData\n    }), 'high');\n  }\n  bulkDeleteTasks(taskIds) {\n    // Invalidate all affected task caches and task lists\n    taskIds.forEach(id => {\n      this.invalidateCache(`task_${id}`);\n    });\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.delete('/tasks/bulk-delete', {\n      data: {\n        taskIds\n      }\n    }), 'high');\n  }\n\n  // Search tasks with debounced caching\n  searchTasks(searchTerm, filters = {}) {\n    const queryParams = new URLSearchParams();\n    queryParams.append('search', searchTerm);\n    Object.entries(filters).forEach(([key, value]) => {\n      if (value !== undefined) {\n        queryParams.append(key, value);\n      }\n    });\n    const queryString = queryParams.toString();\n    const cacheKey = `search_${queryString}`;\n\n    // Very short expiry for search results\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/search?${queryString}`), {\n      shortCache: true\n    });\n  }\n\n  // Get task statistics with longer cache\n  getTaskStats() {\n    return this.getCachedData('task_stats', () => apiClient.get('/tasks/stats'), {\n      longCache: true\n    });\n  }\n}\n\n// Authentication API with token management\nclass AuthAPI {\n  login(credentials) {\n    return login(credentials);\n  }\n  register(userData) {\n    return apiClient.post('/auth/register', userData);\n  }\n  logout() {\n    return logout();\n  }\n  forgotPassword(email) {\n    return apiClient.post('/auth/forgot-password', {\n      email\n    });\n  }\n  validateResetToken(token) {\n    return apiClient.get(`/auth/reset-password/${token}`);\n  }\n  resetPassword(token, newPassword) {\n    return apiClient.post('/auth/reset-password', {\n      token,\n      newPassword\n    });\n  }\n  refreshToken() {\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      return Promise.reject(new Error('No refresh token available'));\n    }\n    return apiClient.post('/auth/refresh', {\n      refreshToken\n    }).then(data => {\n      if (data.token) {\n        localStorage.setItem('authToken', data.token);\n      }\n      if (data.refreshToken) {\n        localStorage.setItem('refreshToken', data.refreshToken);\n      }\n      return data;\n    });\n  }\n\n  // Check if the user is authenticated\n  isAuthenticated() {\n    return isAuthenticated();\n  }\n\n  // Get current user ID\n  getCurrentUserId() {\n    return getCurrentUserId();\n  }\n}\n\n// User API for profile management\nclass UserAPI {\n  getProfile() {\n    return this.getCachedData('user_profile', () => apiClient.get('/user/profile'));\n  }\n  updateProfile(userData) {\n    this.invalidateCache('user_profile');\n    return apiClient.put('/user/profile', userData);\n  }\n  changePassword(passwordData) {\n    return apiClient.put('/user/password', passwordData);\n  }\n\n  // Inherit caching methods from TaskAPI\n  getCachedData(key, fetchFn, options = {}) {\n    return taskApi.getCachedData(key, fetchFn, options);\n  }\n  invalidateCache(key = null) {\n    return taskApi.invalidateCache(key);\n  }\n}\n\n// Create instances of the API classes\nconst taskApi = new TaskAPI();\nconst authApi = new AuthAPI();\nconst userApi = new UserAPI();\n\n// Create a consolidated API object that includes utility functions\nconst api = {\n  tasks: taskApi,\n  auth: authApi,\n  user: userApi,\n  // Add utility functions at the top level for convenience\n  isAuthenticated,\n  getCurrentUserId,\n  login,\n  logout\n};\n\n// Export the API instances and client\nexport { apiClient, taskApi, authApi, userApi, isAuthenticated, getCurrentUserId };\n\n// Default export for convenience\nexport default api;","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","apiClient","create","baseURL","timeout","headers","withCredentials","interceptors","request","use","config","token","localStorage","getItem","error","Promise","reject","MAX_RETRIES","RETRY_DELAY_MS","RETRY_CODES","response","data","_error$response2","_error$response3","_error$response3$data","_error$response4","originalRequest","skipRetryEndpoints","shouldSkipRetry","some","endpoint","url","includes","_retry","_error$response","status","jitter","Math","random","backoffFactor","min","pow","delay","console","log","round","retryAfter","retryDelay","parseInt","resolve","setTimeout","_hasRefreshed","Error","refreshToken","post","setItem","refreshError","removeItem","window","location","pathname","href","errorResponse","message","isAuthenticated","payload","split","decodedData","JSON","parse","atob","expirationTime","exp","Date","now","getCurrentUserId","id","logout","catch","warn","login","credentials","TaskAPI","constructor","cache","Map","pendingRequests","requestQueue","processing","activeRequests","MAX_CONCURRENT","rateLimitPerSecond","requestTimestamps","cacheConfig","defaultExpiry","longExpiry","shortExpiry","shouldRateLimit","filter","time","length","trackRequest","push","getCachedData","key","fetchFn","options","cached","get","expiryTime","longCache","shortCache","timestamp","has","enqueueRequest","then","set","delete","invalidateCache","clear","cacheKey","keys","fn","priority","unshift","index","findIndex","r","splice","processQueue","processNext","shift","result","processors","Array","fill","map","allSettled","getTasks","params","queryParams","URLSearchParams","Object","entries","forEach","value","undefined","append","queryString","toString","getTaskById","taskId","createTask","taskData","startsWith","updateTask","put","deleteTask","toggleTaskStatus","patch","bulkUpdateTasks","taskIds","updateData","bulkDeleteTasks","searchTasks","searchTerm","filters","getTaskStats","AuthAPI","register","userData","forgotPassword","email","validateResetToken","resetPassword","newPassword","UserAPI","getProfile","updateProfile","changePassword","passwordData","taskApi","authApi","userApi","api","tasks","auth","user"],"sources":["D:/Projects/todo list/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\r\n\r\n// Create axios instance with defaults\r\nconst apiClient = axios.create({\r\n  baseURL: API_URL,\r\n  timeout: 15000, // Increased timeout for network congestion\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n  withCredentials: true // Send cookies with cross-origin requests\r\n});\r\n\r\n// Request interceptor for adding auth token\r\napiClient.interceptors.request.use(\r\n  config => {\r\n    const token = localStorage.getItem('authToken');\r\n    if (token) {\r\n      config.headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  error => Promise.reject(error)\r\n);\r\n\r\n// Enhanced response interceptor with better retry logic and rate limiting handling\r\nconst MAX_RETRIES = 3;\r\nconst RETRY_DELAY_MS = 1000;\r\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\r\n\r\napiClient.interceptors.response.use(\r\n  response => response.data,\r\n  async error => {\r\n    const originalRequest = error.config;\r\n    \r\n    // Skip retry for certain endpoints to avoid duplication\r\n    const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\r\n    const shouldSkipRetry = skipRetryEndpoints.some(endpoint => originalRequest.url.includes(endpoint));\r\n    \r\n    if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\r\n      const status = error.response?.status;\r\n      \r\n      // Retry on network errors or specific status codes\r\n      if (!error.response || RETRY_CODES.includes(status)) {\r\n        originalRequest._retry = (originalRequest._retry || 0) + 1;\r\n        \r\n        // Calculate backoff delay with jitter to prevent thundering herd\r\n        const jitter = Math.random() * 0.3;\r\n        const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10);\r\n        const delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\r\n        \r\n        console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms`);\r\n        \r\n        // Special handling for rate limiting\r\n        if (status === 429) {\r\n          // Extract retry-after header if available or use our calculated delay\r\n          const retryAfter = error.response.headers['retry-after'];\r\n          const retryDelay = retryAfter ? parseInt(retryAfter, 10) * 1000 : delay;\r\n          \r\n          console.log(`Rate limited. Retrying after ${retryDelay}ms`);\r\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\r\n        } else {\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n        \r\n        return apiClient(originalRequest);\r\n      }\r\n    }\r\n    \r\n    // Handle 401 Unauthorized - refresh token or redirect to login\r\n    if (error.response && error.response.status === 401) {\r\n      // Skip refresh token attempt if already in progress\r\n      if (originalRequest.url.includes('/auth/refresh') || \r\n      originalRequest._hasRefreshed ||\r\n      originalRequest.url.includes('/auth/login')) {  // <-- Add this check\r\n    throw new Error('Token refresh failed');\r\n  }\r\n      \r\n      // Flag to prevent infinite refresh loop\r\n      originalRequest._hasRefreshed = true;\r\n      \r\n      try {\r\n        // Attempt to refresh token\r\n        const refreshToken = localStorage.getItem('refreshToken');\r\n        if (!refreshToken) {\r\n          throw new Error('No refresh token available');\r\n        }\r\n        \r\n        // Call refresh token endpoint\r\n        const response = await axios.post(`${API_URL}/auth/refresh`, {\r\n          refreshToken\r\n        }, {\r\n          headers: {\r\n            'Content-Type': 'application/json'\r\n          },\r\n          withCredentials: true // Send cookies\r\n        });\r\n        \r\n        // Update tokens\r\n        const { token } = response.data;\r\n        localStorage.setItem('authToken', token);\r\n        \r\n        // Update authorization header and retry\r\n        originalRequest.headers['Authorization'] = `Bearer ${token}`;\r\n        return apiClient(originalRequest);\r\n      } catch (refreshError) {\r\n        // If refresh fails, clean up tokens and redirect to login\r\n        localStorage.removeItem('authToken');\r\n        localStorage.removeItem('refreshToken');\r\n        \r\n        // Don't redirect for background API calls\r\n        if (window.location.pathname !== '/login') {\r\n          window.location.href = '/login';\r\n        }\r\n        \r\n        throw refreshError; // Re-throw to properly handle the error\r\n      }\r\n    }\r\n    \r\n    // Create a standardized error object\r\n    const errorResponse = {\r\n      status: error.response?.status,\r\n      message: error.response?.data?.message || error.message,\r\n      data: error.response?.data\r\n    };\r\n    \r\n    return Promise.reject(errorResponse);\r\n  }\r\n);\r\n\r\n// Authentication utilities\r\n// Check if user is authenticated\r\nconst isAuthenticated = () => {\r\n  const token = localStorage.getItem('authToken');\r\n  if (!token) return false;\r\n  \r\n  // Optional: Check if token is expired\r\n  try {\r\n    // Get payload from JWT (token structure: header.payload.signature)\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return false;\r\n    \r\n    const decodedData = JSON.parse(atob(payload));\r\n    const expirationTime = decodedData.exp * 1000; // Convert to milliseconds\r\n    \r\n    return expirationTime > Date.now();\r\n  } catch (error) {\r\n    console.error('Error checking token validity:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Get current user ID from token\r\nconst getCurrentUserId = () => {\r\n  const token = localStorage.getItem('authToken');\r\n  if (!token) return null;\r\n  \r\n  try {\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return null;\r\n    \r\n    const decodedData = JSON.parse(atob(payload));\r\n    return decodedData.id;\r\n  } catch (error) {\r\n    console.error('Error extracting user ID from token:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Logout helper\r\nconst logout = () => {\r\n  localStorage.removeItem('authToken');\r\n  localStorage.removeItem('refreshToken');\r\n  \r\n  // If you're using cookies for refresh tokens, you would also clear them here\r\n  // via the logout API endpoint\r\n  return apiClient.post('/auth/logout').catch(error => {\r\n    console.warn('Error during logout API call:', error);\r\n    // Continue with client-side logout even if server logout fails\r\n  });\r\n};\r\n\r\n// Login helper\r\nconst login = async (credentials) => {\r\n  const data = await apiClient.post('/auth/login', credentials);\r\n  if (data.token) {\r\n    localStorage.setItem('authToken', data.token);\r\n  }\r\n  if (data.refreshToken) {\r\n    localStorage.setItem('refreshToken', data.refreshToken);\r\n  }\r\n  return data;\r\n};\r\n\r\n// Enhanced Task API with better request management and queuing\r\nclass TaskAPI {\r\n  constructor() {\r\n    this.cache = new Map();\r\n    this.pendingRequests = new Map();\r\n    this.requestQueue = [];\r\n    this.processing = false;\r\n    this.activeRequests = 0;\r\n    this.MAX_CONCURRENT = 6; // Maximum concurrent requests\r\n    \r\n    // Rate limiting parameters\r\n    this.rateLimitPerSecond = 10;\r\n    this.requestTimestamps = [];\r\n    \r\n    // Cache config with adaptive expiration\r\n    this.cacheConfig = {\r\n      defaultExpiry: 30000, // 30 seconds\r\n      longExpiry: 5 * 60 * 1000, // 5 minutes for static resources\r\n      shortExpiry: 10000 // 10 seconds for frequently changing data\r\n    };\r\n  }\r\n  \r\n  // Check if we should apply rate limiting\r\n  shouldRateLimit() {\r\n    const now = Date.now();\r\n    \r\n    // Remove timestamps older than 1 second\r\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\r\n    \r\n    // Check if we've reached our limit\r\n    return this.requestTimestamps.length >= this.rateLimitPerSecond;\r\n  }\r\n  \r\n  // Track request for rate limiting\r\n  trackRequest() {\r\n    this.requestTimestamps.push(Date.now());\r\n  }\r\n  \r\n  // Enhanced cache management with expiration policies\r\n  getCachedData(key, fetchFn, options = {}) {\r\n    const cached = this.cache.get(key);\r\n    const expiryTime = options.longCache \r\n      ? this.cacheConfig.longExpiry \r\n      : (options.shortCache ? this.cacheConfig.shortExpiry : this.cacheConfig.defaultExpiry);\r\n    \r\n    // If we have valid cached data, use it\r\n    if (cached && Date.now() - cached.timestamp < expiryTime) {\r\n      return Promise.resolve(cached.data);\r\n    }\r\n    \r\n    // If there's already a pending request for this data\r\n    if (this.pendingRequests.has(key)) {\r\n      return this.pendingRequests.get(key);\r\n    }\r\n    \r\n    // Make a new request and cache the promise\r\n    const request = this.enqueueRequest(() => fetchFn())\r\n      .then(data => {\r\n        this.cache.set(key, {\r\n          data,\r\n          timestamp: Date.now()\r\n        });\r\n        this.pendingRequests.delete(key);\r\n        return data;\r\n      })\r\n      .catch(error => {\r\n        this.pendingRequests.delete(key);\r\n        throw error;\r\n      });\r\n    \r\n    this.pendingRequests.set(key, request);\r\n    return request;\r\n  }\r\n  \r\n  // Clear cache for a specific key or entire cache\r\n  invalidateCache(key = null) {\r\n    if (key === null) {\r\n      this.cache.clear();\r\n    } else if (typeof key === 'string') {\r\n      this.cache.delete(key);\r\n    } else if (typeof key === 'function') {\r\n      // Handle function-based invalidation\r\n      for (const cacheKey of this.cache.keys()) {\r\n        if (key(cacheKey)) {\r\n          this.cache.delete(cacheKey);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Improved request queuing with priority support\r\n  enqueueRequest(fn, priority = 'normal') {\r\n    return new Promise((resolve, reject) => {\r\n      const request = { fn, resolve, reject, priority, timestamp: Date.now() };\r\n      \r\n      // Insert by priority (high, normal, low)\r\n      if (priority === 'high') {\r\n        this.requestQueue.unshift(request);\r\n      } else if (priority === 'low') {\r\n        this.requestQueue.push(request);\r\n      } else {\r\n        // Insert normal priority requests at the front of normal/low section\r\n        const index = this.requestQueue.findIndex(r => r.priority === 'low');\r\n        if (index === -1) {\r\n          this.requestQueue.push(request);\r\n        } else {\r\n          this.requestQueue.splice(index, 0, request);\r\n        }\r\n      }\r\n      \r\n      // Start processing the queue if not already running\r\n      if (!this.processing) {\r\n        this.processQueue();\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Process request queue with improved concurrency management\r\n  async processQueue() {\r\n    if (this.processing) return;\r\n    this.processing = true;\r\n    \r\n    const processNext = async () => {\r\n      // Stop if queue is empty or we've reached max concurrent requests\r\n      if (this.requestQueue.length === 0 || this.activeRequests >= this.MAX_CONCURRENT) {\r\n        if (this.requestQueue.length === 0 && this.activeRequests === 0) {\r\n          this.processing = false;\r\n        }\r\n        return;\r\n      }\r\n      \r\n      // Check rate limiting\r\n      if (this.shouldRateLimit()) {\r\n        // Wait a bit before trying again\r\n        setTimeout(() => processNext(), 100);\r\n        return;\r\n      }\r\n      \r\n      // Dequeue request\r\n      const request = this.requestQueue.shift();\r\n      this.activeRequests++;\r\n      this.trackRequest();\r\n      \r\n      try {\r\n        const result = await request.fn();\r\n        request.resolve(result);\r\n      } catch (error) {\r\n        request.reject(error);\r\n      } finally {\r\n        this.activeRequests--;\r\n        // Process next item\r\n        processNext();\r\n      }\r\n    };\r\n    \r\n    // Start multiple processors up to MAX_CONCURRENT\r\n    const processors = Array(Math.min(this.MAX_CONCURRENT, this.requestQueue.length))\r\n      .fill()\r\n      .map(() => processNext());\r\n    \r\n    await Promise.allSettled(processors);\r\n    \r\n    // If there are still items in the queue, continue processing\r\n    if (this.requestQueue.length > 0 && this.activeRequests < this.MAX_CONCURRENT) {\r\n      this.processQueue();\r\n    } else if (this.requestQueue.length === 0 && this.activeRequests === 0) {\r\n      this.processing = false;\r\n    }\r\n  }\r\n  \r\n  // Enhanced API methods with better error handling and caching\r\n  \r\n  getTasks(params = {}) {\r\n    const queryParams = new URLSearchParams();\r\n    \r\n    Object.entries(params).forEach(([key, value]) => {\r\n      if (value !== undefined) {\r\n        queryParams.append(key, value);\r\n      }\r\n    });\r\n    \r\n    const queryString = queryParams.toString();\r\n    const cacheKey = `tasks_${queryString}`;\r\n    \r\n    // Short expiry for task lists as they change frequently\r\n    return this.getCachedData(cacheKey, () => \r\n      apiClient.get(`/tasks?${queryString}`)\r\n    , { shortCache: true });\r\n  }\r\n  \r\n  getTaskById(taskId) {\r\n    const cacheKey = `task_${taskId}`;\r\n    \r\n    return this.getCachedData(cacheKey, () =>\r\n      apiClient.get(`/tasks/${taskId}`)\r\n    );\r\n  }\r\n  \r\n  createTask(taskData) {\r\n    // Invalidate task list cache on create\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    \r\n    return this.enqueueRequest(() =>\r\n      apiClient.post('/tasks', taskData)\r\n    , 'high');\r\n  }\r\n  \r\n  updateTask(taskId, taskData) {\r\n    // Invalidate specific task cache and task lists\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    \r\n    return this.enqueueRequest(() =>\r\n      apiClient.put(`/tasks/${taskId}`, taskData)\r\n    );\r\n  }\r\n  \r\n  deleteTask(taskId) {\r\n    // Invalidate specific task cache and task lists\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    \r\n    return this.enqueueRequest(() =>\r\n      apiClient.delete(`/tasks/${taskId}`)\r\n    );\r\n  }\r\n  \r\n  toggleTaskStatus(taskId) {\r\n    // Invalidate specific task cache and task lists\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    \r\n    return this.enqueueRequest(() =>\r\n      apiClient.patch(`/tasks/${taskId}/toggle`)\r\n    );\r\n  }\r\n  \r\n  // Bulk operations with optimized handling\r\n  bulkUpdateTasks(taskIds, updateData) {\r\n    // Invalidate all affected task caches and task lists\r\n    taskIds.forEach(id => {\r\n      this.invalidateCache(`task_${id}`);\r\n    });\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    \r\n    return this.enqueueRequest(() =>\r\n      apiClient.put('/tasks/bulk-update', { taskIds, updateData })\r\n    , 'high');\r\n  }\r\n  \r\n  bulkDeleteTasks(taskIds) {\r\n    // Invalidate all affected task caches and task lists\r\n    taskIds.forEach(id => {\r\n      this.invalidateCache(`task_${id}`);\r\n    });\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    \r\n    return this.enqueueRequest(() =>\r\n      apiClient.delete('/tasks/bulk-delete', { data: { taskIds } })\r\n    , 'high');\r\n  }\r\n  \r\n  // Search tasks with debounced caching\r\n  searchTasks(searchTerm, filters = {}) {\r\n    const queryParams = new URLSearchParams();\r\n    queryParams.append('search', searchTerm);\r\n    \r\n    Object.entries(filters).forEach(([key, value]) => {\r\n      if (value !== undefined) {\r\n        queryParams.append(key, value);\r\n      }\r\n    });\r\n    \r\n    const queryString = queryParams.toString();\r\n    const cacheKey = `search_${queryString}`;\r\n    \r\n    // Very short expiry for search results\r\n    return this.getCachedData(cacheKey, () => \r\n      apiClient.get(`/tasks/search?${queryString}`)\r\n    , { shortCache: true });\r\n  }\r\n  \r\n  // Get task statistics with longer cache\r\n  getTaskStats() {\r\n    return this.getCachedData('task_stats', () =>\r\n      apiClient.get('/tasks/stats')\r\n    , { longCache: true });\r\n  }\r\n}\r\n\r\n// Authentication API with token management\r\nclass AuthAPI {\r\n  login(credentials) {\r\n    return login(credentials);\r\n  }\r\n  \r\n  register(userData) {\r\n    return apiClient.post('/auth/register', userData);\r\n  }\r\n  \r\n  logout() {\r\n    return logout();\r\n  }\r\n  \r\n  forgotPassword(email) {\r\n    return apiClient.post('/auth/forgot-password', { email });\r\n  }\r\n  \r\n  validateResetToken(token) {\r\n    return apiClient.get(`/auth/reset-password/${token}`);\r\n  }\r\n  \r\n  resetPassword(token, newPassword) {\r\n    return apiClient.post('/auth/reset-password', { token, newPassword });\r\n  }\r\n  \r\n  refreshToken() {\r\n    const refreshToken = localStorage.getItem('refreshToken');\r\n    \r\n    if (!refreshToken) {\r\n      return Promise.reject(new Error('No refresh token available'));\r\n    }\r\n    \r\n    return apiClient.post('/auth/refresh', { refreshToken })\r\n      .then(data => {\r\n        if (data.token) {\r\n          localStorage.setItem('authToken', data.token);\r\n        }\r\n        if (data.refreshToken) {\r\n          localStorage.setItem('refreshToken', data.refreshToken);\r\n        }\r\n        return data;\r\n      });\r\n  }\r\n  \r\n  // Check if the user is authenticated\r\n  isAuthenticated() {\r\n    return isAuthenticated();\r\n  }\r\n  \r\n  // Get current user ID\r\n  getCurrentUserId() {\r\n    return getCurrentUserId();\r\n  }\r\n}\r\n\r\n// User API for profile management\r\nclass UserAPI {\r\n  getProfile() {\r\n    return this.getCachedData('user_profile', () =>\r\n      apiClient.get('/user/profile')\r\n    );\r\n  }\r\n  \r\n  updateProfile(userData) {\r\n    this.invalidateCache('user_profile');\r\n    \r\n    return apiClient.put('/user/profile', userData);\r\n  }\r\n  \r\n  changePassword(passwordData) {\r\n    return apiClient.put('/user/password', passwordData);\r\n  }\r\n  \r\n  // Inherit caching methods from TaskAPI\r\n  getCachedData(key, fetchFn, options = {}) {\r\n    return taskApi.getCachedData(key, fetchFn, options);\r\n  }\r\n  \r\n  invalidateCache(key = null) {\r\n    return taskApi.invalidateCache(key);\r\n  }\r\n}\r\n\r\n// Create instances of the API classes\r\nconst taskApi = new TaskAPI();\r\nconst authApi = new AuthAPI();\r\nconst userApi = new UserAPI();\r\n\r\n// Create a consolidated API object that includes utility functions\r\nconst api = {\r\n  tasks: taskApi,\r\n  auth: authApi,\r\n  user: userApi,\r\n  // Add utility functions at the top level for convenience\r\n  isAuthenticated,\r\n  getCurrentUserId,\r\n  login,\r\n  logout\r\n};\r\n\r\n// Export the API instances and client\r\nexport {\r\n  apiClient,\r\n  taskApi,\r\n  authApi,\r\n  userApi,\r\n  isAuthenticated,\r\n  getCurrentUserId\r\n};\r\n\r\n// Default export for convenience\r\nexport default api;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,OAAO,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,MAAM;;AAEvD;AACA,MAAMC,SAAS,GAAGL,KAAK,CAACM,MAAM,CAAC;EAC7BC,OAAO,EAAEN,OAAO;EAChBO,OAAO,EAAE,KAAK;EAAE;EAChBC,OAAO,EAAE;IACP,cAAc,EAAE;EAClB,CAAC;EACDC,eAAe,EAAE,IAAI,CAAC;AACxB,CAAC,CAAC;;AAEF;AACAL,SAAS,CAACM,YAAY,CAACC,OAAO,CAACC,GAAG,CAChCC,MAAM,IAAI;EACR,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,WAAW,CAAC;EAC/C,IAAIF,KAAK,EAAE;IACTD,MAAM,CAACL,OAAO,CAAC,eAAe,CAAC,GAAG,UAAUM,KAAK,EAAE;EACrD;EACA,OAAOD,MAAM;AACf,CAAC,EACDI,KAAK,IAAIC,OAAO,CAACC,MAAM,CAACF,KAAK,CAC/B,CAAC;;AAED;AACA,MAAMG,WAAW,GAAG,CAAC;AACrB,MAAMC,cAAc,GAAG,IAAI;AAC3B,MAAMC,WAAW,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAElDlB,SAAS,CAACM,YAAY,CAACa,QAAQ,CAACX,GAAG,CACjCW,QAAQ,IAAIA,QAAQ,CAACC,IAAI,EACzB,MAAMP,KAAK,IAAI;EAAA,IAAAQ,gBAAA,EAAAC,gBAAA,EAAAC,qBAAA,EAAAC,gBAAA;EACb,MAAMC,eAAe,GAAGZ,KAAK,CAACJ,MAAM;;EAEpC;EACA,MAAMiB,kBAAkB,GAAG,CAAC,oBAAoB,EAAE,oBAAoB,EAAE,cAAc,CAAC;EACvF,MAAMC,eAAe,GAAGD,kBAAkB,CAACE,IAAI,CAACC,QAAQ,IAAIJ,eAAe,CAACK,GAAG,CAACC,QAAQ,CAACF,QAAQ,CAAC,CAAC;EAEnG,IAAI,CAACF,eAAe,KAAK,CAACF,eAAe,CAACO,MAAM,IAAIP,eAAe,CAACO,MAAM,GAAGhB,WAAW,CAAC,EAAE;IAAA,IAAAiB,eAAA;IACzF,MAAMC,MAAM,IAAAD,eAAA,GAAGpB,KAAK,CAACM,QAAQ,cAAAc,eAAA,uBAAdA,eAAA,CAAgBC,MAAM;;IAErC;IACA,IAAI,CAACrB,KAAK,CAACM,QAAQ,IAAID,WAAW,CAACa,QAAQ,CAACG,MAAM,CAAC,EAAE;MACnDT,eAAe,CAACO,MAAM,GAAG,CAACP,eAAe,CAACO,MAAM,IAAI,CAAC,IAAI,CAAC;;MAE1D;MACA,MAAMG,MAAM,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG;MAClC,MAAMC,aAAa,GAAGF,IAAI,CAACG,GAAG,CAACH,IAAI,CAACI,GAAG,CAAC,CAAC,EAAEf,eAAe,CAACO,MAAM,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;MAC3E,MAAMS,KAAK,GAAGxB,cAAc,GAAGqB,aAAa,IAAI,CAAC,GAAGH,MAAM,CAAC;MAE3DO,OAAO,CAACC,GAAG,CAAC,aAAalB,eAAe,CAACO,MAAM,IAAIhB,WAAW,QAAQS,eAAe,CAACK,GAAG,UAAUM,IAAI,CAACQ,KAAK,CAACH,KAAK,CAAC,IAAI,CAAC;;MAEzH;MACA,IAAIP,MAAM,KAAK,GAAG,EAAE;QAClB;QACA,MAAMW,UAAU,GAAGhC,KAAK,CAACM,QAAQ,CAACf,OAAO,CAAC,aAAa,CAAC;QACxD,MAAM0C,UAAU,GAAGD,UAAU,GAAGE,QAAQ,CAACF,UAAU,EAAE,EAAE,CAAC,GAAG,IAAI,GAAGJ,KAAK;QAEvEC,OAAO,CAACC,GAAG,CAAC,gCAAgCG,UAAU,IAAI,CAAC;QAC3D,MAAM,IAAIhC,OAAO,CAACkC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,UAAU,CAAC,CAAC;MAC/D,CAAC,MAAM;QACL,MAAM,IAAIhC,OAAO,CAACkC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEP,KAAK,CAAC,CAAC;MAC1D;MAEA,OAAOzC,SAAS,CAACyB,eAAe,CAAC;IACnC;EACF;;EAEA;EACA,IAAIZ,KAAK,CAACM,QAAQ,IAAIN,KAAK,CAACM,QAAQ,CAACe,MAAM,KAAK,GAAG,EAAE;IACnD;IACA,IAAIT,eAAe,CAACK,GAAG,CAACC,QAAQ,CAAC,eAAe,CAAC,IACjDN,eAAe,CAACyB,aAAa,IAC7BzB,eAAe,CAACK,GAAG,CAACC,QAAQ,CAAC,aAAa,CAAC,EAAE;MAAG;MAClD,MAAM,IAAIoB,KAAK,CAAC,sBAAsB,CAAC;IACzC;;IAEI;IACA1B,eAAe,CAACyB,aAAa,GAAG,IAAI;IAEpC,IAAI;MACF;MACA,MAAME,YAAY,GAAGzC,YAAY,CAACC,OAAO,CAAC,cAAc,CAAC;MACzD,IAAI,CAACwC,YAAY,EAAE;QACjB,MAAM,IAAID,KAAK,CAAC,4BAA4B,CAAC;MAC/C;;MAEA;MACA,MAAMhC,QAAQ,GAAG,MAAMxB,KAAK,CAAC0D,IAAI,CAAC,GAAGzD,OAAO,eAAe,EAAE;QAC3DwD;MACF,CAAC,EAAE;QACDhD,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,eAAe,EAAE,IAAI,CAAC;MACxB,CAAC,CAAC;;MAEF;MACA,MAAM;QAAEK;MAAM,CAAC,GAAGS,QAAQ,CAACC,IAAI;MAC/BT,YAAY,CAAC2C,OAAO,CAAC,WAAW,EAAE5C,KAAK,CAAC;;MAExC;MACAe,eAAe,CAACrB,OAAO,CAAC,eAAe,CAAC,GAAG,UAAUM,KAAK,EAAE;MAC5D,OAAOV,SAAS,CAACyB,eAAe,CAAC;IACnC,CAAC,CAAC,OAAO8B,YAAY,EAAE;MACrB;MACA5C,YAAY,CAAC6C,UAAU,CAAC,WAAW,CAAC;MACpC7C,YAAY,CAAC6C,UAAU,CAAC,cAAc,CAAC;;MAEvC;MACA,IAAIC,MAAM,CAACC,QAAQ,CAACC,QAAQ,KAAK,QAAQ,EAAE;QACzCF,MAAM,CAACC,QAAQ,CAACE,IAAI,GAAG,QAAQ;MACjC;MAEA,MAAML,YAAY,CAAC,CAAC;IACtB;EACF;;EAEA;EACA,MAAMM,aAAa,GAAG;IACpB3B,MAAM,GAAAb,gBAAA,GAAER,KAAK,CAACM,QAAQ,cAAAE,gBAAA,uBAAdA,gBAAA,CAAgBa,MAAM;IAC9B4B,OAAO,EAAE,EAAAxC,gBAAA,GAAAT,KAAK,CAACM,QAAQ,cAAAG,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgBF,IAAI,cAAAG,qBAAA,uBAApBA,qBAAA,CAAsBuC,OAAO,KAAIjD,KAAK,CAACiD,OAAO;IACvD1C,IAAI,GAAAI,gBAAA,GAAEX,KAAK,CAACM,QAAQ,cAAAK,gBAAA,uBAAdA,gBAAA,CAAgBJ;EACxB,CAAC;EAED,OAAON,OAAO,CAACC,MAAM,CAAC8C,aAAa,CAAC;AACtC,CACF,CAAC;;AAED;AACA;AACA,MAAME,eAAe,GAAGA,CAAA,KAAM;EAC5B,MAAMrD,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,WAAW,CAAC;EAC/C,IAAI,CAACF,KAAK,EAAE,OAAO,KAAK;;EAExB;EACA,IAAI;IACF;IACA,MAAMsD,OAAO,GAAGtD,KAAK,CAACuD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACnC,IAAI,CAACD,OAAO,EAAE,OAAO,KAAK;IAE1B,MAAME,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACL,OAAO,CAAC,CAAC;IAC7C,MAAMM,cAAc,GAAGJ,WAAW,CAACK,GAAG,GAAG,IAAI,CAAC,CAAC;;IAE/C,OAAOD,cAAc,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC;EACpC,CAAC,CAAC,OAAO5D,KAAK,EAAE;IACd6B,OAAO,CAAC7B,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACtD,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA,MAAM6D,gBAAgB,GAAGA,CAAA,KAAM;EAC7B,MAAMhE,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,WAAW,CAAC;EAC/C,IAAI,CAACF,KAAK,EAAE,OAAO,IAAI;EAEvB,IAAI;IACF,MAAMsD,OAAO,GAAGtD,KAAK,CAACuD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACnC,IAAI,CAACD,OAAO,EAAE,OAAO,IAAI;IAEzB,MAAME,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACL,OAAO,CAAC,CAAC;IAC7C,OAAOE,WAAW,CAACS,EAAE;EACvB,CAAC,CAAC,OAAO9D,KAAK,EAAE;IACd6B,OAAO,CAAC7B,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC5D,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA,MAAM+D,MAAM,GAAGA,CAAA,KAAM;EACnBjE,YAAY,CAAC6C,UAAU,CAAC,WAAW,CAAC;EACpC7C,YAAY,CAAC6C,UAAU,CAAC,cAAc,CAAC;;EAEvC;EACA;EACA,OAAOxD,SAAS,CAACqD,IAAI,CAAC,cAAc,CAAC,CAACwB,KAAK,CAAChE,KAAK,IAAI;IACnD6B,OAAO,CAACoC,IAAI,CAAC,+BAA+B,EAAEjE,KAAK,CAAC;IACpD;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,MAAMkE,KAAK,GAAG,MAAOC,WAAW,IAAK;EACnC,MAAM5D,IAAI,GAAG,MAAMpB,SAAS,CAACqD,IAAI,CAAC,aAAa,EAAE2B,WAAW,CAAC;EAC7D,IAAI5D,IAAI,CAACV,KAAK,EAAE;IACdC,YAAY,CAAC2C,OAAO,CAAC,WAAW,EAAElC,IAAI,CAACV,KAAK,CAAC;EAC/C;EACA,IAAIU,IAAI,CAACgC,YAAY,EAAE;IACrBzC,YAAY,CAAC2C,OAAO,CAAC,cAAc,EAAElC,IAAI,CAACgC,YAAY,CAAC;EACzD;EACA,OAAOhC,IAAI;AACb,CAAC;;AAED;AACA,MAAM6D,OAAO,CAAC;EACZC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,eAAe,GAAG,IAAID,GAAG,CAAC,CAAC;IAChC,IAAI,CAACE,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC,CAAC;;IAEzB;IACA,IAAI,CAACC,kBAAkB,GAAG,EAAE;IAC5B,IAAI,CAACC,iBAAiB,GAAG,EAAE;;IAE3B;IACA,IAAI,CAACC,WAAW,GAAG;MACjBC,aAAa,EAAE,KAAK;MAAE;MACtBC,UAAU,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI;MAAE;MAC3BC,WAAW,EAAE,KAAK,CAAC;IACrB,CAAC;EACH;;EAEA;EACAC,eAAeA,CAAA,EAAG;IAChB,MAAMvB,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC,CAAC;;IAEtB;IACA,IAAI,CAACkB,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACM,MAAM,CAACC,IAAI,IAAIzB,GAAG,GAAGyB,IAAI,GAAG,IAAI,CAAC;;IAEjF;IACA,OAAO,IAAI,CAACP,iBAAiB,CAACQ,MAAM,IAAI,IAAI,CAACT,kBAAkB;EACjE;;EAEA;EACAU,YAAYA,CAAA,EAAG;IACb,IAAI,CAACT,iBAAiB,CAACU,IAAI,CAAC7B,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC;EACzC;;EAEA;EACA6B,aAAaA,CAACC,GAAG,EAAEC,OAAO,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxC,MAAMC,MAAM,GAAG,IAAI,CAACvB,KAAK,CAACwB,GAAG,CAACJ,GAAG,CAAC;IAClC,MAAMK,UAAU,GAAGH,OAAO,CAACI,SAAS,GAChC,IAAI,CAACjB,WAAW,CAACE,UAAU,GAC1BW,OAAO,CAACK,UAAU,GAAG,IAAI,CAAClB,WAAW,CAACG,WAAW,GAAG,IAAI,CAACH,WAAW,CAACC,aAAc;;IAExF;IACA,IAAIa,MAAM,IAAIlC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGiC,MAAM,CAACK,SAAS,GAAGH,UAAU,EAAE;MACxD,OAAO9F,OAAO,CAACkC,OAAO,CAAC0D,MAAM,CAACtF,IAAI,CAAC;IACrC;;IAEA;IACA,IAAI,IAAI,CAACiE,eAAe,CAAC2B,GAAG,CAACT,GAAG,CAAC,EAAE;MACjC,OAAO,IAAI,CAAClB,eAAe,CAACsB,GAAG,CAACJ,GAAG,CAAC;IACtC;;IAEA;IACA,MAAMhG,OAAO,GAAG,IAAI,CAAC0G,cAAc,CAAC,MAAMT,OAAO,CAAC,CAAC,CAAC,CACjDU,IAAI,CAAC9F,IAAI,IAAI;MACZ,IAAI,CAAC+D,KAAK,CAACgC,GAAG,CAACZ,GAAG,EAAE;QAClBnF,IAAI;QACJ2F,SAAS,EAAEvC,IAAI,CAACC,GAAG,CAAC;MACtB,CAAC,CAAC;MACF,IAAI,CAACY,eAAe,CAAC+B,MAAM,CAACb,GAAG,CAAC;MAChC,OAAOnF,IAAI;IACb,CAAC,CAAC,CACDyD,KAAK,CAAChE,KAAK,IAAI;MACd,IAAI,CAACwE,eAAe,CAAC+B,MAAM,CAACb,GAAG,CAAC;MAChC,MAAM1F,KAAK;IACb,CAAC,CAAC;IAEJ,IAAI,CAACwE,eAAe,CAAC8B,GAAG,CAACZ,GAAG,EAAEhG,OAAO,CAAC;IACtC,OAAOA,OAAO;EAChB;;EAEA;EACA8G,eAAeA,CAACd,GAAG,GAAG,IAAI,EAAE;IAC1B,IAAIA,GAAG,KAAK,IAAI,EAAE;MAChB,IAAI,CAACpB,KAAK,CAACmC,KAAK,CAAC,CAAC;IACpB,CAAC,MAAM,IAAI,OAAOf,GAAG,KAAK,QAAQ,EAAE;MAClC,IAAI,CAACpB,KAAK,CAACiC,MAAM,CAACb,GAAG,CAAC;IACxB,CAAC,MAAM,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;MACpC;MACA,KAAK,MAAMgB,QAAQ,IAAI,IAAI,CAACpC,KAAK,CAACqC,IAAI,CAAC,CAAC,EAAE;QACxC,IAAIjB,GAAG,CAACgB,QAAQ,CAAC,EAAE;UACjB,IAAI,CAACpC,KAAK,CAACiC,MAAM,CAACG,QAAQ,CAAC;QAC7B;MACF;IACF;EACF;;EAEA;EACAN,cAAcA,CAACQ,EAAE,EAAEC,QAAQ,GAAG,QAAQ,EAAE;IACtC,OAAO,IAAI5G,OAAO,CAAC,CAACkC,OAAO,EAAEjC,MAAM,KAAK;MACtC,MAAMR,OAAO,GAAG;QAAEkH,EAAE;QAAEzE,OAAO;QAAEjC,MAAM;QAAE2G,QAAQ;QAAEX,SAAS,EAAEvC,IAAI,CAACC,GAAG,CAAC;MAAE,CAAC;;MAExE;MACA,IAAIiD,QAAQ,KAAK,MAAM,EAAE;QACvB,IAAI,CAACpC,YAAY,CAACqC,OAAO,CAACpH,OAAO,CAAC;MACpC,CAAC,MAAM,IAAImH,QAAQ,KAAK,KAAK,EAAE;QAC7B,IAAI,CAACpC,YAAY,CAACe,IAAI,CAAC9F,OAAO,CAAC;MACjC,CAAC,MAAM;QACL;QACA,MAAMqH,KAAK,GAAG,IAAI,CAACtC,YAAY,CAACuC,SAAS,CAACC,CAAC,IAAIA,CAAC,CAACJ,QAAQ,KAAK,KAAK,CAAC;QACpE,IAAIE,KAAK,KAAK,CAAC,CAAC,EAAE;UAChB,IAAI,CAACtC,YAAY,CAACe,IAAI,CAAC9F,OAAO,CAAC;QACjC,CAAC,MAAM;UACL,IAAI,CAAC+E,YAAY,CAACyC,MAAM,CAACH,KAAK,EAAE,CAAC,EAAErH,OAAO,CAAC;QAC7C;MACF;;MAEA;MACA,IAAI,CAAC,IAAI,CAACgF,UAAU,EAAE;QACpB,IAAI,CAACyC,YAAY,CAAC,CAAC;MACrB;IACF,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMA,YAAYA,CAAA,EAAG;IACnB,IAAI,IAAI,CAACzC,UAAU,EAAE;IACrB,IAAI,CAACA,UAAU,GAAG,IAAI;IAEtB,MAAM0C,WAAW,GAAG,MAAAA,CAAA,KAAY;MAC9B;MACA,IAAI,IAAI,CAAC3C,YAAY,CAACa,MAAM,KAAK,CAAC,IAAI,IAAI,CAACX,cAAc,IAAI,IAAI,CAACC,cAAc,EAAE;QAChF,IAAI,IAAI,CAACH,YAAY,CAACa,MAAM,KAAK,CAAC,IAAI,IAAI,CAACX,cAAc,KAAK,CAAC,EAAE;UAC/D,IAAI,CAACD,UAAU,GAAG,KAAK;QACzB;QACA;MACF;;MAEA;MACA,IAAI,IAAI,CAACS,eAAe,CAAC,CAAC,EAAE;QAC1B;QACA/C,UAAU,CAAC,MAAMgF,WAAW,CAAC,CAAC,EAAE,GAAG,CAAC;QACpC;MACF;;MAEA;MACA,MAAM1H,OAAO,GAAG,IAAI,CAAC+E,YAAY,CAAC4C,KAAK,CAAC,CAAC;MACzC,IAAI,CAAC1C,cAAc,EAAE;MACrB,IAAI,CAACY,YAAY,CAAC,CAAC;MAEnB,IAAI;QACF,MAAM+B,MAAM,GAAG,MAAM5H,OAAO,CAACkH,EAAE,CAAC,CAAC;QACjClH,OAAO,CAACyC,OAAO,CAACmF,MAAM,CAAC;MACzB,CAAC,CAAC,OAAOtH,KAAK,EAAE;QACdN,OAAO,CAACQ,MAAM,CAACF,KAAK,CAAC;MACvB,CAAC,SAAS;QACR,IAAI,CAAC2E,cAAc,EAAE;QACrB;QACAyC,WAAW,CAAC,CAAC;MACf;IACF,CAAC;;IAED;IACA,MAAMG,UAAU,GAAGC,KAAK,CAACjG,IAAI,CAACG,GAAG,CAAC,IAAI,CAACkD,cAAc,EAAE,IAAI,CAACH,YAAY,CAACa,MAAM,CAAC,CAAC,CAC9EmC,IAAI,CAAC,CAAC,CACNC,GAAG,CAAC,MAAMN,WAAW,CAAC,CAAC,CAAC;IAE3B,MAAMnH,OAAO,CAAC0H,UAAU,CAACJ,UAAU,CAAC;;IAEpC;IACA,IAAI,IAAI,CAAC9C,YAAY,CAACa,MAAM,GAAG,CAAC,IAAI,IAAI,CAACX,cAAc,GAAG,IAAI,CAACC,cAAc,EAAE;MAC7E,IAAI,CAACuC,YAAY,CAAC,CAAC;IACrB,CAAC,MAAM,IAAI,IAAI,CAAC1C,YAAY,CAACa,MAAM,KAAK,CAAC,IAAI,IAAI,CAACX,cAAc,KAAK,CAAC,EAAE;MACtE,IAAI,CAACD,UAAU,GAAG,KAAK;IACzB;EACF;;EAEA;;EAEAkD,QAAQA,CAACC,MAAM,GAAG,CAAC,CAAC,EAAE;IACpB,MAAMC,WAAW,GAAG,IAAIC,eAAe,CAAC,CAAC;IAEzCC,MAAM,CAACC,OAAO,CAACJ,MAAM,CAAC,CAACK,OAAO,CAAC,CAAC,CAACxC,GAAG,EAAEyC,KAAK,CAAC,KAAK;MAC/C,IAAIA,KAAK,KAAKC,SAAS,EAAE;QACvBN,WAAW,CAACO,MAAM,CAAC3C,GAAG,EAAEyC,KAAK,CAAC;MAChC;IACF,CAAC,CAAC;IAEF,MAAMG,WAAW,GAAGR,WAAW,CAACS,QAAQ,CAAC,CAAC;IAC1C,MAAM7B,QAAQ,GAAG,SAAS4B,WAAW,EAAE;;IAEvC;IACA,OAAO,IAAI,CAAC7C,aAAa,CAACiB,QAAQ,EAAE,MAClCvH,SAAS,CAAC2G,GAAG,CAAC,UAAUwC,WAAW,EAAE,CAAC,EACtC;MAAErC,UAAU,EAAE;IAAK,CAAC,CAAC;EACzB;EAEAuC,WAAWA,CAACC,MAAM,EAAE;IAClB,MAAM/B,QAAQ,GAAG,QAAQ+B,MAAM,EAAE;IAEjC,OAAO,IAAI,CAAChD,aAAa,CAACiB,QAAQ,EAAE,MAClCvH,SAAS,CAAC2G,GAAG,CAAC,UAAU2C,MAAM,EAAE,CAClC,CAAC;EACH;EAEAC,UAAUA,CAACC,QAAQ,EAAE;IACnB;IACA,IAAI,CAACnC,eAAe,CAAEd,GAAG,IAAKA,GAAG,CAACkD,UAAU,CAAC,QAAQ,CAAC,CAAC;IAEvD,OAAO,IAAI,CAACxC,cAAc,CAAC,MACzBjH,SAAS,CAACqD,IAAI,CAAC,QAAQ,EAAEmG,QAAQ,CAAC,EAClC,MAAM,CAAC;EACX;EAEAE,UAAUA,CAACJ,MAAM,EAAEE,QAAQ,EAAE;IAC3B;IACA,IAAI,CAACnC,eAAe,CAAC,QAAQiC,MAAM,EAAE,CAAC;IACtC,IAAI,CAACjC,eAAe,CAAEd,GAAG,IAAKA,GAAG,CAACkD,UAAU,CAAC,QAAQ,CAAC,CAAC;IAEvD,OAAO,IAAI,CAACxC,cAAc,CAAC,MACzBjH,SAAS,CAAC2J,GAAG,CAAC,UAAUL,MAAM,EAAE,EAAEE,QAAQ,CAC5C,CAAC;EACH;EAEAI,UAAUA,CAACN,MAAM,EAAE;IACjB;IACA,IAAI,CAACjC,eAAe,CAAC,QAAQiC,MAAM,EAAE,CAAC;IACtC,IAAI,CAACjC,eAAe,CAAEd,GAAG,IAAKA,GAAG,CAACkD,UAAU,CAAC,QAAQ,CAAC,CAAC;IAEvD,OAAO,IAAI,CAACxC,cAAc,CAAC,MACzBjH,SAAS,CAACoH,MAAM,CAAC,UAAUkC,MAAM,EAAE,CACrC,CAAC;EACH;EAEAO,gBAAgBA,CAACP,MAAM,EAAE;IACvB;IACA,IAAI,CAACjC,eAAe,CAAC,QAAQiC,MAAM,EAAE,CAAC;IACtC,IAAI,CAACjC,eAAe,CAAEd,GAAG,IAAKA,GAAG,CAACkD,UAAU,CAAC,QAAQ,CAAC,CAAC;IAEvD,OAAO,IAAI,CAACxC,cAAc,CAAC,MACzBjH,SAAS,CAAC8J,KAAK,CAAC,UAAUR,MAAM,SAAS,CAC3C,CAAC;EACH;;EAEA;EACAS,eAAeA,CAACC,OAAO,EAAEC,UAAU,EAAE;IACnC;IACAD,OAAO,CAACjB,OAAO,CAACpE,EAAE,IAAI;MACpB,IAAI,CAAC0C,eAAe,CAAC,QAAQ1C,EAAE,EAAE,CAAC;IACpC,CAAC,CAAC;IACF,IAAI,CAAC0C,eAAe,CAAEd,GAAG,IAAKA,GAAG,CAACkD,UAAU,CAAC,QAAQ,CAAC,CAAC;IAEvD,OAAO,IAAI,CAACxC,cAAc,CAAC,MACzBjH,SAAS,CAAC2J,GAAG,CAAC,oBAAoB,EAAE;MAAEK,OAAO;MAAEC;IAAW,CAAC,CAAC,EAC5D,MAAM,CAAC;EACX;EAEAC,eAAeA,CAACF,OAAO,EAAE;IACvB;IACAA,OAAO,CAACjB,OAAO,CAACpE,EAAE,IAAI;MACpB,IAAI,CAAC0C,eAAe,CAAC,QAAQ1C,EAAE,EAAE,CAAC;IACpC,CAAC,CAAC;IACF,IAAI,CAAC0C,eAAe,CAAEd,GAAG,IAAKA,GAAG,CAACkD,UAAU,CAAC,QAAQ,CAAC,CAAC;IAEvD,OAAO,IAAI,CAACxC,cAAc,CAAC,MACzBjH,SAAS,CAACoH,MAAM,CAAC,oBAAoB,EAAE;MAAEhG,IAAI,EAAE;QAAE4I;MAAQ;IAAE,CAAC,CAAC,EAC7D,MAAM,CAAC;EACX;;EAEA;EACAG,WAAWA,CAACC,UAAU,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACpC,MAAM1B,WAAW,GAAG,IAAIC,eAAe,CAAC,CAAC;IACzCD,WAAW,CAACO,MAAM,CAAC,QAAQ,EAAEkB,UAAU,CAAC;IAExCvB,MAAM,CAACC,OAAO,CAACuB,OAAO,CAAC,CAACtB,OAAO,CAAC,CAAC,CAACxC,GAAG,EAAEyC,KAAK,CAAC,KAAK;MAChD,IAAIA,KAAK,KAAKC,SAAS,EAAE;QACvBN,WAAW,CAACO,MAAM,CAAC3C,GAAG,EAAEyC,KAAK,CAAC;MAChC;IACF,CAAC,CAAC;IAEF,MAAMG,WAAW,GAAGR,WAAW,CAACS,QAAQ,CAAC,CAAC;IAC1C,MAAM7B,QAAQ,GAAG,UAAU4B,WAAW,EAAE;;IAExC;IACA,OAAO,IAAI,CAAC7C,aAAa,CAACiB,QAAQ,EAAE,MAClCvH,SAAS,CAAC2G,GAAG,CAAC,iBAAiBwC,WAAW,EAAE,CAAC,EAC7C;MAAErC,UAAU,EAAE;IAAK,CAAC,CAAC;EACzB;;EAEA;EACAwD,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAAChE,aAAa,CAAC,YAAY,EAAE,MACtCtG,SAAS,CAAC2G,GAAG,CAAC,cAAc,CAAC,EAC7B;MAAEE,SAAS,EAAE;IAAK,CAAC,CAAC;EACxB;AACF;;AAEA;AACA,MAAM0D,OAAO,CAAC;EACZxF,KAAKA,CAACC,WAAW,EAAE;IACjB,OAAOD,KAAK,CAACC,WAAW,CAAC;EAC3B;EAEAwF,QAAQA,CAACC,QAAQ,EAAE;IACjB,OAAOzK,SAAS,CAACqD,IAAI,CAAC,gBAAgB,EAAEoH,QAAQ,CAAC;EACnD;EAEA7F,MAAMA,CAAA,EAAG;IACP,OAAOA,MAAM,CAAC,CAAC;EACjB;EAEA8F,cAAcA,CAACC,KAAK,EAAE;IACpB,OAAO3K,SAAS,CAACqD,IAAI,CAAC,uBAAuB,EAAE;MAAEsH;IAAM,CAAC,CAAC;EAC3D;EAEAC,kBAAkBA,CAAClK,KAAK,EAAE;IACxB,OAAOV,SAAS,CAAC2G,GAAG,CAAC,wBAAwBjG,KAAK,EAAE,CAAC;EACvD;EAEAmK,aAAaA,CAACnK,KAAK,EAAEoK,WAAW,EAAE;IAChC,OAAO9K,SAAS,CAACqD,IAAI,CAAC,sBAAsB,EAAE;MAAE3C,KAAK;MAAEoK;IAAY,CAAC,CAAC;EACvE;EAEA1H,YAAYA,CAAA,EAAG;IACb,MAAMA,YAAY,GAAGzC,YAAY,CAACC,OAAO,CAAC,cAAc,CAAC;IAEzD,IAAI,CAACwC,YAAY,EAAE;MACjB,OAAOtC,OAAO,CAACC,MAAM,CAAC,IAAIoC,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAChE;IAEA,OAAOnD,SAAS,CAACqD,IAAI,CAAC,eAAe,EAAE;MAAED;IAAa,CAAC,CAAC,CACrD8D,IAAI,CAAC9F,IAAI,IAAI;MACZ,IAAIA,IAAI,CAACV,KAAK,EAAE;QACdC,YAAY,CAAC2C,OAAO,CAAC,WAAW,EAAElC,IAAI,CAACV,KAAK,CAAC;MAC/C;MACA,IAAIU,IAAI,CAACgC,YAAY,EAAE;QACrBzC,YAAY,CAAC2C,OAAO,CAAC,cAAc,EAAElC,IAAI,CAACgC,YAAY,CAAC;MACzD;MACA,OAAOhC,IAAI;IACb,CAAC,CAAC;EACN;;EAEA;EACA2C,eAAeA,CAAA,EAAG;IAChB,OAAOA,eAAe,CAAC,CAAC;EAC1B;;EAEA;EACAW,gBAAgBA,CAAA,EAAG;IACjB,OAAOA,gBAAgB,CAAC,CAAC;EAC3B;AACF;;AAEA;AACA,MAAMqG,OAAO,CAAC;EACZC,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC1E,aAAa,CAAC,cAAc,EAAE,MACxCtG,SAAS,CAAC2G,GAAG,CAAC,eAAe,CAC/B,CAAC;EACH;EAEAsE,aAAaA,CAACR,QAAQ,EAAE;IACtB,IAAI,CAACpD,eAAe,CAAC,cAAc,CAAC;IAEpC,OAAOrH,SAAS,CAAC2J,GAAG,CAAC,eAAe,EAAEc,QAAQ,CAAC;EACjD;EAEAS,cAAcA,CAACC,YAAY,EAAE;IAC3B,OAAOnL,SAAS,CAAC2J,GAAG,CAAC,gBAAgB,EAAEwB,YAAY,CAAC;EACtD;;EAEA;EACA7E,aAAaA,CAACC,GAAG,EAAEC,OAAO,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxC,OAAO2E,OAAO,CAAC9E,aAAa,CAACC,GAAG,EAAEC,OAAO,EAAEC,OAAO,CAAC;EACrD;EAEAY,eAAeA,CAACd,GAAG,GAAG,IAAI,EAAE;IAC1B,OAAO6E,OAAO,CAAC/D,eAAe,CAACd,GAAG,CAAC;EACrC;AACF;;AAEA;AACA,MAAM6E,OAAO,GAAG,IAAInG,OAAO,CAAC,CAAC;AAC7B,MAAMoG,OAAO,GAAG,IAAId,OAAO,CAAC,CAAC;AAC7B,MAAMe,OAAO,GAAG,IAAIP,OAAO,CAAC,CAAC;;AAE7B;AACA,MAAMQ,GAAG,GAAG;EACVC,KAAK,EAAEJ,OAAO;EACdK,IAAI,EAAEJ,OAAO;EACbK,IAAI,EAAEJ,OAAO;EACb;EACAvH,eAAe;EACfW,gBAAgB;EAChBK,KAAK;EACLH;AACF,CAAC;;AAED;AACA,SACE5E,SAAS,EACToL,OAAO,EACPC,OAAO,EACPC,OAAO,EACPvH,eAAe,EACfW,gBAAgB;;AAGlB;AACA,eAAe6G,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}