{"ast":null,"code":"import axios from 'axios';\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\n\n// Create axios instance with defaults\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  timeout: 15000,\n  // Increased timeout for network congestion\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true // Send cookies with cross-origin requests\n});\n\n// Request interceptor for adding auth token\napiClient.interceptors.request.use(config => {\n  const token = localStorage.getItem('authToken');\n  if (token) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Enhanced response interceptor with better retry logic and rate limiting handling\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\napiClient.interceptors.response.use(response => response.data, async error => {\n  var _error$response2, _error$response3, _error$response3$data, _error$response4;\n  const originalRequest = error.config;\n\n  // Skip retry for certain endpoints to avoid duplication\n  const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\n  const shouldSkipRetry = skipRetryEndpoints.some(endpoint => originalRequest.url.includes(endpoint));\n  if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\n    var _error$response;\n    const status = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status;\n\n    // Retry on network errors or specific status codes\n    if (!error.response || RETRY_CODES.includes(status)) {\n      originalRequest._retry = (originalRequest._retry || 0) + 1;\n\n      // Calculate backoff delay with jitter to prevent thundering herd\n      const jitter = Math.random() * 0.3;\n      const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10);\n      const delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\n      console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms`);\n\n      // Special handling for rate limiting\n      if (status === 429) {\n        // Extract retry-after header if available or use our calculated delay\n        const retryAfter = error.response.headers['retry-after'];\n        const retryDelay = retryAfter ? parseInt(retryAfter, 10) * 1000 : delay;\n        console.log(`Rate limited. Retrying after ${retryDelay}ms`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n      } else {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n      return apiClient(originalRequest);\n    }\n  }\n\n  // Handle 401 Unauthorized - refresh token or redirect to login\n  if (error.response && error.response.status === 401) {\n    // Skip refresh token attempt if already in progress\n    if (originalRequest.url.includes('/auth/refresh') || originalRequest._hasRefreshed || originalRequest.url.includes('/auth/login')) {\n      // <-- Add this check\n      throw new Error('Token refresh failed');\n    }\n\n    // Flag to prevent infinite refresh loop\n    originalRequest._hasRefreshed = true;\n    try {\n      // Attempt to refresh token\n      const refreshToken = localStorage.getItem('refreshToken');\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n\n      // Call refresh token endpoint\n      const response = await axios.post(`${API_URL}/auth/refresh`, {\n        refreshToken\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        withCredentials: true // Send cookies\n      });\n\n      // Update tokens\n      const {\n        token\n      } = response.data;\n      localStorage.setItem('authToken', token);\n\n      // Update authorization header and retry\n      originalRequest.headers['Authorization'] = `Bearer ${token}`;\n      return apiClient(originalRequest);\n    } catch (refreshError) {\n      // If refresh fails, clean up tokens and redirect to login\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('refreshToken');\n\n      // Don't redirect for background API calls\n      if (window.location.pathname !== '/login') {\n        window.location.href = '/login';\n      }\n      throw refreshError; // Re-throw to properly handle the error\n    }\n  }\n\n  // Create a standardized error object\n  const errorResponse = {\n    status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status,\n    message: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || error.message,\n    data: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data\n  };\n  return Promise.reject(errorResponse);\n});\n\n// Authentication utilities\n// Check if user is authenticated\nconst isAuthenticated = () => {\n  const token = localStorage.getItem('authToken');\n  if (!token) return false;\n\n  // Optional: Check if token is expired\n  try {\n    // Get payload from JWT (token structure: header.payload.signature)\n    const payload = token.split('.')[1];\n    if (!payload) return false;\n    const decodedData = JSON.parse(atob(payload));\n    const expirationTime = decodedData.exp * 1000; // Convert to milliseconds\n\n    return expirationTime > Date.now();\n  } catch (error) {\n    console.error('Error checking token validity:', error);\n    return false;\n  }\n};\n\n// Get current user ID from token\nconst getCurrentUserId = () => {\n  const token = localStorage.getItem('authToken');\n  if (!token) return null;\n  try {\n    const payload = token.split('.')[1];\n    if (!payload) return null;\n    const decodedData = JSON.parse(atob(payload));\n    return decodedData.id;\n  } catch (error) {\n    console.error('Error extracting user ID from token:', error);\n    return null;\n  }\n};\n\n// Logout helper\nconst logout = () => {\n  localStorage.removeItem('authToken');\n  localStorage.removeItem('refreshToken');\n\n  // If you're using cookies for refresh tokens, you would also clear them here\n  // via the logout API endpoint\n  return apiClient.post('/auth/logout').catch(error => {\n    console.warn('Error during logout API call:', error);\n    // Continue with client-side logout even if server logout fails\n  });\n};\n\n// Login helper\nconst login = async credentials => {\n  const data = await apiClient.post('/auth/login', credentials);\n  if (data.token) {\n    localStorage.setItem('authToken', data.token);\n  }\n  if (data.refreshToken) {\n    localStorage.setItem('refreshToken', data.refreshToken);\n  }\n  return data;\n};\nclass TaskAPI {\n  constructor(client) {\n    apiClient = client; // Pass your configured apiClient instance\n    if (!apiClient) {\n      console.error(\"TaskAPI initialized without an apiClient. API calls will fail.\");\n      // Fallback to a dummy client to prevent crashes, but log error\n      apiClient = {\n        get: () => Promise.reject(new Error(\"apiClient not configured\")),\n        post: () => Promise.reject(new Error(\"apiClient not configured\")),\n        put: () => Promise.reject(new Error(\"apiClient not configured\")),\n        patch: () => Promise.reject(new Error(\"apiClient not configured\")),\n        delete: () => Promise.reject(new Error(\"apiClient not configured\"))\n      };\n    }\n    this.cache = new Map();\n    this.pendingRequests = new Map(); // Stores promises of pending requests for deduplication\n    this.requestQueue = [];\n    this.processing = false; // Lock for the manager part of processQueue\n    this.activeRequests = 0; // Count of currently active network requests\n    this.MAX_CONCURRENT = 6;\n    this.rateLimitPerSecond = 10;\n    this.requestTimestamps = [];\n    this.cacheConfig = {\n      defaultExpiry: 30 * 1000,\n      // 30 seconds\n      longExpiry: 5 * 60 * 1000,\n      // 5 minutes\n      shortExpiry: 10 * 1000 // 10 seconds\n    };\n  }\n  shouldRateLimit() {\n    const now = Date.now();\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\n    return this.requestTimestamps.length >= this.rateLimitPerSecond;\n  }\n  trackRequest() {\n    this.requestTimestamps.push(Date.now());\n  }\n  getCachedData(key, fetchFn, options = {}) {\n    const cached = this.cache.get(key);\n    const expiryTime = options.longCache ? this.cacheConfig.longExpiry : options.shortCache ? this.cacheConfig.shortExpiry : this.cacheConfig.defaultExpiry;\n    if (cached && Date.now() - cached.timestamp < expiryTime) {\n      return Promise.resolve(cached.data);\n    }\n    if (this.pendingRequests.has(key)) {\n      return this.pendingRequests.get(key);\n    }\n    const requestPromise = this.enqueueRequest(() => fetchFn()).then(data => {\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now()\n      });\n      this.pendingRequests.delete(key);\n      return data;\n    }).catch(error => {\n      this.pendingRequests.delete(key);\n      // Optionally, cache errors for a short period to prevent hammering on failure\n      // this.cache.set(key, { error, timestamp: Date.now(), isError: true });\n      throw error;\n    });\n    this.pendingRequests.set(key, requestPromise);\n    return requestPromise;\n  }\n  invalidateCache(key = null) {\n    if (key === null) {\n      this.cache.clear();\n      // console.log('Cache cleared entirely');\n    } else if (typeof key === 'string') {\n      this.cache.delete(key);\n      // console.log(`Cache invalidated for key: ${key}`);\n    } else if (typeof key === 'function') {\n      let invalidatedCount = 0;\n      for (const cacheKey of this.cache.keys()) {\n        if (key(cacheKey)) {\n          this.cache.delete(cacheKey);\n          invalidatedCount++;\n        }\n      }\n      // console.log(`Cache invalidated for ${invalidatedCount} keys matching function.`);\n    }\n  }\n  enqueueRequest(fn, priority = 'normal') {\n    return new Promise((resolve, reject) => {\n      const request = {\n        fn,\n        resolve,\n        reject,\n        priority,\n        timestamp: Date.now()\n      };\n      let inserted = false;\n      if (priority === 'high') {\n        this.requestQueue.unshift(request);\n        inserted = true;\n      } else {\n        // For 'normal' and 'low'\n        // Find first 'low' priority item to insert 'normal' before it\n        const lowPriorityIndex = this.requestQueue.findIndex(r => r.priority === 'low');\n        if (priority === 'normal') {\n          if (lowPriorityIndex !== -1) {\n            this.requestQueue.splice(lowPriorityIndex, 0, request);\n          } else {\n            this.requestQueue.push(request); // No low priority, add to end\n          }\n        } else {\n          // 'low' priority\n          this.requestQueue.push(request); // Add to end\n        }\n        inserted = true;\n      }\n      if (!inserted) this.requestQueue.push(request); // Fallback\n\n      this.processQueue(); // Attempt to process the queue\n    });\n  }\n\n  // processQueue is the \"manager\" that initiates \"worker\" chains (processNext calls).\n  // `this.processing` is a lock to prevent the manager from running multiple times concurrently.\n  // `processNext` is a \"worker\" function; each call handles one request and then recursively\n  // calls itself to pick up the next request from the queue.\n  // `this.activeRequests` is incremented/decremented by each worker.\n  async processQueue() {\n    if (this.processing) {\n      // If manager is already running, let it finish its current cycle.\n      return;\n    }\n    this.processing = true; // Manager starts its cycle.\n\n    // `processNext` is the core worker logic.\n    const processNext = async () => {\n      // Worker checks if it should proceed.\n      if (this.requestQueue.length === 0) {\n        // No more tasks for this worker chain to pick up.\n        // The `activeRequests` count will be decremented in finally.\n        return;\n      }\n      if (this.shouldRateLimit()) {\n        // This worker chain is rate-limited, retry after a delay.\n        setTimeout(processNext, 100);\n        return;\n      }\n      const request = this.requestQueue.shift(); // Worker takes a task from the front.\n      if (!request) {\n        // Should be redundant if queue.length > 0, but for safety.\n        return;\n      }\n      this.activeRequests++; // This worker is now processing a task.\n      this.trackRequest(); // Track the attempt for rate limiting.\n\n      try {\n        const result = await request.fn();\n        request.resolve(result);\n      } catch (error) {\n        request.reject(error);\n      } finally {\n        this.activeRequests--; // Worker finished this task.\n        // This worker chain attempts to pick up the next task.\n        processNext(); // Recursive call to continue the chain.\n      }\n    };\n\n    // Manager's job: Launch new worker chains (processNext calls) if there are available slots.\n    // It will try to fill up to MAX_CONCURRENT active workers.\n    // The `processors` array and `Promise.allSettled` from the prompt's code\n    // implies waiting for the first task of each newly launched chain.\n    const chainsToLaunch = [];\n    while (this.activeRequests < this.MAX_CONCURRENT && this.requestQueue.length > 0) {\n      // Before launching a new chain, check global rate limit.\n      // If we are rate-limited, the manager should pause and try later.\n      if (this.shouldRateLimit()) {\n        // Manager pauses, will retry later when processQueue is called again.\n        // Set processing to false so it can be re-entered.\n        this.processing = false;\n        setTimeout(() => this.processQueue(), 100 + Math.random() * 50); // Stagger retry\n        return;\n      }\n      // A new worker chain (processNext call) is about to be started.\n      // `activeRequests` will be incremented *inside* processNext when it picks a task.\n      // So, we just launch it.\n      chainsToLaunch.push(processNext());\n      // Note: The prompt's code had `activeRequests` incremented inside processNext.\n      // If we start N chains, each will inc/dec activeRequests.\n      // The `this.activeRequests < this.MAX_CONCURRENT` check here is crucial.\n    }\n\n    // If chains were launched, wait for their *initial* task completion as per prompt's structure.\n    // This part is unusual for typical queue processors but follows the prompt's design.\n    if (chainsToLaunch.length > 0) {\n      await Promise.allSettled(chainsToLaunch);\n    }\n\n    // After the initial batch of tasks from newly launched chains (if any) are done,\n    // the manager re-evaluates if it needs to run again.\n    if (this.requestQueue.length > 0 && this.activeRequests < this.MAX_CONCURRENT) {\n      this.processing = false; // Release lock before recursive call\n      this.processQueue(); // More work to do and slots available, manager re-runs.\n    } else if (this.requestQueue.length === 0 && this.activeRequests === 0) {\n      // Queue is empty and no requests are active, manager can truly stop.\n      this.processing = false;\n    } else {\n      // Queue might have items but all workers are busy, or other conditions.\n      // Manager cycle ends for now. It will be re-triggered by enqueueRequest or worker completion.\n      this.processing = false;\n    }\n  }\n\n  // --- API Methods ---\n\n  getTasks(params = {}) {\n    const queryParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && value !== '') {\n        queryParams.append(key, value);\n      }\n    });\n    const queryString = queryParams.toString();\n    const cacheKey = `tasks_${queryString || 'all'}`;\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks?${queryString}`), {\n      shortCache: true\n    });\n  }\n  getTaskById(taskId) {\n    const cacheKey = `task_${taskId}`;\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/${taskId}`));\n  }\n  createTask(taskData) {\n    this.invalidateCache(key => key.startsWith('tasks_')); // Invalidate all task list caches\n    this.invalidateCache('task_stats'); // Invalidate stats\n    return this.enqueueRequest(() => apiClient.post('/tasks', taskData), 'high');\n  }\n  updateTask(taskId, taskData) {\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    this.invalidateCache('task_stats');\n    return this.enqueueRequest(() => apiClient.put(`/tasks/${taskId}`, taskData));\n  }\n  deleteTask(taskId) {\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    this.invalidateCache('task_stats');\n    return this.enqueueRequest(() => apiClient.delete(`/tasks/${taskId}`));\n  }\n  toggleTaskStatus(taskId) {\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    this.invalidateCache('task_stats');\n    return this.enqueueRequest(() => apiClient.patch(`/tasks/${taskId}/toggle`));\n  }\n\n  // For dedicated search endpoint if used\n  searchTasks(searchTerm, filters = {}) {\n    const queryParams = new URLSearchParams();\n    queryParams.append('search', searchTerm);\n    Object.entries(filters).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && value !== '') {\n        queryParams.append(key, value);\n      }\n    });\n    const queryString = queryParams.toString();\n    const cacheKey = `search_${queryString}`;\n    // Search results might change very frequently or be less critical to cache long\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/search?${queryString}`), {\n      shortCache: true\n    });\n  }\n  getTaskStats() {\n    return this.getCachedData('task_stats', () => apiClient.get('/tasks/stats'), {\n      longCache: true\n    });\n  }\n  bulkUpdateTasks(taskIds, updateData) {\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    this.invalidateCache('task_stats');\n    // Backend expects { taskIds, updateData } in body for PUT\n    return this.enqueueRequest(() => apiClient.put('/tasks/bulk-update', {\n      taskIds,\n      updateData\n    }), 'high');\n  }\n  bulkDeleteTasks(taskIds) {\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    this.invalidateCache('task_stats');\n    // Backend expects { taskIds } in body for DELETE\n    return this.enqueueRequest(() => apiClient.delete('/tasks/bulk-delete', {\n      data: {\n        taskIds\n      }\n    }), 'high');\n  }\n}\n// Authentication API with token management\nclass AuthAPI {\n  login(credentials) {\n    return login(credentials);\n  }\n  register(userData) {\n    return apiClient.post('/auth/register', userData);\n  }\n  logout() {\n    return logout();\n  }\n  forgotPassword(email) {\n    return apiClient.post('/auth/forgot-password', {\n      email\n    });\n  }\n  validateResetToken(token) {\n    return apiClient.get(`/auth/reset-password/${token}`);\n  }\n  resetPassword(token, newPassword) {\n    return apiClient.post('/auth/reset-password', {\n      token,\n      newPassword\n    });\n  }\n  refreshToken() {\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      return Promise.reject(new Error('No refresh token available'));\n    }\n    return apiClient.post('/auth/refresh', {\n      refreshToken\n    }).then(data => {\n      if (data.token) {\n        localStorage.setItem('authToken', data.token);\n      }\n      if (data.refreshToken) {\n        localStorage.setItem('refreshToken', data.refreshToken);\n      }\n      return data;\n    });\n  }\n\n  // Check if the user is authenticated\n  isAuthenticated() {\n    return isAuthenticated();\n  }\n\n  // Get current user ID\n  getCurrentUserId() {\n    return getCurrentUserId();\n  }\n}\n\n// User API for profile management\nclass UserAPI {\n  getProfile() {\n    return this.getCachedData('user_profile', () => apiClient.get('/user/profile'));\n  }\n  updateProfile(userData) {\n    this.invalidateCache('user_profile');\n    return apiClient.put('/user/profile', userData);\n  }\n  changePassword(passwordData) {\n    return apiClient.put('/user/password', passwordData);\n  }\n\n  // Inherit caching methods from TaskAPI\n  getCachedData(key, fetchFn, options = {}) {\n    return taskApi.getCachedData(key, fetchFn, options);\n  }\n  invalidateCache(key = null) {\n    return taskApi.invalidateCache(key);\n  }\n}\n\n// Create instances of the API classes\nconst taskApi = new TaskAPI();\nconst authApi = new AuthAPI();\nconst userApi = new UserAPI();\n\n// Create a consolidated API object that includes utility functions\nconst api = {\n  tasks: taskApi,\n  auth: authApi,\n  user: userApi,\n  // Add utility functions at the top level for convenience\n  isAuthenticated,\n  getCurrentUserId,\n  login,\n  logout\n};\n\n// Export the API instances and client\nexport { apiClient, taskApi, authApi, userApi, isAuthenticated, getCurrentUserId };\n\n// Default export for convenience\nexport default api;","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","apiClient","create","baseURL","timeout","headers","withCredentials","interceptors","request","use","config","token","localStorage","getItem","error","Promise","reject","MAX_RETRIES","RETRY_DELAY_MS","RETRY_CODES","response","data","_error$response2","_error$response3","_error$response3$data","_error$response4","originalRequest","skipRetryEndpoints","shouldSkipRetry","some","endpoint","url","includes","_retry","_error$response","status","jitter","Math","random","backoffFactor","min","pow","delay","console","log","round","retryAfter","retryDelay","parseInt","resolve","setTimeout","_hasRefreshed","Error","refreshToken","post","setItem","refreshError","removeItem","window","location","pathname","href","errorResponse","message","isAuthenticated","payload","split","decodedData","JSON","parse","atob","expirationTime","exp","Date","now","getCurrentUserId","id","logout","catch","warn","login","credentials","TaskAPI","constructor","client","get","put","patch","delete","cache","Map","pendingRequests","requestQueue","processing","activeRequests","MAX_CONCURRENT","rateLimitPerSecond","requestTimestamps","cacheConfig","defaultExpiry","longExpiry","shortExpiry","shouldRateLimit","filter","time","length","trackRequest","push","getCachedData","key","fetchFn","options","cached","expiryTime","longCache","shortCache","timestamp","has","requestPromise","enqueueRequest","then","set","invalidateCache","clear","invalidatedCount","cacheKey","keys","fn","priority","inserted","unshift","lowPriorityIndex","findIndex","r","splice","processQueue","processNext","shift","result","chainsToLaunch","allSettled","getTasks","params","queryParams","URLSearchParams","Object","entries","forEach","value","undefined","append","queryString","toString","getTaskById","taskId","createTask","taskData","startsWith","updateTask","deleteTask","toggleTaskStatus","searchTasks","searchTerm","filters","getTaskStats","bulkUpdateTasks","taskIds","updateData","bulkDeleteTasks","AuthAPI","register","userData","forgotPassword","email","validateResetToken","resetPassword","newPassword","UserAPI","getProfile","updateProfile","changePassword","passwordData","taskApi","authApi","userApi","api","tasks","auth","user"],"sources":["D:/Projects/todo list/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\r\n\r\n// Create axios instance with defaults\r\nconst apiClient = axios.create({\r\n  baseURL: API_URL,\r\n  timeout: 15000, // Increased timeout for network congestion\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n  withCredentials: true // Send cookies with cross-origin requests\r\n});\r\n\r\n// Request interceptor for adding auth token\r\napiClient.interceptors.request.use(\r\n  config => {\r\n    const token = localStorage.getItem('authToken');\r\n    if (token) {\r\n      config.headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  error => Promise.reject(error)\r\n);\r\n\r\n// Enhanced response interceptor with better retry logic and rate limiting handling\r\nconst MAX_RETRIES = 3;\r\nconst RETRY_DELAY_MS = 1000;\r\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\r\n\r\napiClient.interceptors.response.use(\r\n  response => response.data,\r\n  async error => {\r\n    const originalRequest = error.config;\r\n    \r\n    // Skip retry for certain endpoints to avoid duplication\r\n    const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\r\n    const shouldSkipRetry = skipRetryEndpoints.some(endpoint => originalRequest.url.includes(endpoint));\r\n    \r\n    if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\r\n      const status = error.response?.status;\r\n      \r\n      // Retry on network errors or specific status codes\r\n      if (!error.response || RETRY_CODES.includes(status)) {\r\n        originalRequest._retry = (originalRequest._retry || 0) + 1;\r\n        \r\n        // Calculate backoff delay with jitter to prevent thundering herd\r\n        const jitter = Math.random() * 0.3;\r\n        const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10);\r\n        const delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\r\n        \r\n        console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms`);\r\n        \r\n        // Special handling for rate limiting\r\n        if (status === 429) {\r\n          // Extract retry-after header if available or use our calculated delay\r\n          const retryAfter = error.response.headers['retry-after'];\r\n          const retryDelay = retryAfter ? parseInt(retryAfter, 10) * 1000 : delay;\r\n          \r\n          console.log(`Rate limited. Retrying after ${retryDelay}ms`);\r\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\r\n        } else {\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n        \r\n        return apiClient(originalRequest);\r\n      }\r\n    }\r\n    \r\n    // Handle 401 Unauthorized - refresh token or redirect to login\r\n    if (error.response && error.response.status === 401) {\r\n      // Skip refresh token attempt if already in progress\r\n      if (originalRequest.url.includes('/auth/refresh') || \r\n      originalRequest._hasRefreshed ||\r\n      originalRequest.url.includes('/auth/login')) {  // <-- Add this check\r\n    throw new Error('Token refresh failed');\r\n  }\r\n      \r\n      // Flag to prevent infinite refresh loop\r\n      originalRequest._hasRefreshed = true;\r\n      \r\n      try {\r\n        // Attempt to refresh token\r\n        const refreshToken = localStorage.getItem('refreshToken');\r\n        if (!refreshToken) {\r\n          throw new Error('No refresh token available');\r\n        }\r\n        \r\n        // Call refresh token endpoint\r\n        const response = await axios.post(`${API_URL}/auth/refresh`, {\r\n          refreshToken\r\n        }, {\r\n          headers: {\r\n            'Content-Type': 'application/json'\r\n          },\r\n          withCredentials: true // Send cookies\r\n        });\r\n        \r\n        // Update tokens\r\n        const { token } = response.data;\r\n        localStorage.setItem('authToken', token);\r\n        \r\n        // Update authorization header and retry\r\n        originalRequest.headers['Authorization'] = `Bearer ${token}`;\r\n        return apiClient(originalRequest);\r\n      } catch (refreshError) {\r\n        // If refresh fails, clean up tokens and redirect to login\r\n        localStorage.removeItem('authToken');\r\n        localStorage.removeItem('refreshToken');\r\n        \r\n        // Don't redirect for background API calls\r\n        if (window.location.pathname !== '/login') {\r\n          window.location.href = '/login';\r\n        }\r\n        \r\n        throw refreshError; // Re-throw to properly handle the error\r\n      }\r\n    }\r\n    \r\n    // Create a standardized error object\r\n    const errorResponse = {\r\n      status: error.response?.status,\r\n      message: error.response?.data?.message || error.message,\r\n      data: error.response?.data\r\n    };\r\n    \r\n    return Promise.reject(errorResponse);\r\n  }\r\n);\r\n\r\n// Authentication utilities\r\n// Check if user is authenticated\r\nconst isAuthenticated = () => {\r\n  const token = localStorage.getItem('authToken');\r\n  if (!token) return false;\r\n  \r\n  // Optional: Check if token is expired\r\n  try {\r\n    // Get payload from JWT (token structure: header.payload.signature)\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return false;\r\n    \r\n    const decodedData = JSON.parse(atob(payload));\r\n    const expirationTime = decodedData.exp * 1000; // Convert to milliseconds\r\n    \r\n    return expirationTime > Date.now();\r\n  } catch (error) {\r\n    console.error('Error checking token validity:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Get current user ID from token\r\nconst getCurrentUserId = () => {\r\n  const token = localStorage.getItem('authToken');\r\n  if (!token) return null;\r\n  \r\n  try {\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return null;\r\n    \r\n    const decodedData = JSON.parse(atob(payload));\r\n    return decodedData.id;\r\n  } catch (error) {\r\n    console.error('Error extracting user ID from token:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Logout helper\r\nconst logout = () => {\r\n  localStorage.removeItem('authToken');\r\n  localStorage.removeItem('refreshToken');\r\n  \r\n  // If you're using cookies for refresh tokens, you would also clear them here\r\n  // via the logout API endpoint\r\n  return apiClient.post('/auth/logout').catch(error => {\r\n    console.warn('Error during logout API call:', error);\r\n    // Continue with client-side logout even if server logout fails\r\n  });\r\n};\r\n\r\n// Login helper\r\nconst login = async (credentials) => {\r\n  const data = await apiClient.post('/auth/login', credentials);\r\n  if (data.token) {\r\n    localStorage.setItem('authToken', data.token);\r\n  }\r\n  if (data.refreshToken) {\r\n    localStorage.setItem('refreshToken', data.refreshToken);\r\n  }\r\n  return data;\r\n};\r\nclass TaskAPI {\r\n  constructor(client) {\r\n    apiClient = client; // Pass your configured apiClient instance\r\n    if (!apiClient) {\r\n        console.error(\"TaskAPI initialized without an apiClient. API calls will fail.\");\r\n        // Fallback to a dummy client to prevent crashes, but log error\r\n        apiClient = {\r\n            get: () => Promise.reject(new Error(\"apiClient not configured\")),\r\n            post: () => Promise.reject(new Error(\"apiClient not configured\")),\r\n            put: () => Promise.reject(new Error(\"apiClient not configured\")),\r\n            patch: () => Promise.reject(new Error(\"apiClient not configured\")),\r\n            delete: () => Promise.reject(new Error(\"apiClient not configured\")),\r\n        };\r\n    }\r\n    this.cache = new Map();\r\n    this.pendingRequests = new Map(); // Stores promises of pending requests for deduplication\r\n    this.requestQueue = [];\r\n    this.processing = false; // Lock for the manager part of processQueue\r\n    this.activeRequests = 0; // Count of currently active network requests\r\n    this.MAX_CONCURRENT = 6;\r\n\r\n    this.rateLimitPerSecond = 10;\r\n    this.requestTimestamps = [];\r\n\r\n    this.cacheConfig = {\r\n      defaultExpiry: 30 * 1000,  // 30 seconds\r\n      longExpiry: 5 * 60 * 1000, // 5 minutes\r\n      shortExpiry: 10 * 1000,    // 10 seconds\r\n    };\r\n  }\r\n\r\n  shouldRateLimit() {\r\n    const now = Date.now();\r\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\r\n    return this.requestTimestamps.length >= this.rateLimitPerSecond;\r\n  }\r\n\r\n  trackRequest() {\r\n    this.requestTimestamps.push(Date.now());\r\n  }\r\n\r\n  getCachedData(key, fetchFn, options = {}) {\r\n    const cached = this.cache.get(key);\r\n    const expiryTime = options.longCache\r\n      ? this.cacheConfig.longExpiry\r\n      : (options.shortCache ? this.cacheConfig.shortExpiry : this.cacheConfig.defaultExpiry);\r\n\r\n    if (cached && Date.now() - cached.timestamp < expiryTime) {\r\n      return Promise.resolve(cached.data);\r\n    }\r\n\r\n    if (this.pendingRequests.has(key)) {\r\n      return this.pendingRequests.get(key);\r\n    }\r\n\r\n    const requestPromise = this.enqueueRequest(() => fetchFn())\r\n      .then(data => {\r\n        this.cache.set(key, { data, timestamp: Date.now() });\r\n        this.pendingRequests.delete(key);\r\n        return data;\r\n      })\r\n      .catch(error => {\r\n        this.pendingRequests.delete(key);\r\n        // Optionally, cache errors for a short period to prevent hammering on failure\r\n        // this.cache.set(key, { error, timestamp: Date.now(), isError: true });\r\n        throw error;\r\n      });\r\n\r\n    this.pendingRequests.set(key, requestPromise);\r\n    return requestPromise;\r\n  }\r\n\r\n  invalidateCache(key = null) {\r\n    if (key === null) {\r\n      this.cache.clear();\r\n      // console.log('Cache cleared entirely');\r\n    } else if (typeof key === 'string') {\r\n      this.cache.delete(key);\r\n      // console.log(`Cache invalidated for key: ${key}`);\r\n    } else if (typeof key === 'function') {\r\n      let invalidatedCount = 0;\r\n      for (const cacheKey of this.cache.keys()) {\r\n        if (key(cacheKey)) {\r\n          this.cache.delete(cacheKey);\r\n          invalidatedCount++;\r\n        }\r\n      }\r\n      // console.log(`Cache invalidated for ${invalidatedCount} keys matching function.`);\r\n    }\r\n  }\r\n\r\n  enqueueRequest(fn, priority = 'normal') {\r\n    return new Promise((resolve, reject) => {\r\n      const request = { fn, resolve, reject, priority, timestamp: Date.now() };\r\n\r\n      let inserted = false;\r\n      if (priority === 'high') {\r\n        this.requestQueue.unshift(request);\r\n        inserted = true;\r\n      } else { // For 'normal' and 'low'\r\n        // Find first 'low' priority item to insert 'normal' before it\r\n        const lowPriorityIndex = this.requestQueue.findIndex(r => r.priority === 'low');\r\n        if (priority === 'normal') {\r\n          if (lowPriorityIndex !== -1) {\r\n            this.requestQueue.splice(lowPriorityIndex, 0, request);\r\n          } else {\r\n            this.requestQueue.push(request); // No low priority, add to end\r\n          }\r\n        } else { // 'low' priority\r\n          this.requestQueue.push(request); // Add to end\r\n        }\r\n        inserted = true;\r\n      }\r\n      if (!inserted) this.requestQueue.push(request); // Fallback\r\n\r\n      this.processQueue(); // Attempt to process the queue\r\n    });\r\n  }\r\n\r\n  // processQueue is the \"manager\" that initiates \"worker\" chains (processNext calls).\r\n  // `this.processing` is a lock to prevent the manager from running multiple times concurrently.\r\n  // `processNext` is a \"worker\" function; each call handles one request and then recursively\r\n  // calls itself to pick up the next request from the queue.\r\n  // `this.activeRequests` is incremented/decremented by each worker.\r\n  async processQueue() {\r\n    if (this.processing) { // If manager is already running, let it finish its current cycle.\r\n        return;\r\n    }\r\n    this.processing = true; // Manager starts its cycle.\r\n\r\n    // `processNext` is the core worker logic.\r\n    const processNext = async () => {\r\n      // Worker checks if it should proceed.\r\n      if (this.requestQueue.length === 0) {\r\n        // No more tasks for this worker chain to pick up.\r\n        // The `activeRequests` count will be decremented in finally.\r\n        return;\r\n      }\r\n\r\n      if (this.shouldRateLimit()) {\r\n        // This worker chain is rate-limited, retry after a delay.\r\n        setTimeout(processNext, 100);\r\n        return;\r\n      }\r\n\r\n      const request = this.requestQueue.shift(); // Worker takes a task from the front.\r\n      if (!request) { // Should be redundant if queue.length > 0, but for safety.\r\n        return;\r\n      }\r\n\r\n      this.activeRequests++; // This worker is now processing a task.\r\n      this.trackRequest();   // Track the attempt for rate limiting.\r\n\r\n      try {\r\n        const result = await request.fn();\r\n        request.resolve(result);\r\n      } catch (error) {\r\n        request.reject(error);\r\n      } finally {\r\n        this.activeRequests--; // Worker finished this task.\r\n        // This worker chain attempts to pick up the next task.\r\n        processNext(); // Recursive call to continue the chain.\r\n      }\r\n    };\r\n\r\n    // Manager's job: Launch new worker chains (processNext calls) if there are available slots.\r\n    // It will try to fill up to MAX_CONCURRENT active workers.\r\n    // The `processors` array and `Promise.allSettled` from the prompt's code\r\n    // implies waiting for the first task of each newly launched chain.\r\n    const chainsToLaunch = [];\r\n    while (this.activeRequests < this.MAX_CONCURRENT && this.requestQueue.length > 0) {\r\n        // Before launching a new chain, check global rate limit.\r\n        // If we are rate-limited, the manager should pause and try later.\r\n        if (this.shouldRateLimit()) {\r\n            // Manager pauses, will retry later when processQueue is called again.\r\n            // Set processing to false so it can be re-entered.\r\n            this.processing = false;\r\n            setTimeout(() => this.processQueue(), 100 + Math.random() * 50); // Stagger retry\r\n            return;\r\n        }\r\n        // A new worker chain (processNext call) is about to be started.\r\n        // `activeRequests` will be incremented *inside* processNext when it picks a task.\r\n        // So, we just launch it.\r\n        chainsToLaunch.push(processNext());\r\n        // Note: The prompt's code had `activeRequests` incremented inside processNext.\r\n        // If we start N chains, each will inc/dec activeRequests.\r\n        // The `this.activeRequests < this.MAX_CONCURRENT` check here is crucial.\r\n    }\r\n    \r\n    // If chains were launched, wait for their *initial* task completion as per prompt's structure.\r\n    // This part is unusual for typical queue processors but follows the prompt's design.\r\n    if (chainsToLaunch.length > 0) {\r\n        await Promise.allSettled(chainsToLaunch);\r\n    }\r\n\r\n    // After the initial batch of tasks from newly launched chains (if any) are done,\r\n    // the manager re-evaluates if it needs to run again.\r\n    if (this.requestQueue.length > 0 && this.activeRequests < this.MAX_CONCURRENT) {\r\n      this.processing = false; // Release lock before recursive call\r\n      this.processQueue();     // More work to do and slots available, manager re-runs.\r\n    } else if (this.requestQueue.length === 0 && this.activeRequests === 0) {\r\n      // Queue is empty and no requests are active, manager can truly stop.\r\n      this.processing = false;\r\n    } else {\r\n      // Queue might have items but all workers are busy, or other conditions.\r\n      // Manager cycle ends for now. It will be re-triggered by enqueueRequest or worker completion.\r\n      this.processing = false;\r\n    }\r\n  }\r\n\r\n  // --- API Methods ---\r\n\r\n  getTasks(params = {}) {\r\n    const queryParams = new URLSearchParams();\r\n    Object.entries(params).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null && value !== '') {\r\n        queryParams.append(key, value);\r\n      }\r\n    });\r\n    const queryString = queryParams.toString();\r\n    const cacheKey = `tasks_${queryString || 'all'}`;\r\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks?${queryString}`), { shortCache: true });\r\n  }\r\n\r\n  getTaskById(taskId) {\r\n    const cacheKey = `task_${taskId}`;\r\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/${taskId}`));\r\n  }\r\n\r\n  createTask(taskData) {\r\n    this.invalidateCache(key => key.startsWith('tasks_')); // Invalidate all task list caches\r\n    this.invalidateCache('task_stats'); // Invalidate stats\r\n    return this.enqueueRequest(() => apiClient.post('/tasks', taskData), 'high');\r\n  }\r\n\r\n  updateTask(taskId, taskData) {\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache(key => key.startsWith('tasks_'));\r\n    this.invalidateCache('task_stats');\r\n    return this.enqueueRequest(() => apiClient.put(`/tasks/${taskId}`, taskData));\r\n  }\r\n\r\n  deleteTask(taskId) {\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache(key => key.startsWith('tasks_'));\r\n    this.invalidateCache('task_stats');\r\n    return this.enqueueRequest(() => apiClient.delete(`/tasks/${taskId}`));\r\n  }\r\n\r\n  toggleTaskStatus(taskId) {\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache(key => key.startsWith('tasks_'));\r\n    this.invalidateCache('task_stats');\r\n    return this.enqueueRequest(() => apiClient.patch(`/tasks/${taskId}/toggle`));\r\n  }\r\n  \r\n  // For dedicated search endpoint if used\r\n  searchTasks(searchTerm, filters = {}) {\r\n    const queryParams = new URLSearchParams();\r\n    queryParams.append('search', searchTerm);\r\n    Object.entries(filters).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null && value !== '') {\r\n        queryParams.append(key, value);\r\n      }\r\n    });\r\n    const queryString = queryParams.toString();\r\n    const cacheKey = `search_${queryString}`;\r\n    // Search results might change very frequently or be less critical to cache long\r\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/search?${queryString}`), { shortCache: true });\r\n  }\r\n\r\n  getTaskStats() {\r\n    return this.getCachedData('task_stats', () => apiClient.get('/tasks/stats'), { longCache: true });\r\n  }\r\n\r\n  bulkUpdateTasks(taskIds, updateData) {\r\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\r\n    this.invalidateCache(key => key.startsWith('tasks_'));\r\n    this.invalidateCache('task_stats');\r\n    // Backend expects { taskIds, updateData } in body for PUT\r\n    return this.enqueueRequest(() => apiClient.put('/tasks/bulk-update', { taskIds, updateData }), 'high');\r\n  }\r\n\r\n  bulkDeleteTasks(taskIds) {\r\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\r\n    this.invalidateCache(key => key.startsWith('tasks_'));\r\n    this.invalidateCache('task_stats');\r\n    // Backend expects { taskIds } in body for DELETE\r\n    return this.enqueueRequest(() => apiClient.delete('/tasks/bulk-delete', { data: { taskIds } }), 'high');\r\n  }\r\n}\r\n// Authentication API with token management\r\nclass AuthAPI {\r\n  login(credentials) {\r\n    return login(credentials);\r\n  }\r\n  \r\n  register(userData) {\r\n    return apiClient.post('/auth/register', userData);\r\n  }\r\n  \r\n  logout() {\r\n    return logout();\r\n  }\r\n  \r\n  forgotPassword(email) {\r\n    return apiClient.post('/auth/forgot-password', { email });\r\n  }\r\n  \r\n  validateResetToken(token) {\r\n    return apiClient.get(`/auth/reset-password/${token}`);\r\n  }\r\n  \r\n  resetPassword(token, newPassword) {\r\n    return apiClient.post('/auth/reset-password', { token, newPassword });\r\n  }\r\n  \r\n  refreshToken() {\r\n    const refreshToken = localStorage.getItem('refreshToken');\r\n    \r\n    if (!refreshToken) {\r\n      return Promise.reject(new Error('No refresh token available'));\r\n    }\r\n    \r\n    return apiClient.post('/auth/refresh', { refreshToken })\r\n      .then(data => {\r\n        if (data.token) {\r\n          localStorage.setItem('authToken', data.token);\r\n        }\r\n        if (data.refreshToken) {\r\n          localStorage.setItem('refreshToken', data.refreshToken);\r\n        }\r\n        return data;\r\n      });\r\n  }\r\n  \r\n  // Check if the user is authenticated\r\n  isAuthenticated() {\r\n    return isAuthenticated();\r\n  }\r\n  \r\n  // Get current user ID\r\n  getCurrentUserId() {\r\n    return getCurrentUserId();\r\n  }\r\n}\r\n\r\n// User API for profile management\r\nclass UserAPI {\r\n  getProfile() {\r\n    return this.getCachedData('user_profile', () =>\r\n      apiClient.get('/user/profile')\r\n    );\r\n  }\r\n  \r\n  updateProfile(userData) {\r\n    this.invalidateCache('user_profile');\r\n    \r\n    return apiClient.put('/user/profile', userData);\r\n  }\r\n  \r\n  changePassword(passwordData) {\r\n    return apiClient.put('/user/password', passwordData);\r\n  }\r\n  \r\n  // Inherit caching methods from TaskAPI\r\n  getCachedData(key, fetchFn, options = {}) {\r\n    return taskApi.getCachedData(key, fetchFn, options);\r\n  }\r\n  \r\n  invalidateCache(key = null) {\r\n    return taskApi.invalidateCache(key);\r\n  }\r\n}\r\n\r\n// Create instances of the API classes\r\nconst taskApi = new TaskAPI();\r\nconst authApi = new AuthAPI();\r\nconst userApi = new UserAPI();\r\n\r\n// Create a consolidated API object that includes utility functions\r\nconst api = {\r\n  tasks: taskApi,\r\n  auth: authApi,\r\n  user: userApi,\r\n  // Add utility functions at the top level for convenience\r\n  isAuthenticated,\r\n  getCurrentUserId,\r\n  login,\r\n  logout\r\n};\r\n\r\n// Export the API instances and client\r\nexport {\r\n  apiClient,\r\n  taskApi,\r\n  authApi,\r\n  userApi,\r\n  isAuthenticated,\r\n  getCurrentUserId\r\n};\r\n\r\n// Default export for convenience\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}