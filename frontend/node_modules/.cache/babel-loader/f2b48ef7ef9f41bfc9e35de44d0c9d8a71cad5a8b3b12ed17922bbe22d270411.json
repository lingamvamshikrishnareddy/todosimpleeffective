{"ast":null,"code":"import axios from 'axios';\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\n\n// Create axios instance with defaults\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  timeout: 15000,\n  // Increased timeout for network congestion\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true // Send cookies with cross-origin requests\n});\n\n// Request interceptor for adding auth token\napiClient.interceptors.request.use(config => {\n  const token = localStorage.getItem('authToken');\n  if (token) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Enhanced response interceptor with better retry logic and rate limiting handling\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\napiClient.interceptors.response.use(response => response.data, async error => {\n  var _error$response2, _error$response3, _error$response3$data, _error$response4;\n  const originalRequest = error.config;\n\n  // Skip retry for certain endpoints to avoid duplication\n  const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\n  const shouldSkipRetry = skipRetryEndpoints.some(endpoint => originalRequest.url.includes(endpoint));\n  if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\n    var _error$response;\n    const status = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status;\n\n    // Retry on network errors or specific status codes\n    if (!error.response || RETRY_CODES.includes(status)) {\n      originalRequest._retry = (originalRequest._retry || 0) + 1;\n\n      // Calculate backoff delay with jitter to prevent thundering herd\n      const jitter = Math.random() * 0.3;\n      const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10);\n      const delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\n      console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms`);\n\n      // Special handling for rate limiting\n      if (status === 429) {\n        // Extract retry-after header if available or use our calculated delay\n        const retryAfter = error.response.headers['retry-after'];\n        const retryDelay = retryAfter ? parseInt(retryAfter, 10) * 1000 : delay;\n        console.log(`Rate limited. Retrying after ${retryDelay}ms`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n      } else {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n      return apiClient(originalRequest);\n    }\n  }\n\n  // Handle 401 Unauthorized - refresh token or redirect to login\n  if (error.response && error.response.status === 401) {\n    // Skip refresh token attempt if already in progress\n    if (originalRequest.url.includes('/auth/refresh') || originalRequest._hasRefreshed || originalRequest.url.includes('/auth/login')) {\n      // <-- Add this check\n      throw new Error('Token refresh failed');\n    }\n\n    // Flag to prevent infinite refresh loop\n    originalRequest._hasRefreshed = true;\n    try {\n      // Attempt to refresh token\n      const refreshToken = localStorage.getItem('refreshToken');\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n\n      // Call refresh token endpoint\n      const response = await axios.post(`${API_URL}/auth/refresh`, {\n        refreshToken\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        withCredentials: true // Send cookies\n      });\n\n      // Update tokens\n      const {\n        token\n      } = response.data;\n      localStorage.setItem('authToken', token);\n\n      // Update authorization header and retry\n      originalRequest.headers['Authorization'] = `Bearer ${token}`;\n      return apiClient(originalRequest);\n    } catch (refreshError) {\n      // If refresh fails, clean up tokens and redirect to login\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('refreshToken');\n\n      // Don't redirect for background API calls\n      if (window.location.pathname !== '/login') {\n        window.location.href = '/login';\n      }\n      throw refreshError; // Re-throw to properly handle the error\n    }\n  }\n\n  // Create a standardized error object\n  const errorResponse = {\n    status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status,\n    message: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || error.message,\n    data: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data\n  };\n  return Promise.reject(errorResponse);\n});\n\n// Authentication utilities\n// Check if user is authenticated\nconst isAuthenticated = () => {\n  const token = localStorage.getItem('authToken');\n  if (!token) return false;\n\n  // Optional: Check if token is expired\n  try {\n    // Get payload from JWT (token structure: header.payload.signature)\n    const payload = token.split('.')[1];\n    if (!payload) return false;\n    const decodedData = JSON.parse(atob(payload));\n    const expirationTime = decodedData.exp * 1000; // Convert to milliseconds\n\n    return expirationTime > Date.now();\n  } catch (error) {\n    console.error('Error checking token validity:', error);\n    return false;\n  }\n};\n\n// Get current user ID from token\nconst getCurrentUserId = () => {\n  const token = localStorage.getItem('authToken');\n  if (!token) return null;\n  try {\n    const payload = token.split('.')[1];\n    if (!payload) return null;\n    const decodedData = JSON.parse(atob(payload));\n    return decodedData.id;\n  } catch (error) {\n    console.error('Error extracting user ID from token:', error);\n    return null;\n  }\n};\n\n// Logout helper\nconst logout = () => {\n  localStorage.removeItem('authToken');\n  localStorage.removeItem('refreshToken');\n\n  // If you're using cookies for refresh tokens, you would also clear them here\n  // via the logout API endpoint\n  return apiClient.post('/auth/logout').catch(error => {\n    console.warn('Error during logout API call:', error);\n    // Continue with client-side logout even if server logout fails\n  });\n};\n\n// Login helper\nconst login = async credentials => {\n  const data = await apiClient.post('/auth/login', credentials);\n  if (data.token) {\n    localStorage.setItem('authToken', data.token);\n  }\n  if (data.refreshToken) {\n    localStorage.setItem('refreshToken', data.refreshToken);\n  }\n  return data;\n};\n\n// Authentication API with token management\nclass AuthAPI {\n  login(credentials) {\n    return login(credentials);\n  }\n  register(userData) {\n    return apiClient.post('/auth/register', userData);\n  }\n  logout() {\n    return logout();\n  }\n  forgotPassword(email) {\n    return apiClient.post('/auth/forgot-password', {\n      email\n    });\n  }\n  validateResetToken(token) {\n    return apiClient.get(`/auth/reset-password/${token}`);\n  }\n  resetPassword(token, newPassword) {\n    return apiClient.post('/auth/reset-password', {\n      token,\n      newPassword\n    });\n  }\n  refreshToken() {\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      return Promise.reject(new Error('No refresh token available'));\n    }\n    return apiClient.post('/auth/refresh', {\n      refreshToken\n    }).then(data => {\n      if (data.token) {\n        localStorage.setItem('authToken', data.token);\n      }\n      if (data.refreshToken) {\n        localStorage.setItem('refreshToken', data.refreshToken);\n      }\n      return data;\n    });\n  }\n\n  // Check if the user is authenticated\n  isAuthenticated() {\n    return isAuthenticated();\n  }\n\n  // Get current user ID\n  getCurrentUserId() {\n    return getCurrentUserId();\n  }\n}\n\n// User API for profile management\nclass UserAPI {\n  getProfile() {\n    return this.getCachedData('user_profile', () => apiClient.get('/user/profile'));\n  }\n  updateProfile(userData) {\n    this.invalidateCache('user_profile');\n    return apiClient.put('/user/profile', userData);\n  }\n  changePassword(passwordData) {\n    return apiClient.put('/user/password', passwordData);\n  }\n\n  // Inherit caching methods from TaskAPI\n  getCachedData(key, fetchFn, options = {}) {\n    return taskApi.getCachedData(key, fetchFn, options);\n  }\n  invalidateCache(key = null) {\n    return taskApi.invalidateCache(key);\n  }\n}\n\n// Create instances of the API classes\nconst taskApi = new TaskAPI();\nconst authApi = new AuthAPI();\nconst userApi = new UserAPI();\n\n// Create a consolidated API object that includes utility functions\nconst api = {\n  tasks: taskApi,\n  auth: authApi,\n  user: userApi,\n  // Add utility functions at the top level for convenience\n  isAuthenticated,\n  getCurrentUserId,\n  login,\n  logout\n};\n\n// Export the API instances and client\nexport { apiClient, taskApi, authApi, userApi, isAuthenticated, getCurrentUserId };\n\n// Default export for convenience\nexport default api;","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","apiClient","create","baseURL","timeout","headers","withCredentials","interceptors","request","use","config","token","localStorage","getItem","error","Promise","reject","MAX_RETRIES","RETRY_DELAY_MS","RETRY_CODES","response","data","_error$response2","_error$response3","_error$response3$data","_error$response4","originalRequest","skipRetryEndpoints","shouldSkipRetry","some","endpoint","url","includes","_retry","_error$response","status","jitter","Math","random","backoffFactor","min","pow","delay","console","log","round","retryAfter","retryDelay","parseInt","resolve","setTimeout","_hasRefreshed","Error","refreshToken","post","setItem","refreshError","removeItem","window","location","pathname","href","errorResponse","message","isAuthenticated","payload","split","decodedData","JSON","parse","atob","expirationTime","exp","Date","now","getCurrentUserId","id","logout","catch","warn","login","credentials","AuthAPI","register","userData","forgotPassword","email","validateResetToken","get","resetPassword","newPassword","then","UserAPI","getProfile","getCachedData","updateProfile","invalidateCache","put","changePassword","passwordData","key","fetchFn","options","taskApi","TaskAPI","authApi","userApi","api","tasks","auth","user"],"sources":["D:/Projects/todo list/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\r\n\r\n// Create axios instance with defaults\r\nconst apiClient = axios.create({\r\n  baseURL: API_URL,\r\n  timeout: 15000, // Increased timeout for network congestion\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n  withCredentials: true // Send cookies with cross-origin requests\r\n});\r\n\r\n// Request interceptor for adding auth token\r\napiClient.interceptors.request.use(\r\n  config => {\r\n    const token = localStorage.getItem('authToken');\r\n    if (token) {\r\n      config.headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  error => Promise.reject(error)\r\n);\r\n\r\n// Enhanced response interceptor with better retry logic and rate limiting handling\r\nconst MAX_RETRIES = 3;\r\nconst RETRY_DELAY_MS = 1000;\r\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\r\n\r\napiClient.interceptors.response.use(\r\n  response => response.data,\r\n  async error => {\r\n    const originalRequest = error.config;\r\n    \r\n    // Skip retry for certain endpoints to avoid duplication\r\n    const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\r\n    const shouldSkipRetry = skipRetryEndpoints.some(endpoint => originalRequest.url.includes(endpoint));\r\n    \r\n    if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\r\n      const status = error.response?.status;\r\n      \r\n      // Retry on network errors or specific status codes\r\n      if (!error.response || RETRY_CODES.includes(status)) {\r\n        originalRequest._retry = (originalRequest._retry || 0) + 1;\r\n        \r\n        // Calculate backoff delay with jitter to prevent thundering herd\r\n        const jitter = Math.random() * 0.3;\r\n        const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10);\r\n        const delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\r\n        \r\n        console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms`);\r\n        \r\n        // Special handling for rate limiting\r\n        if (status === 429) {\r\n          // Extract retry-after header if available or use our calculated delay\r\n          const retryAfter = error.response.headers['retry-after'];\r\n          const retryDelay = retryAfter ? parseInt(retryAfter, 10) * 1000 : delay;\r\n          \r\n          console.log(`Rate limited. Retrying after ${retryDelay}ms`);\r\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\r\n        } else {\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n        \r\n        return apiClient(originalRequest);\r\n      }\r\n    }\r\n    \r\n    // Handle 401 Unauthorized - refresh token or redirect to login\r\n    if (error.response && error.response.status === 401) {\r\n      // Skip refresh token attempt if already in progress\r\n      if (originalRequest.url.includes('/auth/refresh') || \r\n      originalRequest._hasRefreshed ||\r\n      originalRequest.url.includes('/auth/login')) {  // <-- Add this check\r\n    throw new Error('Token refresh failed');\r\n  }\r\n      \r\n      // Flag to prevent infinite refresh loop\r\n      originalRequest._hasRefreshed = true;\r\n      \r\n      try {\r\n        // Attempt to refresh token\r\n        const refreshToken = localStorage.getItem('refreshToken');\r\n        if (!refreshToken) {\r\n          throw new Error('No refresh token available');\r\n        }\r\n        \r\n        // Call refresh token endpoint\r\n        const response = await axios.post(`${API_URL}/auth/refresh`, {\r\n          refreshToken\r\n        }, {\r\n          headers: {\r\n            'Content-Type': 'application/json'\r\n          },\r\n          withCredentials: true // Send cookies\r\n        });\r\n        \r\n        // Update tokens\r\n        const { token } = response.data;\r\n        localStorage.setItem('authToken', token);\r\n        \r\n        // Update authorization header and retry\r\n        originalRequest.headers['Authorization'] = `Bearer ${token}`;\r\n        return apiClient(originalRequest);\r\n      } catch (refreshError) {\r\n        // If refresh fails, clean up tokens and redirect to login\r\n        localStorage.removeItem('authToken');\r\n        localStorage.removeItem('refreshToken');\r\n        \r\n        // Don't redirect for background API calls\r\n        if (window.location.pathname !== '/login') {\r\n          window.location.href = '/login';\r\n        }\r\n        \r\n        throw refreshError; // Re-throw to properly handle the error\r\n      }\r\n    }\r\n    \r\n    // Create a standardized error object\r\n    const errorResponse = {\r\n      status: error.response?.status,\r\n      message: error.response?.data?.message || error.message,\r\n      data: error.response?.data\r\n    };\r\n    \r\n    return Promise.reject(errorResponse);\r\n  }\r\n);\r\n\r\n// Authentication utilities\r\n// Check if user is authenticated\r\nconst isAuthenticated = () => {\r\n  const token = localStorage.getItem('authToken');\r\n  if (!token) return false;\r\n  \r\n  // Optional: Check if token is expired\r\n  try {\r\n    // Get payload from JWT (token structure: header.payload.signature)\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return false;\r\n    \r\n    const decodedData = JSON.parse(atob(payload));\r\n    const expirationTime = decodedData.exp * 1000; // Convert to milliseconds\r\n    \r\n    return expirationTime > Date.now();\r\n  } catch (error) {\r\n    console.error('Error checking token validity:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Get current user ID from token\r\nconst getCurrentUserId = () => {\r\n  const token = localStorage.getItem('authToken');\r\n  if (!token) return null;\r\n  \r\n  try {\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return null;\r\n    \r\n    const decodedData = JSON.parse(atob(payload));\r\n    return decodedData.id;\r\n  } catch (error) {\r\n    console.error('Error extracting user ID from token:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Logout helper\r\nconst logout = () => {\r\n  localStorage.removeItem('authToken');\r\n  localStorage.removeItem('refreshToken');\r\n  \r\n  // If you're using cookies for refresh tokens, you would also clear them here\r\n  // via the logout API endpoint\r\n  return apiClient.post('/auth/logout').catch(error => {\r\n    console.warn('Error during logout API call:', error);\r\n    // Continue with client-side logout even if server logout fails\r\n  });\r\n};\r\n\r\n// Login helper\r\nconst login = async (credentials) => {\r\n  const data = await apiClient.post('/auth/login', credentials);\r\n  if (data.token) {\r\n    localStorage.setItem('authToken', data.token);\r\n  }\r\n  if (data.refreshToken) {\r\n    localStorage.setItem('refreshToken', data.refreshToken);\r\n  }\r\n  return data;\r\n};\r\n\r\n// Authentication API with token management\r\nclass AuthAPI {\r\n  login(credentials) {\r\n    return login(credentials);\r\n  }\r\n  \r\n  register(userData) {\r\n    return apiClient.post('/auth/register', userData);\r\n  }\r\n  \r\n  logout() {\r\n    return logout();\r\n  }\r\n  \r\n  forgotPassword(email) {\r\n    return apiClient.post('/auth/forgot-password', { email });\r\n  }\r\n  \r\n  validateResetToken(token) {\r\n    return apiClient.get(`/auth/reset-password/${token}`);\r\n  }\r\n  \r\n  resetPassword(token, newPassword) {\r\n    return apiClient.post('/auth/reset-password', { token, newPassword });\r\n  }\r\n  \r\n  refreshToken() {\r\n    const refreshToken = localStorage.getItem('refreshToken');\r\n    \r\n    if (!refreshToken) {\r\n      return Promise.reject(new Error('No refresh token available'));\r\n    }\r\n    \r\n    return apiClient.post('/auth/refresh', { refreshToken })\r\n      .then(data => {\r\n        if (data.token) {\r\n          localStorage.setItem('authToken', data.token);\r\n        }\r\n        if (data.refreshToken) {\r\n          localStorage.setItem('refreshToken', data.refreshToken);\r\n        }\r\n        return data;\r\n      });\r\n  }\r\n  \r\n  // Check if the user is authenticated\r\n  isAuthenticated() {\r\n    return isAuthenticated();\r\n  }\r\n  \r\n  // Get current user ID\r\n  getCurrentUserId() {\r\n    return getCurrentUserId();\r\n  }\r\n}\r\n\r\n// User API for profile management\r\nclass UserAPI {\r\n  getProfile() {\r\n    return this.getCachedData('user_profile', () =>\r\n      apiClient.get('/user/profile')\r\n    );\r\n  }\r\n  \r\n  updateProfile(userData) {\r\n    this.invalidateCache('user_profile');\r\n    \r\n    return apiClient.put('/user/profile', userData);\r\n  }\r\n  \r\n  changePassword(passwordData) {\r\n    return apiClient.put('/user/password', passwordData);\r\n  }\r\n  \r\n  // Inherit caching methods from TaskAPI\r\n  getCachedData(key, fetchFn, options = {}) {\r\n    return taskApi.getCachedData(key, fetchFn, options);\r\n  }\r\n  \r\n  invalidateCache(key = null) {\r\n    return taskApi.invalidateCache(key);\r\n  }\r\n}\r\n\r\n// Create instances of the API classes\r\nconst taskApi = new TaskAPI();\r\nconst authApi = new AuthAPI();\r\nconst userApi = new UserAPI();\r\n\r\n// Create a consolidated API object that includes utility functions\r\nconst api = {\r\n  tasks: taskApi,\r\n  auth: authApi,\r\n  user: userApi,\r\n  // Add utility functions at the top level for convenience\r\n  isAuthenticated,\r\n  getCurrentUserId,\r\n  login,\r\n  logout\r\n};\r\n\r\n// Export the API instances and client\r\nexport {\r\n  apiClient,\r\n  taskApi,\r\n  authApi,\r\n  userApi,\r\n  isAuthenticated,\r\n  getCurrentUserId\r\n};\r\n\r\n// Default export for convenience\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}