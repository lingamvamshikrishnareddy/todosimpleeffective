{"ast":null,"code":"import axios from 'axios';\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\n\n// Enhanced configuration with environment-specific settings\nconst API_CONFIG = {\n  baseURL: API_URL,\n  timeout: 15000,\n  // 15 seconds\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true,\n  maxRetries: 3,\n  retryDelay: 1000,\n  // Milliseconds\n  rateLimitPerSecond: 10,\n  maxConcurrentRequests: 6,\n  cache: {\n    defaultExpiry: 30 * 1000,\n    // 30 seconds\n    longExpiry: 5 * 60 * 1000,\n    // 5 minutes\n    shortExpiry: 10 * 1000 // 10 seconds\n  }\n};\n\n// Enhanced error types for better error handling\nclass APIError extends Error {\n  constructor(message, status, code, originalError) {\n    super(message);\n    this.name = 'APIError';\n    this.status = status;\n    this.code = code;\n    this.originalError = originalError;\n    this.timestamp = new Date().toISOString();\n  }\n}\nclass NetworkError extends APIError {\n  constructor(message, originalError) {\n    super(message, null, 'NETWORK_ERROR', originalError);\n    this.name = 'NetworkError';\n  }\n}\nclass AuthenticationError extends APIError {\n  constructor(message, status = 401) {\n    super(message, status, 'AUTH_ERROR');\n    this.name = 'AuthenticationError';\n  }\n}\nclass RateLimitError extends APIError {\n  constructor(message, retryAfter) {\n    super(message, 429, 'RATE_LIMIT_ERROR');\n    this.name = 'RateLimitError';\n    this.retryAfter = retryAfter; // Milliseconds\n  }\n}\n\n// Enhanced token management with better security practices\nclass TokenManager {\n  constructor() {\n    this.isRefreshing = false;\n    this.failedQueue = [];\n    this.localStorageAvailable = typeof localStorage !== 'undefined';\n  }\n  _getItem(key) {\n    if (!this.localStorageAvailable) return null;\n    try {\n      return localStorage.getItem(key);\n    } catch (error) {\n      console.warn(`Failed to access localStorage for ${key}:`, error);\n      return null;\n    }\n  }\n  _setItem(key, value) {\n    if (!this.localStorageAvailable) {\n      console.warn('localStorage not available, cannot set item.');\n      return;\n    }\n    try {\n      localStorage.setItem(key, value);\n    } catch (error) {\n      console.error(`Failed to store ${key} in localStorage:`, error);\n      throw new Error('Token storage failed');\n    }\n  }\n  _removeItem(key) {\n    if (!this.localStorageAvailable) return;\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.warn(`Failed to remove ${key} from localStorage:`, error);\n    }\n  }\n  getAuthToken() {\n    return this._getItem('authToken');\n  }\n  getRefreshToken() {\n    return this._getItem('refreshToken');\n  }\n  setTokens(authToken, refreshToken) {\n    if (authToken) this._setItem('authToken', authToken);\n    // Allow explicitly setting refreshToken to null to clear it, or providing a new one\n    if (refreshToken !== undefined) {\n      if (refreshToken === null) {\n        this._removeItem('refreshToken');\n      } else {\n        this._setItem('refreshToken', refreshToken);\n      }\n    }\n  }\n  clearTokens() {\n    this._removeItem('authToken');\n    this._removeItem('refreshToken');\n  }\n  isTokenValid(token) {\n    if (!token) return false;\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false; // Not a JWT\n\n      const payload = JSON.parse(atob(parts[1]));\n      if (!payload.exp) return true; // No expiration claim, assume valid (or handle as invalid)\n\n      const expirationTime = payload.exp * 1000; // Convert to milliseconds\n      const bufferTime = 5 * 60 * 1000; // 5 minutes buffer to account for clock skew and request time\n\n      return expirationTime > Date.now() + bufferTime;\n    } catch (error) {\n      console.error('Error validating token:', error);\n      return false; // Invalid token if parsing or structure is wrong\n    }\n  }\n  getUserIdFromToken(token = null) {\n    const authToken = token || this.getAuthToken();\n    if (!authToken) return null;\n    try {\n      const parts = authToken.split('.');\n      if (parts.length !== 3) return null;\n      const payload = JSON.parse(atob(parts[1]));\n      return payload.id || payload.sub || payload.userId || null;\n    } catch (error) {\n      console.error('Error extracting user ID from token:', error);\n      return null;\n    }\n  }\n  isAuthenticated() {\n    const token = this.getAuthToken();\n    return token && this.isTokenValid(token);\n  }\n  async refreshTokens() {\n    if (this.isRefreshing) {\n      return new Promise((resolve, reject) => {\n        this.failedQueue.push({\n          resolve,\n          reject\n        });\n      });\n    }\n    this.isRefreshing = true;\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      this.isRefreshing = false;\n      this.failedQueue.forEach(({\n        reject\n      }) => reject(new AuthenticationError('No refresh token available')));\n      this.failedQueue = [];\n      throw new AuthenticationError('No refresh token available');\n    }\n    try {\n      // Use a raw axios instance for refresh token to avoid circular interceptor issues\n      const response = await axios.post(`${API_CONFIG.baseURL}/auth/refresh`, {\n        refreshToken\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        withCredentials: API_CONFIG.withCredentials,\n        timeout: 10000 // Specific timeout for refresh\n      });\n      const {\n        token,\n        refreshToken: newRefreshToken\n      } = response.data;\n      this.setTokens(token, newRefreshToken);\n      this.failedQueue.forEach(({\n        resolve\n      }) => resolve(token));\n      return token;\n    } catch (error) {\n      this.failedQueue.forEach(({\n        reject\n      }) => reject(error));\n      this.clearTokens(); // Critical: clear tokens on refresh failure\n      // Determine if the error is from Axios and has a response\n      if (axios.isAxiosError(error) && error.response) {\n        var _error$response$data;\n        throw new AuthenticationError(`Token refresh failed: ${((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message}`, error.response.status);\n      }\n      throw new AuthenticationError(`Token refresh failed: ${error.message}`);\n    } finally {\n      this.isRefreshing = false;\n      this.failedQueue = [];\n    }\n  }\n}\nconst tokenManager = new TokenManager();\n\n// Create axios instance with enhanced configuration\nconst apiClient = axios.create(API_CONFIG);\n\n// Enhanced request interceptor\napiClient.interceptors.request.use(config => {\n  const token = tokenManager.getAuthToken();\n  // Attach token if it's valid. If not, let the request proceed without it;\n  // the backend will return a 401 if it's required and missing/invalid.\n  if (token && tokenManager.isTokenValid(token)) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n\n  // Add request ID and start time for debugging and performance monitoring\n  config.metadata = {\n    requestId: Math.random().toString(36).substring(2, 11),\n    startTime: Date.now()\n  };\n  return config;\n}, error => {\n  console.error('Request interceptor error:', error);\n  // This error occurs before the request is sent\n  return Promise.reject(new NetworkError('Request configuration failed', error));\n});\n\n// Enhanced response interceptor with comprehensive error handling\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504]; // Status codes that might warrant a retry\nconst SKIP_RETRY_ENDPOINTS = ['/auth/logout', '/tasks/bulk-delete', '/tasks/bulk-update']; // Endpoints not safe for retry\n\napiClient.interceptors.response.use(response => {\n  // Log successful requests in development\n  if (process.env.NODE_ENV === 'development') {\n    var _response$config$meta, _response$config$meth;\n    const duration = Date.now() - (((_response$config$meta = response.config.metadata) === null || _response$config$meta === void 0 ? void 0 : _response$config$meta.startTime) || Date.now());\n    console.log(`✅ ${(_response$config$meth = response.config.method) === null || _response$config$meth === void 0 ? void 0 : _response$config$meth.toUpperCase()} ${response.config.url} (${response.status}) (${duration}ms)`);\n  }\n  return response.data; // Key change: return data directly for convenience\n}, async error => {\n  var _originalRequest$meta, _error$response, _error$response2;\n  const originalRequest = error.config;\n  const requestId = originalRequest === null || originalRequest === void 0 ? void 0 : (_originalRequest$meta = originalRequest.metadata) === null || _originalRequest$meta === void 0 ? void 0 : _originalRequest$meta.requestId;\n  console.error(`❌ API Error [${requestId}]:`, {\n    url: originalRequest === null || originalRequest === void 0 ? void 0 : originalRequest.url,\n    method: originalRequest === null || originalRequest === void 0 ? void 0 : originalRequest.method,\n    status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n    message: error.message,\n    responseData: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data\n    // originalError: error // Uncomment if deep original error inspection is needed\n  });\n\n  // Handle network errors (request made but no response received, or setup error)\n  if (!error.response && error.isAxiosError) {\n    // Check if it's an Axios error without a response\n    throw new NetworkError(`Network request failed for ${originalRequest === null || originalRequest === void 0 ? void 0 : originalRequest.url}: ${error.message}`, error);\n  }\n  if (!error.response) {\n    // Non-Axios error or other issue\n    throw new APIError(error.message || 'An unknown network error occurred', null, 'UNKNOWN_NETWORK_ERROR', error);\n  }\n  const {\n    status,\n    data,\n    headers\n  } = error.response;\n\n  // Handle authentication errors (401 Unauthorized)\n  if (status === 401 && !originalRequest._authRetried) {\n    var _originalRequest$url, _originalRequest$url2;\n    // Avoid refresh loops for auth endpoints\n    if ((_originalRequest$url = originalRequest.url) !== null && _originalRequest$url !== void 0 && _originalRequest$url.includes('/auth/refresh') || (_originalRequest$url2 = originalRequest.url) !== null && _originalRequest$url2 !== void 0 && _originalRequest$url2.includes('/auth/login')) {\n      tokenManager.clearTokens(); // Ensure tokens are cleared\n      throw new AuthenticationError((data === null || data === void 0 ? void 0 : data.message) || 'Authentication failed', status);\n    }\n    originalRequest._authRetried = true; // Mark to prevent infinite refresh loops\n\n    try {\n      const newToken = await tokenManager.refreshTokens();\n      originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\n      return apiClient(originalRequest); // Retry the original request with the new token\n    } catch (refreshError) {\n      // If refresh fails, a robust AuthenticationError is already thrown by refreshTokens()\n      // The application should catch this and decide on redirection.\n      // console.warn('Token refresh failed, user needs to re-authenticate.', refreshError);\n      // if (typeof window !== 'undefined' && window.location.pathname !== '/login') {\n      //   // Consider moving this side-effect to the UI layer\n      //   // window.location.href = '/login';\n      // }\n      throw refreshError; // Re-throw the error from tokenManager.refreshTokens()\n    }\n  }\n\n  // Handle rate limiting (429 Too Many Requests)\n  if (status === 429) {\n    const retryAfterHeader = headers === null || headers === void 0 ? void 0 : headers['retry-after'];\n    // retry-after can be in seconds or an HTTP-date. Assuming seconds for simplicity here.\n    const delay = retryAfterHeader ? parseInt(retryAfterHeader, 10) * 1000 : API_CONFIG.retryDelay;\n    throw new RateLimitError((data === null || data === void 0 ? void 0 : data.message) || 'Rate limit exceeded', delay);\n  }\n\n  // Generic retry logic for specific server error codes\n  const shouldSkipRetry = SKIP_RETRY_ENDPOINTS.some(endpoint => {\n    var _originalRequest$url3;\n    return (_originalRequest$url3 = originalRequest.url) === null || _originalRequest$url3 === void 0 ? void 0 : _originalRequest$url3.includes(endpoint);\n  });\n  if (!shouldSkipRetry && RETRY_CODES.includes(status)) {\n    const retryCount = originalRequest._retryCount || 0;\n    if (retryCount < API_CONFIG.maxRetries) {\n      originalRequest._retryCount = retryCount + 1;\n\n      // Exponential backoff with jitter\n      const backoffDelay = Math.min(API_CONFIG.retryDelay * Math.pow(2, retryCount) * (1 + Math.random() * 0.3), 10000 // Max backoff delay\n      );\n      console.log(`🔄 Retrying request to ${originalRequest.url} (${retryCount + 1}/${API_CONFIG.maxRetries}) after ${Math.round(backoffDelay)}ms`);\n      await new Promise(resolve => setTimeout(resolve, backoffDelay));\n      return apiClient(originalRequest);\n    }\n  }\n\n  // For all other errors, create a standardized APIError\n  const errorMessage = (data === null || data === void 0 ? void 0 : data.message) || error.message || 'An unknown API error occurred';\n  const errorCode = (data === null || data === void 0 ? void 0 : data.code) || `HTTP_${status}`;\n  throw new APIError(errorMessage, status, errorCode, error);\n});\n\n// Enhanced base API class with caching, queuing, rate limiting, and concurrency control\nclass BaseAPI {\n  constructor(client = apiClient) {\n    this.client = client;\n    this.cache = new Map();\n    this.pendingRequests = new Map(); // Deduplicates identical concurrent requests\n    this.requestQueue = []; // For managing sequential execution order if needed\n    this.processing = false; // Flag for queue processing state\n    this.activeRequests = 0; // Count of currently active dispatched requests\n    this.requestTimestamps = []; // For rate limiting\n\n    this.processQueue = this.processQueue.bind(this);\n    this.enqueueRequest = this.enqueueRequest.bind(this);\n  }\n  shouldRateLimit() {\n    const now = Date.now();\n    // Filter timestamps older than 1 second\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\n    return this.requestTimestamps.length >= API_CONFIG.rateLimitPerSecond;\n  }\n  trackRequest() {\n    this.requestTimestamps.push(Date.now());\n  }\n  async getCachedData(key, fetchFn, options = {}) {\n    const expiryTime = options.longCache ? API_CONFIG.cache.longExpiry : options.shortCache ? API_CONFIG.cache.shortExpiry : API_CONFIG.cache.defaultExpiry;\n    const cachedItem = this.cache.get(key);\n    if (cachedItem && !cachedItem.isError && Date.now() - cachedItem.timestamp < expiryTime) {\n      return Promise.resolve(cachedItem.data);\n    }\n\n    // Short-term caching for errors to prevent hammering failing endpoints\n    if (cachedItem !== null && cachedItem !== void 0 && cachedItem.isError && Date.now() - cachedItem.timestamp < 5000) {\n      // Cache errors for 5s\n      return Promise.reject(cachedItem.error);\n    }\n\n    // Deduplicate concurrent requests for the same key\n    if (this.pendingRequests.has(key)) {\n      return this.pendingRequests.get(key);\n    }\n    const requestPromise = this.enqueueRequest(fetchFn) // Use queue for all actual fetches\n    .then(data => {\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now(),\n        isError: false\n      });\n      this.pendingRequests.delete(key);\n      return data;\n    }).catch(error => {\n      this.cache.set(key, {\n        error,\n        timestamp: Date.now(),\n        isError: true\n      });\n      this.pendingRequests.delete(key);\n      throw error; // Propagate the error\n    });\n    this.pendingRequests.set(key, requestPromise);\n    return requestPromise;\n  }\n  invalidateCache(keyOrPredicate = null) {\n    if (keyOrPredicate === null) {\n      this.cache.clear();\n      this.pendingRequests.clear(); // Also clear pending requests if all cache is gone\n      if (process.env.NODE_ENV === 'development') console.log('🗑️ Cache cleared entirely');\n    } else if (typeof keyOrPredicate === 'string') {\n      this.cache.delete(keyOrPredicate);\n      this.pendingRequests.delete(keyOrPredicate); // Remove from pending if present\n      if (process.env.NODE_ENV === 'development') console.log(`🗑️ Cache invalidated for key: ${keyOrPredicate}`);\n    } else if (typeof keyOrPredicate === 'function') {\n      let invalidatedCount = 0;\n      for (const cacheKey of this.cache.keys()) {\n        if (keyOrPredicate(cacheKey)) {\n          this.cache.delete(cacheKey);\n          this.pendingRequests.delete(cacheKey);\n          invalidatedCount++;\n        }\n      }\n      if (process.env.NODE_ENV === 'development') console.log(`🗑️ Cache invalidated for ${invalidatedCount} keys matching predicate`);\n    }\n  }\n  enqueueRequest(fn, priority = 'normal') {\n    return new Promise((resolve, reject) => {\n      const request = {\n        fn,\n        resolve,\n        reject,\n        priority,\n        timestamp: Date.now(),\n        id: Math.random().toString(36).substring(2, 11) // Unique ID for queued request\n      };\n\n      // Simple priority implementation (high goes to front, low to back)\n      if (priority === 'high') {\n        this.requestQueue.unshift(request);\n      } else if (priority === 'low') {\n        this.requestQueue.push(request);\n      } else {\n        // normal\n        // Insert normal priority before low priority, otherwise append\n        const lowPriorityIndex = this.requestQueue.findIndex(r => r.priority === 'low');\n        if (lowPriorityIndex !== -1) {\n          this.requestQueue.splice(lowPriorityIndex, 0, request);\n        } else {\n          this.requestQueue.push(request);\n        }\n      }\n      this.processQueue();\n    });\n  }\n  async processQueue() {\n    if (this.processing) return; // Already processing the decision to launch workers\n    this.processing = true;\n    const processNextRequest = async () => {\n      if (this.requestQueue.length === 0) {\n        // No items left for this worker thread\n        return;\n      }\n      if (this.shouldRateLimit()) {\n        // If rate-limited, this worker thread defers and tries again\n        setTimeout(processNextRequest, 100 + Math.random() * 50);\n        return;\n      }\n      const requestToProcess = this.requestQueue.shift(); // Get the highest priority request\n      if (!requestToProcess) {\n        // Should not happen if queue.length > 0 check passed, but good guard\n        return;\n      }\n      this.activeRequests++;\n      this.trackRequest(); // Mark timestamp for rate limiting\n\n      try {\n        const result = await requestToProcess.fn();\n        requestToProcess.resolve(result);\n      } catch (error) {\n        requestToProcess.reject(error);\n      } finally {\n        this.activeRequests--;\n        // This worker finished, try to pick up another request if queue has items\n        if (this.requestQueue.length > 0) {\n          processNextRequest(); // Continue processing with this worker thread\n        }\n        // If queue is empty, this worker thread finishes.\n        // The outer processQueue logic will re-evaluate if all workers stop.\n      }\n    };\n\n    // Manager: Launch worker threads up to the concurrent limit\n    const workersToLaunch = [];\n    while (this.activeRequests < API_CONFIG.maxConcurrentRequests && this.requestQueue.length > 0 && !this.shouldRateLimit()) {\n      // Each call to processNextRequest effectively starts a new \"worker thread\"\n      // that will self-sustain as long as there are requests.\n      // We don't increment activeRequests here, processNextRequest does it.\n      workersToLaunch.push(processNextRequest());\n    }\n    if (workersToLaunch.length > 0) {\n      // Wait for the first task of each newly launched worker to settle.\n      // Workers will continue processing subsequent tasks on their own.\n      await Promise.allSettled(workersToLaunch);\n    }\n\n    // After the initial batch of workers might have completed their first task or deferred:\n    // Check if the queue still needs attention (e.g., if all workers became idle or hit rate limits).\n    this.processing = false; // Allow processQueue to be called again by enqueueRequest or setTimeout\n\n    if (this.requestQueue.length > 0 && this.activeRequests < API_CONFIG.maxConcurrentRequests) {\n      // If there are still requests and capacity, try to kick off more processing.\n      // This could be due to workers finishing or rate limit passing.\n      this.processQueue();\n    } else if (this.requestQueue.length > 0 && (this.activeRequests >= API_CONFIG.maxConcurrentRequests || this.shouldRateLimit())) {\n      // Queue has items, but we are at capacity or rate-limited. Schedule a check.\n      setTimeout(this.processQueue, 100 + Math.random() * 50);\n    }\n    // If queue is empty, processing naturally stops.\n  }\n  buildQueryString(params) {\n    const queryParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && String(value).trim() !== '') {\n        // Check for non-empty strings too\n        if (Array.isArray(value)) {\n          value.forEach(v => {\n            if (v !== undefined && v !== null && String(v).trim() !== '') {\n              queryParams.append(key, v);\n            }\n          });\n        } else {\n          queryParams.append(key, value);\n        }\n      }\n    });\n    return queryParams.toString();\n  }\n}\nclass TaskAPI extends BaseAPI {\n  constructor(client) {\n    // client will default to apiClient if new TaskAPI() is called\n    super(client);\n  }\n  async getTasks(params = {}) {\n    try {\n      const queryString = this.buildQueryString(params);\n      const cacheKey = `tasks_list_${queryString || 'all'}`;\n      return await this.getCachedData(cacheKey, () => this.client.get(`/tasks?${queryString}`), {\n        shortCache: true\n      });\n    } catch (error) {\n      console.error(`TaskAPI Error in getTasks: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async getTaskById(taskId) {\n    if (!taskId) {\n      throw new APIError('Task ID is required for getTaskById', 400, 'INVALID_TASK_ID');\n    }\n    const cacheKey = `task_item_${taskId}`;\n    try {\n      return await this.getCachedData(cacheKey, () => this.client.get(`/tasks/${taskId}`));\n    } catch (error) {\n      console.error(`TaskAPI Error in getTaskById (${taskId}): ${error.message}`, error);\n      throw error;\n    }\n  }\n  async createTask(taskData) {\n    if (!taskData || typeof taskData !== 'object' || !taskData.title) {\n      throw new APIError('Valid task data with a title is required for createTask', 400, 'INVALID_TASK_DATA');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.post('/tasks', taskData), 'high');\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`TaskAPI Error in createTask: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async updateTask(taskId, taskData) {\n    if (!taskId) {\n      throw new APIError('Task ID is required for updateTask', 400, 'INVALID_TASK_ID');\n    }\n    if (!taskData || typeof taskData !== 'object') {\n      throw new APIError('Valid task update data is required', 400, 'INVALID_TASK_UPDATE_DATA');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.put(`/tasks/${taskId}`, taskData));\n      this.invalidateCache(`task_item_${taskId}`);\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`TaskAPI Error in updateTask (${taskId}): ${error.message}`, error);\n      throw error;\n    }\n  }\n  async deleteTask(taskId) {\n    if (!taskId) {\n      throw new APIError('Task ID is required for deleteTask', 400, 'INVALID_TASK_ID');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.delete(`/tasks/${taskId}`));\n      this.invalidateCache(`task_item_${taskId}`);\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`TaskAPI Error in deleteTask (${taskId}): ${error.message}`, error);\n      throw error;\n    }\n  }\n  async toggleTaskStatus(taskId) {\n    if (!taskId) {\n      throw new APIError('Task ID is required for toggleTaskStatus', 400, 'INVALID_TASK_ID');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.patch(`/tasks/${taskId}/toggle`));\n      this.invalidateCache(`task_item_${taskId}`);\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`TaskAPI Error in toggleTaskStatus (${taskId}): ${error.message}`, error);\n      throw error;\n    }\n  }\n  async searchTasks(searchTerm, filters = {}) {\n    if (!searchTerm || typeof searchTerm !== 'string') {\n      throw new APIError('Search term is required for searchTasks', 400, 'INVALID_SEARCH_TERM');\n    }\n    const params = {\n      search: searchTerm,\n      ...filters\n    };\n    const queryString = this.buildQueryString(params);\n    const cacheKey = `tasks_search_${queryString}`;\n    try {\n      return await this.getCachedData(cacheKey, () => this.client.get(`/tasks/search?${queryString}`), {\n        shortCache: true\n      });\n    } catch (error) {\n      console.error(`TaskAPI Error in searchTasks: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async getTaskStats() {\n    const cacheKey = 'task_stats';\n    try {\n      return await this.getCachedData(cacheKey, () => this.client.get('/tasks/stats'), {\n        longCache: true\n      });\n    } catch (error) {\n      console.error(`TaskAPI Error in getTaskStats: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async bulkUpdateTasks(taskIds, updateData) {\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\n      throw new APIError('Task IDs array is required for bulkUpdateTasks', 400, 'INVALID_TASK_IDS');\n    }\n    if (!updateData || typeof updateData !== 'object') {\n      throw new APIError('Update data is required for bulkUpdateTasks', 400, 'INVALID_UPDATE_DATA');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.put('/tasks/bulk-update', {\n        taskIds,\n        updateData\n      }), 'high');\n      taskIds.forEach(id => this.invalidateCache(`task_item_${id}`));\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`TaskAPI Error in bulkUpdateTasks: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async bulkDeleteTasks(taskIds) {\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\n      throw new APIError('Task IDs array is required for bulkDeleteTasks', 400, 'INVALID_TASK_IDS');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.delete('/tasks/bulk-delete', {\n        data: {\n          taskIds\n        }\n      }),\n      // Pass data for DELETE\n      'high');\n      taskIds.forEach(id => this.invalidateCache(`task_item_${id}`));\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`TaskAPI Error in bulkDeleteTasks: ${error.message}`, error);\n      throw error;\n    }\n  }\n}\n\n// AuthAPI does not extend BaseAPI as its methods have specific behaviors (no general caching/queueing)\nclass AuthAPI {\n  constructor(client = apiClient) {\n    this.client = client;\n    this.tokenManager = tokenManager; // Use the global tokenManager instance\n  }\n  async login(credentials) {\n    if (!(credentials !== null && credentials !== void 0 && credentials.email) || !(credentials !== null && credentials !== void 0 && credentials.password)) {\n      throw new APIError('Email and password are required for login', 400, 'INVALID_CREDENTIALS');\n    }\n    try {\n      // apiClient already returns data property due to interceptor\n      const responseData = await this.client.post('/auth/login', credentials);\n      if (responseData.token) {\n        // Assuming 'token' and 'refreshToken' are in responseData\n        this.tokenManager.setTokens(responseData.token, responseData.refreshToken);\n      }\n      return responseData;\n    } catch (error) {\n      console.error(`AuthAPI Error in login: ${error.message}`, error);\n      throw error; // Error is already processed by interceptor\n    }\n  }\n  async register(userData) {\n    if (!(userData !== null && userData !== void 0 && userData.email) || !(userData !== null && userData !== void 0 && userData.password)) {\n      throw new APIError('Email and password are required for registration', 400, 'INVALID_USER_DATA');\n    }\n    try {\n      return await this.client.post('/auth/register', userData);\n    } catch (error) {\n      console.error(`AuthAPI Error in register: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async logout() {\n    try {\n      await this.client.post('/auth/logout');\n    } catch (error) {\n      // Log and ignore server-side logout errors, proceed with client-side cleanup\n      console.warn(`AuthAPI warning during logout: ${error.message}`, error);\n    } finally {\n      this.tokenManager.clearTokens(); // Always clear tokens client-side\n    }\n  }\n  async forgotPassword(email) {\n    if (!email) {\n      throw new APIError('Email is required for forgotPassword', 400, 'INVALID_EMAIL');\n    }\n    try {\n      return await this.client.post('/auth/forgot-password', {\n        email\n      });\n    } catch (error) {\n      console.error(`AuthAPI Error in forgotPassword: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async validateResetToken(token) {\n    if (!token) {\n      throw new APIError('Reset token is required for validateResetToken', 400, 'INVALID_TOKEN');\n    }\n    try {\n      return await this.client.get(`/auth/reset-password/${token}`);\n    } catch (error) {\n      console.error(`AuthAPI Error in validateResetToken: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async resetPassword(token, newPassword) {\n    if (!token || !newPassword) {\n      throw new APIError('Token and new password are required for resetPassword', 400, 'INVALID_RESET_DATA');\n    }\n    try {\n      return await this.client.post('/auth/reset-password', {\n        token,\n        newPassword\n      });\n    } catch (error) {\n      console.error(`AuthAPI Error in resetPassword: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async refreshToken() {\n    // This delegates directly to tokenManager's refreshTokens method\n    try {\n      return await this.tokenManager.refreshTokens();\n    } catch (error) {\n      console.error(`AuthAPI Error in refreshToken: ${error.message}`, error);\n      throw error; // Error from tokenManager is already an AuthenticationError\n    }\n  }\n  isAuthenticated() {\n    return this.tokenManager.isAuthenticated();\n  }\n  getCurrentUserId() {\n    return this.tokenManager.getUserIdFromToken();\n  }\n}\nclass UserAPI extends BaseAPI {\n  constructor(client) {\n    // client will default to apiClient if new UserAPI() is called\n    super(client);\n  }\n  async getProfile() {\n    try {\n      return await this.getCachedData('user_profile', () => this.client.get('/user/profile'), {\n        longCache: true\n      });\n    } catch (error) {\n      console.error(`UserAPI Error in getProfile: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async updateProfile(userData) {\n    if (!userData || typeof userData !== 'object') {\n      throw new APIError('User data object is required for updateProfile', 400, 'INVALID_USER_DATA');\n    }\n    try {\n      const result = await this.client.put('/user/profile', userData);\n      this.invalidateCache('user_profile'); // Invalidate after successful update\n      return result;\n    } catch (error) {\n      console.error(`UserAPI Error in updateProfile: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async changePassword(passwordData) {\n    if (!(passwordData !== null && passwordData !== void 0 && passwordData.currentPassword) || !(passwordData !== null && passwordData !== void 0 && passwordData.newPassword)) {\n      throw new APIError('Current and new passwords are required for changePassword', 400, 'INVALID_PASSWORD_DATA');\n    }\n    try {\n      return await this.client.put('/user/password', passwordData);\n    } catch (error) {\n      console.error(`UserAPI Error in changePassword: ${error.message}`, error);\n      throw error;\n    }\n  }\n  async uploadAvatar(file) {\n    if (!(file instanceof File)) {\n      throw new APIError('A valid File object is required for avatar upload', 400, 'INVALID_FILE');\n    }\n    const formData = new FormData();\n    formData.append('avatar', file);\n    try {\n      // For multipart/form-data, axios usually sets Content-Type automatically\n      // if you pass FormData directly as data.\n      const result = await this.client.post('/user/avatar', formData, {\n        headers: {\n          // 'Content-Type': 'multipart/form-data', // Axios should set this with boundary\n        }\n      });\n      this.invalidateCache('user_profile'); // Avatar change likely affects profile\n      return result;\n    } catch (error) {\n      console.error(`UserAPI Error in uploadAvatar: ${error.message}`, error);\n      throw error;\n    }\n  }\n}\n\n// Create API instances\nconst taskApi = new TaskAPI(); // Uses default apiClient\nconst authApi = new AuthAPI(); // Uses default apiClient and global tokenManager\nconst userApi = new UserAPI(); // Uses default apiClient\n\n// Consolidated API object for easier import and use\nconst api = {\n  tasks: taskApi,\n  auth: authApi,\n  user: userApi,\n  // Expose utility functions from tokenManager or for general use\n  isAuthenticated: () => tokenManager.isAuthenticated(),\n  getCurrentUserId: () => tokenManager.getUserIdFromToken(),\n  clearAllCache: () => {\n    // More descriptive name\n    taskApi.invalidateCache(); // Clear all task-related cache\n    userApi.invalidateCache(); // Clear all user-related cache\n    // Add other API cache invalidations if they exist\n    if (process.env.NODE_ENV === 'development') console.log('🗑️ All known API caches cleared.');\n  },\n  // Expose error classes for type checking by consumers if needed\n  errors: {\n    APIError,\n    NetworkError,\n    AuthenticationError,\n    RateLimitError\n  }\n};\n\n// Export individual components and the consolidated api object\nexport { apiClient,\n// The configured axios instance\ntaskApi, authApi, userApi, tokenManager,\n// For direct token management if necessary\nAPIError, NetworkError, AuthenticationError, RateLimitError, BaseAPI // Export BaseAPI if it's intended to be subclassed externally\n};\nexport default api;","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","API_CONFIG","baseURL","timeout","headers","withCredentials","maxRetries","retryDelay","rateLimitPerSecond","maxConcurrentRequests","cache","defaultExpiry","longExpiry","shortExpiry","APIError","Error","constructor","message","status","code","originalError","name","timestamp","Date","toISOString","NetworkError","AuthenticationError","RateLimitError","retryAfter","TokenManager","isRefreshing","failedQueue","localStorageAvailable","localStorage","_getItem","key","getItem","error","console","warn","_setItem","value","setItem","_removeItem","removeItem","getAuthToken","getRefreshToken","setTokens","authToken","refreshToken","undefined","clearTokens","isTokenValid","token","parts","split","length","payload","JSON","parse","atob","exp","expirationTime","bufferTime","now","getUserIdFromToken","id","sub","userId","isAuthenticated","refreshTokens","Promise","resolve","reject","push","forEach","response","post","newRefreshToken","data","isAxiosError","_error$response$data","tokenManager","apiClient","create","interceptors","request","use","config","metadata","requestId","Math","random","toString","substring","startTime","RETRY_CODES","SKIP_RETRY_ENDPOINTS","NODE_ENV","_response$config$meta","_response$config$meth","duration","log","method","toUpperCase","url","_originalRequest$meta","_error$response","_error$response2","originalRequest","responseData","_authRetried","_originalRequest$url","_originalRequest$url2","includes","newToken","refreshError","retryAfterHeader","delay","parseInt","shouldSkipRetry","some","endpoint","_originalRequest$url3","retryCount","_retryCount","backoffDelay","min","pow","round","setTimeout","errorMessage","errorCode","BaseAPI","client","Map","pendingRequests","requestQueue","processing","activeRequests","requestTimestamps","processQueue","bind","enqueueRequest","shouldRateLimit","filter","time","trackRequest","getCachedData","fetchFn","options","expiryTime","longCache","shortCache","cachedItem","get","isError","has","requestPromise","then","set","delete","catch","invalidateCache","keyOrPredicate","clear","invalidatedCount","cacheKey","keys","fn","priority","unshift","lowPriorityIndex","findIndex","r","splice","processNextRequest","requestToProcess","shift","result","workersToLaunch","allSettled","buildQueryString","params","queryParams","URLSearchParams","Object","entries","String","trim","Array","isArray","v","append","TaskAPI","getTasks","queryString","getTaskById","taskId","createTask","taskData","title","startsWith","updateTask","put","deleteTask","toggleTaskStatus","patch","searchTasks","searchTerm","filters","search","getTaskStats","bulkUpdateTasks","taskIds","updateData","bulkDeleteTasks","AuthAPI","login","credentials","email","password","register","userData","logout","forgotPassword","validateResetToken","resetPassword","newPassword","getCurrentUserId","UserAPI","getProfile","updateProfile","changePassword","passwordData","currentPassword","uploadAvatar","file","File","formData","FormData","taskApi","authApi","userApi","api","tasks","auth","user","clearAllCache","errors"],"sources":["D:/Projects/todo list/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\r\n\r\n// Enhanced configuration with environment-specific settings\r\nconst API_CONFIG = {\r\n  baseURL: API_URL,\r\n  timeout: 15000, // 15 seconds\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n  withCredentials: true,\r\n  maxRetries: 3,\r\n  retryDelay: 1000, // Milliseconds\r\n  rateLimitPerSecond: 10,\r\n  maxConcurrentRequests: 6,\r\n  cache: {\r\n    defaultExpiry: 30 * 1000,  // 30 seconds\r\n    longExpiry: 5 * 60 * 1000, // 5 minutes\r\n    shortExpiry: 10 * 1000,    // 10 seconds\r\n  }\r\n};\r\n\r\n// Enhanced error types for better error handling\r\nclass APIError extends Error {\r\n  constructor(message, status, code, originalError) {\r\n    super(message);\r\n    this.name = 'APIError';\r\n    this.status = status;\r\n    this.code = code;\r\n    this.originalError = originalError;\r\n    this.timestamp = new Date().toISOString();\r\n  }\r\n}\r\n\r\nclass NetworkError extends APIError {\r\n  constructor(message, originalError) {\r\n    super(message, null, 'NETWORK_ERROR', originalError);\r\n    this.name = 'NetworkError';\r\n  }\r\n}\r\n\r\nclass AuthenticationError extends APIError {\r\n  constructor(message, status = 401) {\r\n    super(message, status, 'AUTH_ERROR');\r\n    this.name = 'AuthenticationError';\r\n  }\r\n}\r\n\r\nclass RateLimitError extends APIError {\r\n  constructor(message, retryAfter) {\r\n    super(message, 429, 'RATE_LIMIT_ERROR');\r\n    this.name = 'RateLimitError';\r\n    this.retryAfter = retryAfter; // Milliseconds\r\n  }\r\n}\r\n\r\n// Enhanced token management with better security practices\r\nclass TokenManager {\r\n  constructor() {\r\n    this.isRefreshing = false;\r\n    this.failedQueue = [];\r\n    this.localStorageAvailable = typeof localStorage !== 'undefined';\r\n  }\r\n\r\n  _getItem(key) {\r\n    if (!this.localStorageAvailable) return null;\r\n    try {\r\n      return localStorage.getItem(key);\r\n    } catch (error) {\r\n      console.warn(`Failed to access localStorage for ${key}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  _setItem(key, value) {\r\n    if (!this.localStorageAvailable) {\r\n        console.warn('localStorage not available, cannot set item.');\r\n        return;\r\n    }\r\n    try {\r\n      localStorage.setItem(key, value);\r\n    } catch (error) {\r\n      console.error(`Failed to store ${key} in localStorage:`, error);\r\n      throw new Error('Token storage failed');\r\n    }\r\n  }\r\n\r\n  _removeItem(key) {\r\n    if (!this.localStorageAvailable) return;\r\n    try {\r\n      localStorage.removeItem(key);\r\n    } catch (error) {\r\n      console.warn(`Failed to remove ${key} from localStorage:`, error);\r\n    }\r\n  }\r\n\r\n  getAuthToken() {\r\n    return this._getItem('authToken');\r\n  }\r\n\r\n  getRefreshToken() {\r\n    return this._getItem('refreshToken');\r\n  }\r\n\r\n  setTokens(authToken, refreshToken) {\r\n    if (authToken) this._setItem('authToken', authToken);\r\n    // Allow explicitly setting refreshToken to null to clear it, or providing a new one\r\n    if (refreshToken !== undefined) {\r\n        if (refreshToken === null) {\r\n            this._removeItem('refreshToken');\r\n        } else {\r\n            this._setItem('refreshToken', refreshToken);\r\n        }\r\n    }\r\n  }\r\n\r\n  clearTokens() {\r\n    this._removeItem('authToken');\r\n    this._removeItem('refreshToken');\r\n  }\r\n\r\n  isTokenValid(token) {\r\n    if (!token) return false;\r\n    \r\n    try {\r\n      const parts = token.split('.');\r\n      if (parts.length !== 3) return false; // Not a JWT\r\n      \r\n      const payload = JSON.parse(atob(parts[1]));\r\n      if (!payload.exp) return true; // No expiration claim, assume valid (or handle as invalid)\r\n\r\n      const expirationTime = payload.exp * 1000; // Convert to milliseconds\r\n      const bufferTime = 5 * 60 * 1000; // 5 minutes buffer to account for clock skew and request time\r\n      \r\n      return expirationTime > (Date.now() + bufferTime);\r\n    } catch (error) {\r\n      console.error('Error validating token:', error);\r\n      return false; // Invalid token if parsing or structure is wrong\r\n    }\r\n  }\r\n\r\n  getUserIdFromToken(token = null) {\r\n    const authToken = token || this.getAuthToken();\r\n    if (!authToken) return null;\r\n    \r\n    try {\r\n      const parts = authToken.split('.');\r\n      if (parts.length !== 3) return null;\r\n      const payload = JSON.parse(atob(parts[1]));\r\n      return payload.id || payload.sub || payload.userId || null;\r\n    } catch (error) {\r\n      console.error('Error extracting user ID from token:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  isAuthenticated() {\r\n    const token = this.getAuthToken();\r\n    return token && this.isTokenValid(token);\r\n  }\r\n\r\n  async refreshTokens() {\r\n    if (this.isRefreshing) {\r\n      return new Promise((resolve, reject) => {\r\n        this.failedQueue.push({ resolve, reject });\r\n      });\r\n    }\r\n\r\n    this.isRefreshing = true;\r\n    const refreshToken = this.getRefreshToken();\r\n\r\n    if (!refreshToken) {\r\n      this.isRefreshing = false;\r\n      this.failedQueue.forEach(({ reject }) => reject(new AuthenticationError('No refresh token available')));\r\n      this.failedQueue = [];\r\n      throw new AuthenticationError('No refresh token available');\r\n    }\r\n\r\n    try {\r\n      // Use a raw axios instance for refresh token to avoid circular interceptor issues\r\n      const response = await axios.post(`${API_CONFIG.baseURL}/auth/refresh`, {\r\n        refreshToken\r\n      }, {\r\n        headers: { 'Content-Type': 'application/json' },\r\n        withCredentials: API_CONFIG.withCredentials,\r\n        timeout: 10000 // Specific timeout for refresh\r\n      });\r\n\r\n      const { token, refreshToken: newRefreshToken } = response.data;\r\n      this.setTokens(token, newRefreshToken);\r\n\r\n      this.failedQueue.forEach(({ resolve }) => resolve(token));\r\n      return token;\r\n    } catch (error) {\r\n      this.failedQueue.forEach(({ reject }) => reject(error));\r\n      this.clearTokens(); // Critical: clear tokens on refresh failure\r\n      // Determine if the error is from Axios and has a response\r\n      if (axios.isAxiosError(error) && error.response) {\r\n        throw new AuthenticationError(`Token refresh failed: ${error.response.data?.message || error.message}`, error.response.status);\r\n      }\r\n      throw new AuthenticationError(`Token refresh failed: ${error.message}`);\r\n    } finally {\r\n      this.isRefreshing = false;\r\n      this.failedQueue = [];\r\n    }\r\n  }\r\n}\r\n\r\nconst tokenManager = new TokenManager();\r\n\r\n// Create axios instance with enhanced configuration\r\nconst apiClient = axios.create(API_CONFIG);\r\n\r\n// Enhanced request interceptor\r\napiClient.interceptors.request.use(\r\n  (config) => {\r\n    const token = tokenManager.getAuthToken();\r\n    // Attach token if it's valid. If not, let the request proceed without it;\r\n    // the backend will return a 401 if it's required and missing/invalid.\r\n    if (token && tokenManager.isTokenValid(token)) {\r\n      config.headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    \r\n    // Add request ID and start time for debugging and performance monitoring\r\n    config.metadata = { \r\n      requestId: Math.random().toString(36).substring(2, 11),\r\n      startTime: Date.now()\r\n    };\r\n    \r\n    return config;\r\n  },\r\n  (error) => {\r\n    console.error('Request interceptor error:', error);\r\n    // This error occurs before the request is sent\r\n    return Promise.reject(new NetworkError('Request configuration failed', error));\r\n  }\r\n);\r\n\r\n// Enhanced response interceptor with comprehensive error handling\r\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504]; // Status codes that might warrant a retry\r\nconst SKIP_RETRY_ENDPOINTS = ['/auth/logout', '/tasks/bulk-delete', '/tasks/bulk-update']; // Endpoints not safe for retry\r\n\r\napiClient.interceptors.response.use(\r\n  (response) => {\r\n    // Log successful requests in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      const duration = Date.now() - (response.config.metadata?.startTime || Date.now());\r\n      console.log(`✅ ${response.config.method?.toUpperCase()} ${response.config.url} (${response.status}) (${duration}ms)`);\r\n    }\r\n    return response.data; // Key change: return data directly for convenience\r\n  },\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    const requestId = originalRequest?.metadata?.requestId;\r\n    \r\n    console.error(`❌ API Error [${requestId}]:`, {\r\n      url: originalRequest?.url,\r\n      method: originalRequest?.method,\r\n      status: error.response?.status,\r\n      message: error.message,\r\n      responseData: error.response?.data,\r\n      // originalError: error // Uncomment if deep original error inspection is needed\r\n    });\r\n\r\n    // Handle network errors (request made but no response received, or setup error)\r\n    if (!error.response && error.isAxiosError) { // Check if it's an Axios error without a response\r\n      throw new NetworkError(`Network request failed for ${originalRequest?.url}: ${error.message}`, error);\r\n    }\r\n    if (!error.response) { // Non-Axios error or other issue\r\n        throw new APIError(error.message || 'An unknown network error occurred', null, 'UNKNOWN_NETWORK_ERROR', error);\r\n    }\r\n\r\n\r\n    const { status, data, headers } = error.response;\r\n    \r\n    // Handle authentication errors (401 Unauthorized)\r\n    if (status === 401 && !originalRequest._authRetried) {\r\n      // Avoid refresh loops for auth endpoints\r\n      if (originalRequest.url?.includes('/auth/refresh') || \r\n          originalRequest.url?.includes('/auth/login')) {\r\n        tokenManager.clearTokens(); // Ensure tokens are cleared\r\n        throw new AuthenticationError(data?.message || 'Authentication failed', status);\r\n      }\r\n\r\n      originalRequest._authRetried = true; // Mark to prevent infinite refresh loops\r\n      \r\n      try {\r\n        const newToken = await tokenManager.refreshTokens();\r\n        originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\r\n        return apiClient(originalRequest); // Retry the original request with the new token\r\n      } catch (refreshError) {\r\n        // If refresh fails, a robust AuthenticationError is already thrown by refreshTokens()\r\n        // The application should catch this and decide on redirection.\r\n        // console.warn('Token refresh failed, user needs to re-authenticate.', refreshError);\r\n        // if (typeof window !== 'undefined' && window.location.pathname !== '/login') {\r\n        //   // Consider moving this side-effect to the UI layer\r\n        //   // window.location.href = '/login';\r\n        // }\r\n        throw refreshError; // Re-throw the error from tokenManager.refreshTokens()\r\n      }\r\n    }\r\n\r\n    // Handle rate limiting (429 Too Many Requests)\r\n    if (status === 429) {\r\n      const retryAfterHeader = headers?.['retry-after'];\r\n      // retry-after can be in seconds or an HTTP-date. Assuming seconds for simplicity here.\r\n      const delay = retryAfterHeader ? parseInt(retryAfterHeader, 10) * 1000 : API_CONFIG.retryDelay;\r\n      throw new RateLimitError(data?.message || 'Rate limit exceeded', delay);\r\n    }\r\n\r\n    // Generic retry logic for specific server error codes\r\n    const shouldSkipRetry = SKIP_RETRY_ENDPOINTS.some(endpoint => originalRequest.url?.includes(endpoint));\r\n    \r\n    if (!shouldSkipRetry && RETRY_CODES.includes(status)) {\r\n      const retryCount = originalRequest._retryCount || 0;\r\n      \r\n      if (retryCount < API_CONFIG.maxRetries) {\r\n        originalRequest._retryCount = retryCount + 1;\r\n        \r\n        // Exponential backoff with jitter\r\n        const backoffDelay = Math.min(\r\n          API_CONFIG.retryDelay * Math.pow(2, retryCount) * (1 + Math.random() * 0.3),\r\n          10000 // Max backoff delay\r\n        );\r\n        \r\n        console.log(`🔄 Retrying request to ${originalRequest.url} (${retryCount + 1}/${API_CONFIG.maxRetries}) after ${Math.round(backoffDelay)}ms`);\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, backoffDelay));\r\n        return apiClient(originalRequest);\r\n      }\r\n    }\r\n\r\n    // For all other errors, create a standardized APIError\r\n    const errorMessage = data?.message || error.message || 'An unknown API error occurred';\r\n    const errorCode = data?.code || `HTTP_${status}`;\r\n    throw new APIError(errorMessage, status, errorCode, error);\r\n  }\r\n);\r\n\r\n// Enhanced base API class with caching, queuing, rate limiting, and concurrency control\r\nclass BaseAPI {\r\n  constructor(client = apiClient) {\r\n    this.client = client;\r\n    this.cache = new Map();\r\n    this.pendingRequests = new Map(); // Deduplicates identical concurrent requests\r\n    this.requestQueue = []; // For managing sequential execution order if needed\r\n    this.processing = false; // Flag for queue processing state\r\n    this.activeRequests = 0; // Count of currently active dispatched requests\r\n    this.requestTimestamps = []; // For rate limiting\r\n    \r\n    this.processQueue = this.processQueue.bind(this);\r\n    this.enqueueRequest = this.enqueueRequest.bind(this);\r\n  }\r\n\r\n  shouldRateLimit() {\r\n    const now = Date.now();\r\n    // Filter timestamps older than 1 second\r\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\r\n    return this.requestTimestamps.length >= API_CONFIG.rateLimitPerSecond;\r\n  }\r\n\r\n  trackRequest() {\r\n    this.requestTimestamps.push(Date.now());\r\n  }\r\n\r\n  async getCachedData(key, fetchFn, options = {}) {\r\n    const expiryTime = options.longCache\r\n      ? API_CONFIG.cache.longExpiry\r\n      : (options.shortCache ? API_CONFIG.cache.shortExpiry : API_CONFIG.cache.defaultExpiry);\r\n\r\n    const cachedItem = this.cache.get(key);\r\n    if (cachedItem && !cachedItem.isError && (Date.now() - cachedItem.timestamp < expiryTime)) {\r\n      return Promise.resolve(cachedItem.data);\r\n    }\r\n\r\n    // Short-term caching for errors to prevent hammering failing endpoints\r\n    if (cachedItem?.isError && (Date.now() - cachedItem.timestamp < 5000)) { // Cache errors for 5s\r\n      return Promise.reject(cachedItem.error);\r\n    }\r\n\r\n    // Deduplicate concurrent requests for the same key\r\n    if (this.pendingRequests.has(key)) {\r\n      return this.pendingRequests.get(key);\r\n    }\r\n\r\n    const requestPromise = this.enqueueRequest(fetchFn) // Use queue for all actual fetches\r\n      .then(data => {\r\n        this.cache.set(key, { data, timestamp: Date.now(), isError: false });\r\n        this.pendingRequests.delete(key);\r\n        return data;\r\n      })\r\n      .catch(error => {\r\n        this.cache.set(key, { error, timestamp: Date.now(), isError: true });\r\n        this.pendingRequests.delete(key);\r\n        throw error; // Propagate the error\r\n      });\r\n\r\n    this.pendingRequests.set(key, requestPromise);\r\n    return requestPromise;\r\n  }\r\n\r\n  invalidateCache(keyOrPredicate = null) {\r\n    if (keyOrPredicate === null) {\r\n      this.cache.clear();\r\n      this.pendingRequests.clear(); // Also clear pending requests if all cache is gone\r\n      if (process.env.NODE_ENV === 'development') console.log('🗑️ Cache cleared entirely');\r\n    } else if (typeof keyOrPredicate === 'string') {\r\n      this.cache.delete(keyOrPredicate);\r\n      this.pendingRequests.delete(keyOrPredicate); // Remove from pending if present\r\n      if (process.env.NODE_ENV === 'development') console.log(`🗑️ Cache invalidated for key: ${keyOrPredicate}`);\r\n    } else if (typeof keyOrPredicate === 'function') {\r\n      let invalidatedCount = 0;\r\n      for (const cacheKey of this.cache.keys()) {\r\n        if (keyOrPredicate(cacheKey)) {\r\n          this.cache.delete(cacheKey);\r\n          this.pendingRequests.delete(cacheKey);\r\n          invalidatedCount++;\r\n        }\r\n      }\r\n      if (process.env.NODE_ENV === 'development') console.log(`🗑️ Cache invalidated for ${invalidatedCount} keys matching predicate`);\r\n    }\r\n  }\r\n\r\n  enqueueRequest(fn, priority = 'normal') {\r\n    return new Promise((resolve, reject) => {\r\n      const request = { \r\n        fn, \r\n        resolve, \r\n        reject, \r\n        priority, \r\n        timestamp: Date.now(),\r\n        id: Math.random().toString(36).substring(2, 11) // Unique ID for queued request\r\n      };\r\n\r\n      // Simple priority implementation (high goes to front, low to back)\r\n      if (priority === 'high') {\r\n        this.requestQueue.unshift(request);\r\n      } else if (priority === 'low') {\r\n        this.requestQueue.push(request);\r\n      } else { // normal\r\n        // Insert normal priority before low priority, otherwise append\r\n        const lowPriorityIndex = this.requestQueue.findIndex(r => r.priority === 'low');\r\n        if (lowPriorityIndex !== -1) {\r\n          this.requestQueue.splice(lowPriorityIndex, 0, request);\r\n        } else {\r\n          this.requestQueue.push(request);\r\n        }\r\n      }\r\n      this.processQueue();\r\n    });\r\n  }\r\n\r\n  async processQueue() {\r\n    if (this.processing) return; // Already processing the decision to launch workers\r\n    this.processing = true;\r\n\r\n    const processNextRequest = async () => {\r\n      if (this.requestQueue.length === 0) {\r\n        // No items left for this worker thread\r\n        return;\r\n      }\r\n\r\n      if (this.shouldRateLimit()) {\r\n        // If rate-limited, this worker thread defers and tries again\r\n        setTimeout(processNextRequest, 100 + Math.random() * 50);\r\n        return;\r\n      }\r\n\r\n      const requestToProcess = this.requestQueue.shift(); // Get the highest priority request\r\n      if (!requestToProcess) {\r\n         // Should not happen if queue.length > 0 check passed, but good guard\r\n        return;\r\n      }\r\n\r\n      this.activeRequests++;\r\n      this.trackRequest(); // Mark timestamp for rate limiting\r\n\r\n      try {\r\n        const result = await requestToProcess.fn();\r\n        requestToProcess.resolve(result);\r\n      } catch (error) {\r\n        requestToProcess.reject(error);\r\n      } finally {\r\n        this.activeRequests--;\r\n        // This worker finished, try to pick up another request if queue has items\r\n        if (this.requestQueue.length > 0) {\r\n          processNextRequest(); // Continue processing with this worker thread\r\n        }\r\n        // If queue is empty, this worker thread finishes.\r\n        // The outer processQueue logic will re-evaluate if all workers stop.\r\n      }\r\n    };\r\n\r\n    // Manager: Launch worker threads up to the concurrent limit\r\n    const workersToLaunch = [];\r\n    while (this.activeRequests < API_CONFIG.maxConcurrentRequests && \r\n           this.requestQueue.length > 0 &&\r\n           !this.shouldRateLimit()) {\r\n      // Each call to processNextRequest effectively starts a new \"worker thread\"\r\n      // that will self-sustain as long as there are requests.\r\n      // We don't increment activeRequests here, processNextRequest does it.\r\n      workersToLaunch.push(processNextRequest());\r\n    }\r\n\r\n    if (workersToLaunch.length > 0) {\r\n      // Wait for the first task of each newly launched worker to settle.\r\n      // Workers will continue processing subsequent tasks on their own.\r\n      await Promise.allSettled(workersToLaunch);\r\n    }\r\n\r\n    // After the initial batch of workers might have completed their first task or deferred:\r\n    // Check if the queue still needs attention (e.g., if all workers became idle or hit rate limits).\r\n    this.processing = false; // Allow processQueue to be called again by enqueueRequest or setTimeout\r\n    \r\n    if (this.requestQueue.length > 0 && this.activeRequests < API_CONFIG.maxConcurrentRequests) {\r\n      // If there are still requests and capacity, try to kick off more processing.\r\n      // This could be due to workers finishing or rate limit passing.\r\n      this.processQueue();\r\n    } else if (this.requestQueue.length > 0 && (this.activeRequests >= API_CONFIG.maxConcurrentRequests || this.shouldRateLimit())) {\r\n      // Queue has items, but we are at capacity or rate-limited. Schedule a check.\r\n      setTimeout(this.processQueue, 100 + Math.random() * 50);\r\n    }\r\n    // If queue is empty, processing naturally stops.\r\n  }\r\n\r\n  buildQueryString(params) {\r\n    const queryParams = new URLSearchParams();\r\n    Object.entries(params).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null && String(value).trim() !== '') { // Check for non-empty strings too\r\n        if (Array.isArray(value)) {\r\n          value.forEach(v => {\r\n            if (v !== undefined && v !== null && String(v).trim() !== '') {\r\n              queryParams.append(key, v);\r\n            }\r\n          });\r\n        } else {\r\n          queryParams.append(key, value);\r\n        }\r\n      }\r\n    });\r\n    return queryParams.toString();\r\n  }\r\n}\r\n\r\n\r\nclass TaskAPI extends BaseAPI {\r\n  constructor(client) { // client will default to apiClient if new TaskAPI() is called\r\n    super(client);\r\n  }\r\n\r\n  async getTasks(params = {}) {\r\n    try {\r\n      const queryString = this.buildQueryString(params);\r\n      const cacheKey = `tasks_list_${queryString || 'all'}`; \r\n      \r\n      return await this.getCachedData(\r\n        cacheKey, \r\n        () => this.client.get(`/tasks?${queryString}`),\r\n        { shortCache: true }\r\n      );\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in getTasks: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getTaskById(taskId) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required for getTaskById', 400, 'INVALID_TASK_ID');\r\n    }\r\n    const cacheKey = `task_item_${taskId}`;\r\n    try {\r\n      return await this.getCachedData(\r\n        cacheKey, \r\n        () => this.client.get(`/tasks/${taskId}`)\r\n      );\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in getTaskById (${taskId}): ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async createTask(taskData) {\r\n    if (!taskData || typeof taskData !== 'object' || !taskData.title) {\r\n      throw new APIError('Valid task data with a title is required for createTask', 400, 'INVALID_TASK_DATA');\r\n    }\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.post('/tasks', taskData), \r\n        'high'\r\n      );\r\n      \r\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\r\n      this.invalidateCache('task_stats');\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in createTask: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateTask(taskId, taskData) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required for updateTask', 400, 'INVALID_TASK_ID');\r\n    }\r\n    if (!taskData || typeof taskData !== 'object') {\r\n      throw new APIError('Valid task update data is required', 400, 'INVALID_TASK_UPDATE_DATA');\r\n    }\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.put(`/tasks/${taskId}`, taskData)\r\n      );\r\n      \r\n      this.invalidateCache(`task_item_${taskId}`);\r\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\r\n      this.invalidateCache('task_stats');\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in updateTask (${taskId}): ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deleteTask(taskId) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required for deleteTask', 400, 'INVALID_TASK_ID');\r\n    }\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.delete(`/tasks/${taskId}`)\r\n      );\r\n      \r\n      this.invalidateCache(`task_item_${taskId}`);\r\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\r\n      this.invalidateCache('task_stats');\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in deleteTask (${taskId}): ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async toggleTaskStatus(taskId) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required for toggleTaskStatus', 400, 'INVALID_TASK_ID');\r\n    }\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.patch(`/tasks/${taskId}/toggle`)\r\n      );\r\n      \r\n      this.invalidateCache(`task_item_${taskId}`);\r\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\r\n      this.invalidateCache('task_stats');\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in toggleTaskStatus (${taskId}): ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async searchTasks(searchTerm, filters = {}) {\r\n    if (!searchTerm || typeof searchTerm !== 'string') {\r\n      throw new APIError('Search term is required for searchTasks', 400, 'INVALID_SEARCH_TERM');\r\n    }\r\n    const params = { search: searchTerm, ...filters };\r\n    const queryString = this.buildQueryString(params);\r\n    const cacheKey = `tasks_search_${queryString}`;\r\n    \r\n    try {\r\n      return await this.getCachedData(\r\n        cacheKey,\r\n        () => this.client.get(`/tasks/search?${queryString}`),\r\n        { shortCache: true }\r\n      );\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in searchTasks: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getTaskStats() {\r\n    const cacheKey = 'task_stats';\r\n    try {\r\n      return await this.getCachedData(\r\n        cacheKey,\r\n        () => this.client.get('/tasks/stats'),\r\n        { longCache: true }\r\n      );\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in getTaskStats: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async bulkUpdateTasks(taskIds, updateData) {\r\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\r\n      throw new APIError('Task IDs array is required for bulkUpdateTasks', 400, 'INVALID_TASK_IDS');\r\n    }\r\n    if (!updateData || typeof updateData !== 'object') {\r\n      throw new APIError('Update data is required for bulkUpdateTasks', 400, 'INVALID_UPDATE_DATA');\r\n    }\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.put('/tasks/bulk-update', { taskIds, updateData }),\r\n        'high'\r\n      );\r\n      \r\n      taskIds.forEach(id => this.invalidateCache(`task_item_${id}`));\r\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\r\n      this.invalidateCache('task_stats');\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in bulkUpdateTasks: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async bulkDeleteTasks(taskIds) {\r\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\r\n      throw new APIError('Task IDs array is required for bulkDeleteTasks', 400, 'INVALID_TASK_IDS');\r\n    }\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.delete('/tasks/bulk-delete', { data: { taskIds } }), // Pass data for DELETE\r\n        'high'\r\n      );\r\n      \r\n      taskIds.forEach(id => this.invalidateCache(`task_item_${id}`));\r\n      this.invalidateCache(key => key.startsWith('tasks_list_'));\r\n      this.invalidateCache('task_stats');\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`TaskAPI Error in bulkDeleteTasks: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// AuthAPI does not extend BaseAPI as its methods have specific behaviors (no general caching/queueing)\r\nclass AuthAPI {\r\n  constructor(client = apiClient) {\r\n    this.client = client;\r\n    this.tokenManager = tokenManager; // Use the global tokenManager instance\r\n  }\r\n\r\n  async login(credentials) {\r\n    if (!credentials?.email || !credentials?.password) {\r\n      throw new APIError('Email and password are required for login', 400, 'INVALID_CREDENTIALS');\r\n    }\r\n    try {\r\n      // apiClient already returns data property due to interceptor\r\n      const responseData = await this.client.post('/auth/login', credentials);\r\n      if (responseData.token) { // Assuming 'token' and 'refreshToken' are in responseData\r\n        this.tokenManager.setTokens(responseData.token, responseData.refreshToken);\r\n      }\r\n      return responseData;\r\n    } catch (error) {\r\n      console.error(`AuthAPI Error in login: ${error.message}`, error);\r\n      throw error; // Error is already processed by interceptor\r\n    }\r\n  }\r\n\r\n  async register(userData) {\r\n    if (!userData?.email || !userData?.password) {\r\n      throw new APIError('Email and password are required for registration', 400, 'INVALID_USER_DATA');\r\n    }\r\n    try {\r\n      return await this.client.post('/auth/register', userData);\r\n    } catch (error) {\r\n      console.error(`AuthAPI Error in register: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async logout() {\r\n    try {\r\n      await this.client.post('/auth/logout');\r\n    } catch (error) {\r\n      // Log and ignore server-side logout errors, proceed with client-side cleanup\r\n      console.warn(`AuthAPI warning during logout: ${error.message}`, error);\r\n    } finally {\r\n      this.tokenManager.clearTokens(); // Always clear tokens client-side\r\n    }\r\n  }\r\n\r\n  async forgotPassword(email) {\r\n    if (!email) {\r\n      throw new APIError('Email is required for forgotPassword', 400, 'INVALID_EMAIL');\r\n    }\r\n    try {\r\n      return await this.client.post('/auth/forgot-password', { email });\r\n    } catch (error) {\r\n      console.error(`AuthAPI Error in forgotPassword: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async validateResetToken(token) {\r\n    if (!token) {\r\n      throw new APIError('Reset token is required for validateResetToken', 400, 'INVALID_TOKEN');\r\n    }\r\n    try {\r\n      return await this.client.get(`/auth/reset-password/${token}`);\r\n    } catch (error) {\r\n      console.error(`AuthAPI Error in validateResetToken: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async resetPassword(token, newPassword) {\r\n    if (!token || !newPassword) {\r\n      throw new APIError('Token and new password are required for resetPassword', 400, 'INVALID_RESET_DATA');\r\n    }\r\n    try {\r\n      return await this.client.post('/auth/reset-password', { token, newPassword });\r\n    } catch (error) {\r\n      console.error(`AuthAPI Error in resetPassword: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async refreshToken() {\r\n    // This delegates directly to tokenManager's refreshTokens method\r\n    try {\r\n      return await this.tokenManager.refreshTokens();\r\n    } catch (error) {\r\n       console.error(`AuthAPI Error in refreshToken: ${error.message}`, error);\r\n       throw error; // Error from tokenManager is already an AuthenticationError\r\n    }\r\n  }\r\n\r\n  isAuthenticated() {\r\n    return this.tokenManager.isAuthenticated();\r\n  }\r\n\r\n  getCurrentUserId() {\r\n    return this.tokenManager.getUserIdFromToken();\r\n  }\r\n}\r\n\r\nclass UserAPI extends BaseAPI {\r\n  constructor(client) { // client will default to apiClient if new UserAPI() is called\r\n    super(client);\r\n  }\r\n\r\n  async getProfile() {\r\n    try {\r\n      return await this.getCachedData(\r\n        'user_profile',\r\n        () => this.client.get('/user/profile'),\r\n        { longCache: true }\r\n      );\r\n    } catch (error) {\r\n      console.error(`UserAPI Error in getProfile: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateProfile(userData) {\r\n    if (!userData || typeof userData !== 'object') {\r\n      throw new APIError('User data object is required for updateProfile', 400, 'INVALID_USER_DATA');\r\n    }\r\n    try {\r\n      const result = await this.client.put('/user/profile', userData);\r\n      this.invalidateCache('user_profile'); // Invalidate after successful update\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`UserAPI Error in updateProfile: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async changePassword(passwordData) {\r\n    if (!passwordData?.currentPassword || !passwordData?.newPassword) {\r\n      throw new APIError('Current and new passwords are required for changePassword', 400, 'INVALID_PASSWORD_DATA');\r\n    }\r\n    try {\r\n      return await this.client.put('/user/password', passwordData);\r\n    } catch (error) {\r\n      console.error(`UserAPI Error in changePassword: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async uploadAvatar(file) {\r\n    if (!(file instanceof File)) {\r\n      throw new APIError('A valid File object is required for avatar upload', 400, 'INVALID_FILE');\r\n    }\r\n\r\n    const formData = new FormData();\r\n    formData.append('avatar', file);\r\n\r\n    try {\r\n      // For multipart/form-data, axios usually sets Content-Type automatically\r\n      // if you pass FormData directly as data.\r\n      const result = await this.client.post('/user/avatar', formData, {\r\n        headers: {\r\n          // 'Content-Type': 'multipart/form-data', // Axios should set this with boundary\r\n        }\r\n      });\r\n      this.invalidateCache('user_profile'); // Avatar change likely affects profile\r\n      return result;\r\n    } catch (error) {\r\n      console.error(`UserAPI Error in uploadAvatar: ${error.message}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Create API instances\r\nconst taskApi = new TaskAPI(); // Uses default apiClient\r\nconst authApi = new AuthAPI(); // Uses default apiClient and global tokenManager\r\nconst userApi = new UserAPI(); // Uses default apiClient\r\n\r\n// Consolidated API object for easier import and use\r\nconst api = {\r\n  tasks: taskApi,\r\n  auth: authApi,\r\n  user: userApi,\r\n  // Expose utility functions from tokenManager or for general use\r\n  isAuthenticated: () => tokenManager.isAuthenticated(),\r\n  getCurrentUserId: () => tokenManager.getUserIdFromToken(),\r\n  clearAllCache: () => { // More descriptive name\r\n    taskApi.invalidateCache(); // Clear all task-related cache\r\n    userApi.invalidateCache(); // Clear all user-related cache\r\n    // Add other API cache invalidations if they exist\r\n    if (process.env.NODE_ENV === 'development') console.log('🗑️ All known API caches cleared.');\r\n  },\r\n  // Expose error classes for type checking by consumers if needed\r\n  errors: {\r\n    APIError,\r\n    NetworkError,\r\n    AuthenticationError,\r\n    RateLimitError\r\n  }\r\n};\r\n\r\n// Export individual components and the consolidated api object\r\nexport {\r\n  apiClient, // The configured axios instance\r\n  taskApi,\r\n  authApi,\r\n  userApi,\r\n  tokenManager, // For direct token management if necessary\r\n  APIError,\r\n  NetworkError,\r\n  AuthenticationError,\r\n  RateLimitError,\r\n  BaseAPI // Export BaseAPI if it's intended to be subclassed externally\r\n};\r\n\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}