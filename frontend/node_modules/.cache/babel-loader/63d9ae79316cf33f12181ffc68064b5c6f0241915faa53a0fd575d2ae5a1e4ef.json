{"ast":null,"code":"import axios from 'axios';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport base64 from 'base-64'; // For decoding JWT\n\n// --- Configuration ---\n// TODO: Configure your API URL properly.\n// Use react-native-config, a simple config file, or hardcode for testing.\nconst API_URL = 'YOUR_API_ENDPOINT_HERE'; // e.g., 'https://yourapi.com/api' or 'http://localhost:3000/api'\nif (API_URL === 'YOUR_API_ENDPOINT_HERE') {\n  console.warn('API_URL is not configured in api.js. Please set your API endpoint.');\n}\n\n// --- Constants ---\nconst AUTH_TOKEN_KEY = 'authToken';\nconst REFRESH_TOKEN_KEY = 'refreshToken';\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504]; // Network or server errors eligible for retry\n\n// --- Axios Instance ---\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  timeout: 15000,\n  // Increased timeout for potentially slower mobile networks\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json' // Good practice for APIs\n  }\n  // withCredentials might be less relevant if using token auth, but keep if needed for cookies\n  // withCredentials: true,\n});\n\n// --- Request Interceptor (Async for AsyncStorage) ---\napiClient.interceptors.request.use(async config => {\n  const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\n  if (token) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Flag to prevent multiple concurrent token refresh attempts\nlet isRefreshing = false;\nlet failedQueue = []; // Store requests that failed due to 401\n\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\n// --- Response Interceptor (Async for AsyncStorage & Refresh Logic) ---\napiClient.interceptors.response.use(response => response.data,\n// Return only the data part of the response\nasync error => {\n  var _error$response, _error$response2, _error$response3, _error$response3$data, _error$response4;\n  const originalRequest = error.config;\n\n  // --- Retry Logic ---\n  const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\n  const shouldSkipRetry = skipRetryEndpoints.some(endpoint => {\n    var _originalRequest$url;\n    return (_originalRequest$url = originalRequest.url) === null || _originalRequest$url === void 0 ? void 0 : _originalRequest$url.includes(endpoint);\n  });\n  const status = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status;\n\n  // Check if eligible for retry\n  if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\n    if (!error.response || RETRY_CODES.includes(status)) {\n      originalRequest._retry = (originalRequest._retry || 0) + 1;\n      const jitter = Math.random() * 0.3;\n      const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10); // Cap backoff\n      let delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\n      console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms (Status: ${status || 'Network Error'})`);\n\n      // Handle rate limiting specifically\n      if (status === 429) {\n        var _error$response$heade;\n        const retryAfter = (_error$response$heade = error.response.headers) === null || _error$response$heade === void 0 ? void 0 : _error$response$heade['retry-after']; // Case-insensitive header check is handled by axios lowercasing keys\n        const retryAfterSeconds = retryAfter ? parseInt(retryAfter, 10) : null;\n        if (retryAfterSeconds) {\n          delay = retryAfterSeconds * 1000;\n          console.log(`Rate limited. Retrying after ${delay}ms (from Retry-After header)`);\n        } else {\n          console.log(`Rate limited. Retrying after calculated delay ${delay}ms`);\n        }\n      }\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return apiClient(originalRequest); // Retry the request\n    }\n  }\n\n  // --- Token Refresh Logic (401 Unauthorized) ---\n  if (status === 401 && !originalRequest._hasRefreshed) {\n    var _originalRequest$url2, _originalRequest$url3;\n    // Avoid refresh loops for refresh endpoint itself or login\n    if ((_originalRequest$url2 = originalRequest.url) !== null && _originalRequest$url2 !== void 0 && _originalRequest$url2.includes('/auth/refresh') || (_originalRequest$url3 = originalRequest.url) !== null && _originalRequest$url3 !== void 0 && _originalRequest$url3.includes('/auth/login')) {\n      // Clear tokens if refresh/login itself fails with 401\n      await AsyncStorage.removeItem(AUTH_TOKEN_KEY);\n      await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\n      // Signal logout needed - calling code should handle navigation\n      return Promise.reject(new Error('Authentication failed'));\n    }\n    if (isRefreshing) {\n      // If refresh is already in progress, queue the original request\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers['Authorization'] = 'Bearer ' + token;\n        return apiClient(originalRequest); // Retry with new token\n      }).catch(err => {\n        return Promise.reject(err); // Propagate the error from refresh failure\n      });\n    }\n    originalRequest._hasRefreshed = true; // Mark this request attempt\n    isRefreshing = true;\n    try {\n      const refreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n\n      // Use axios directly to avoid interceptor loop for refresh token request\n      const {\n        data\n      } = await axios.post(`${API_URL}/auth/refresh`, {\n        refreshToken\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        }\n        // No Authorization header needed for refresh token typically\n      });\n      const newAuthToken = data.token; // Adjust based on your refresh response structure\n      await AsyncStorage.setItem(AUTH_TOKEN_KEY, newAuthToken);\n\n      // If your API also returns a new refresh token, store it\n      if (data.refreshToken) {\n        await AsyncStorage.setItem(REFRESH_TOKEN_KEY, data.refreshToken);\n      }\n\n      // Apply the new token to the original request and subsequent queued requests\n      apiClient.defaults.headers.common['Authorization'] = `Bearer ${newAuthToken}`;\n      originalRequest.headers['Authorization'] = `Bearer ${newAuthToken}`;\n      processQueue(null, newAuthToken); // Resolve queued requests\n\n      return apiClient(originalRequest); // Retry the original request with the new token\n    } catch (refreshError) {\n      console.error('Token refresh failed:', refreshError.message);\n      await AsyncStorage.removeItem(AUTH_TOKEN_KEY);\n      await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\n      processQueue(refreshError, null); // Reject queued requests\n      // Signal logout needed - calling code should handle navigation\n      // We throw a specific error or the original one for context\n      return Promise.reject(new Error('Session expired. Please log in again.'));\n    } finally {\n      isRefreshing = false;\n    }\n  }\n\n  // --- Standardized Error Handling ---\n  const errorResponse = {\n    status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status,\n    message: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || error.message || 'An unknown error occurred',\n    data: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data,\n    config: originalRequest // Include original request config for debugging\n  };\n  console.error('API Error:', JSON.stringify(errorResponse, null, 2)); // Log detailed error\n  return Promise.reject(errorResponse); // Reject with standardized error object\n});\n\n// --- Authentication Utilities (Async) ---\nconst isAuthenticated = async () => {\n  const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\n  if (!token) return false;\n  try {\n    const payload = token.split('.')[1];\n    if (!payload) return false;\n    const decodedData = JSON.parse(base64.decode(payload));\n    const expirationTime = decodedData.exp * 1000; // Convert JWT exp (seconds) to milliseconds\n\n    return expirationTime > Date.now();\n  } catch (error) {\n    console.error('Error checking token validity:', error);\n    // If token is malformed, consider it invalid\n    await AsyncStorage.removeItem(AUTH_TOKEN_KEY); // Clean up bad token\n    await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\n    return false;\n  }\n};\nconst getCurrentUserId = async () => {\n  const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\n  if (!token) return null;\n  try {\n    const payload = token.split('.')[1];\n    if (!payload) return null;\n    const decodedData = JSON.parse(base64.decode(payload));\n    return decodedData.id || decodedData.sub; // Common JWT fields for user ID\n  } catch (error) {\n    console.error('Error extracting user ID from token:', error);\n    return null;\n  }\n};\n\n// Logout helper (Async)\nconst logout = async () => {\n  const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\n  const refreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);\n\n  // Clear local tokens immediately\n  await AsyncStorage.removeItem(AUTH_TOKEN_KEY);\n  await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\n  // Clear Authorization header from default Axios instance settings\n  delete apiClient.defaults.headers.common['Authorization'];\n\n  // Attempt to invalidate tokens on the server (best effort)\n  try {\n    // Send relevant tokens if your logout endpoint requires them\n    await apiClient.post('/auth/logout', {\n      refreshToken\n    }); // Adjust payload as needed\n  } catch (error) {\n    // Log error but don't prevent client-side logout\n    console.warn('Error during server logout API call:', error.message);\n  }\n  // NOTE: Navigation to login screen must be handled by the calling code (e.g., in App state management)\n};\n\n// Login helper (Async)\nconst login = async credentials => {\n  try {\n    const data = await apiClient.post('/auth/login', credentials);\n    if (data.token) {\n      await AsyncStorage.setItem(AUTH_TOKEN_KEY, data.token);\n      // Set default header for subsequent requests in this session\n      apiClient.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;\n    }\n    if (data.refreshToken) {\n      await AsyncStorage.setItem(REFRESH_TOKEN_KEY, data.refreshToken);\n    }\n    return data; // Return user data or confirmation\n  } catch (error) {\n    // Error already processed by interceptor, just re-throw\n    throw error;\n  }\n};\n\n// --- Enhanced Task API (Mostly unchanged, adapted query params) ---\nclass TaskAPI {\n  constructor() {\n    // Caching, queuing, rate limiting logic remains the same\n    this.cache = new Map();\n    this.pendingRequests = new Map();\n    this.requestQueue = [];\n    this.processing = false;\n    this.activeRequests = 0;\n    this.MAX_CONCURRENT = 5; // Adjusted for potentially less stable mobile networks\n    this.rateLimitPerSecond = 8; // Adjusted for mobile context\n    this.requestTimestamps = [];\n    this.cacheConfig = {\n      defaultExpiry: 30000,\n      longExpiry: 5 * 60 * 1000,\n      shortExpiry: 10000\n    };\n  }\n\n  // Helper to build query strings safely\n  buildQueryString(params) {\n    const queryParts = [];\n    for (const key in params) {\n      if (Object.prototype.hasOwnProperty.call(params, key) && params[key] !== undefined) {\n        queryParts.push(`${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`);\n      }\n    }\n    return queryParts.join('&');\n  }\n\n  // --- Caching, Queuing, Rate Limiting Methods (Keep as is from original) ---\n  // shouldRateLimit, trackRequest, getCachedData, invalidateCache,\n  // enqueueRequest, processQueue...\n  // (These methods are platform-independent JavaScript logic)\n\n  // --- API Methods using buildQueryString ---\n  getTasks(params = {}) {\n    const queryString = this.buildQueryString(params);\n    const cacheKey = `tasks_${queryString || 'all'}`; // Handle empty query string\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks${queryString ? `?${queryString}` : ''}`), {\n      shortCache: true\n    });\n  }\n  getTaskById(taskId) {\n    const cacheKey = `task_${taskId}`;\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/${taskId}`));\n  }\n  createTask(taskData) {\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.post('/tasks', taskData), 'high');\n  }\n  updateTask(taskId, taskData) {\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.put(`/tasks/${taskId}`, taskData));\n  }\n  deleteTask(taskId) {\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.delete(`/tasks/${taskId}`));\n  }\n  toggleTaskStatus(taskId) {\n    this.invalidateCache(`task_${taskId}`);\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.patch(`/tasks/${taskId}/toggle`));\n  }\n  bulkUpdateTasks(taskIds, updateData) {\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.put('/tasks/bulk-update', {\n      taskIds,\n      updateData\n    }), 'high');\n  }\n  bulkDeleteTasks(taskIds) {\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\n    this.invalidateCache(key => key.startsWith('tasks_'));\n    return this.enqueueRequest(() => apiClient.delete('/tasks/bulk-delete', {\n      data: {\n        taskIds\n      }\n    }) // Pass data for DELETE body\n    , 'high');\n  }\n  searchTasks(searchTerm, filters = {}) {\n    const params = {\n      search: searchTerm,\n      ...filters\n    };\n    const queryString = this.buildQueryString(params);\n    const cacheKey = `search_${queryString}`;\n    return this.getCachedData(cacheKey, () => apiClient.get(`/tasks/search${queryString ? `?${queryString}` : ''}`), {\n      shortCache: true\n    });\n  }\n  getTaskStats() {\n    return this.getCachedData('task_stats', () => apiClient.get('/tasks/stats'), {\n      longCache: true\n    });\n  }\n\n  // --- Add back the methods from the original implementation ---\n  // (Assume these methods are identical unless they use web-specific APIs)\n  shouldRateLimit() {\n    const now = Date.now();\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\n    return this.requestTimestamps.length >= this.rateLimitPerSecond;\n  }\n  trackRequest() {\n    this.requestTimestamps.push(Date.now());\n  }\n  getCachedData(key, fetchFn, options = {}) {\n    const cached = this.cache.get(key);\n    const expiryTime = options.longCache ? this.cacheConfig.longExpiry : options.shortCache ? this.cacheConfig.shortExpiry : this.cacheConfig.defaultExpiry;\n    if (cached && Date.now() - cached.timestamp < expiryTime) {\n      console.log(`Cache hit for key: ${key}`);\n      return Promise.resolve(cached.data);\n    }\n    console.log(`Cache miss for key: ${key}`);\n    if (this.pendingRequests.has(key)) {\n      console.log(`Request already pending for key: ${key}`);\n      return this.pendingRequests.get(key);\n    }\n    console.log(`Fetching data for key: ${key}`);\n    const request = this.enqueueRequest(() => fetchFn()).then(data => {\n      console.log(`Data fetched successfully for key: ${key}, caching.`);\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now()\n      });\n      this.pendingRequests.delete(key);\n      return data;\n    }).catch(error => {\n      console.error(`Error fetching data for key: ${key}`, error);\n      this.pendingRequests.delete(key);\n      // Don't cache errors unless specifically designed to\n      throw error;\n    });\n    this.pendingRequests.set(key, request);\n    return request;\n  }\n  invalidateCache(key = null) {\n    console.log(`Invalidating cache for: ${key === null ? 'all' : typeof key === 'function' ? 'matching keys' : key}`);\n    if (key === null) {\n      this.cache.clear();\n      console.log(\"Cleared all cache.\");\n    } else if (typeof key === 'string') {\n      const deleted = this.cache.delete(key);\n      if (deleted) console.log(`Invalidated cache for key: ${key}`);\n    } else if (typeof key === 'function') {\n      // Invalidate based on a predicate function\n      let invalidatedCount = 0;\n      for (const cacheKey of this.cache.keys()) {\n        if (key(cacheKey)) {\n          this.cache.delete(cacheKey);\n          invalidatedCount++;\n        }\n      }\n      console.log(`Invalidated ${invalidatedCount} cache entries based on predicate.`);\n    }\n  }\n  enqueueRequest(fn, priority = 'normal') {\n    return new Promise((resolve, reject) => {\n      const request = {\n        fn,\n        resolve,\n        reject,\n        priority,\n        timestamp: Date.now()\n      };\n\n      // Simple queueing for now, add priority logic if needed from original\n      this.requestQueue.push(request);\n      console.log(`Request queued (${priority}). Queue size: ${this.requestQueue.length}`);\n\n      // Start processing if not already running and within limits\n      this.processQueue();\n    });\n  }\n  async processQueue() {\n    // Prevent multiple concurrent processing loops, ensure only run if needed\n    if (this.processing || this.requestQueue.length === 0 || this.activeRequests >= this.MAX_CONCURRENT) {\n      if (this.requestQueue.length === 0 && this.activeRequests === 0) {\n        this.processing = false; // Ensure processing stops if queue empty and no active reqs\n      }\n      return;\n    }\n    this.processing = true; // Mark as processing\n\n    while (this.requestQueue.length > 0 && this.activeRequests < this.MAX_CONCURRENT) {\n      if (this.shouldRateLimit()) {\n        console.log(`Rate limit reached. Delaying queue processing.`);\n        // Use setTimeout to yield and check again later, preventing a busy-wait loop\n        setTimeout(() => {\n          this.processing = false; // Allow processQueue to be called again\n          this.processQueue();\n        }, 100); // Check again shortly\n        return; // Exit the current loop iteration\n      }\n      const request = this.requestQueue.shift(); // Get the next request\n      console.log(`Processing request. Active: ${this.activeRequests + 1}/${this.MAX_CONCURRENT}. Queue: ${this.requestQueue.length}`);\n      this.activeRequests++;\n      this.trackRequest(); // Track for rate limiting\n\n      // Execute the request asynchronously without blocking the loop\n      // Use an IIAFE (Immediately Invoked Async Function Expression) or simple async call\n      (async () => {\n        try {\n          const result = await request.fn();\n          request.resolve(result);\n        } catch (error) {\n          request.reject(error);\n        } finally {\n          this.activeRequests--;\n          console.log(`Request finished. Active: ${this.activeRequests}. Queue: ${this.requestQueue.length}`);\n          // Immediately try to process the next item if conditions allow\n          this.processing = false; // Reset processing flag before potentially recursive call\n          this.processQueue();\n        }\n      })(); // Execute immediately\n    }\n\n    // If the loop finished because MAX_CONCURRENT was reached but queue still has items,\n    // the finally block of the last finished request will trigger processQueue again.\n    // If loop finished because queue is empty, set processing to false.\n    if (this.requestQueue.length === 0) {\n      this.processing = false;\n      console.log(\"Request queue empty.\");\n    } else if (this.activeRequests === 0) {\n      // Edge case: if loop exited but active requests somehow became 0\n      this.processing = false;\n      this.processQueue(); // Try again\n    }\n    // If processing is true here, it means MAX_CONCURRENT was hit, and we are waiting for requests to finish.\n  }\n}\n\n// --- Auth API (Async Storage aware) ---\nclass AuthAPI {\n  login(credentials) {\n    // Uses the async login helper function\n    return login(credentials);\n  }\n  async register(userData) {\n    // Assumes registration doesn't immediately log in / return tokens handled by login()\n    return apiClient.post('/auth/register', userData);\n  }\n  logout() {\n    // Uses the async logout helper function\n    return logout();\n  }\n  async forgotPassword(email) {\n    return apiClient.post('/auth/forgot-password', {\n      email\n    });\n  }\n  async validateResetToken(token) {\n    return apiClient.get(`/auth/reset-password/${token}`);\n  }\n  async resetPassword(token, newPassword) {\n    return apiClient.post('/auth/reset-password', {\n      token,\n      newPassword\n    });\n  }\n\n  // Note: Refresh token logic is primarily handled by the interceptor now.\n  // This method could be kept for manual refresh triggers if needed.\n  async refreshToken() {\n    const refreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);\n    if (!refreshToken) {\n      return Promise.reject(new Error('No refresh token available for manual refresh'));\n    }\n    try {\n      const {\n        data\n      } = await axios.post(`${API_URL}/auth/refresh`, {\n        refreshToken\n      });\n      if (data.token) {\n        await AsyncStorage.setItem(AUTH_TOKEN_KEY, data.token);\n        apiClient.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;\n      }\n      if (data.refreshToken) {\n        await AsyncStorage.setItem(REFRESH_TOKEN_KEY, data.refreshToken);\n      }\n      return data;\n    } catch (error) {\n      var _error$response5, _error$response6;\n      console.error(\"Manual token refresh failed\", error);\n      // Decide if logout is necessary based on the error (e.g., 401 on refresh)\n      if (((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) === 401 || ((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) === 403) {\n        await logout(); // Trigger logout if refresh token is invalid\n        throw new Error(\"Session expired. Please log in again.\");\n      }\n      throw error; // Re-throw other errors\n    }\n  }\n  isAuthenticated() {\n    // Uses the async isAuthenticated helper\n    return isAuthenticated();\n  }\n  getCurrentUserId() {\n    // Uses the async getCurrentUserId helper\n    return getCurrentUserId();\n  }\n}\n\n// --- User API (Using TaskAPI's cache methods via instance) ---\nconst taskApiInstance = new TaskAPI(); // Create instance to share caching mechanism\n\nclass UserAPI {\n  async getProfile() {\n    // Use taskApiInstance's caching method\n    return taskApiInstance.getCachedData('user_profile', () => apiClient.get('/user/profile'), {\n      defaultExpiry: 60000\n    }); // Cache profile slightly longer maybe\n  }\n  async updateProfile(userData) {\n    taskApiInstance.invalidateCache('user_profile');\n    return apiClient.put('/user/profile', userData);\n  }\n  async changePassword(passwordData) {\n    // Password change likely doesn't affect cached profile data unless you cache specific flags\n    return apiClient.put('/user/password', passwordData);\n  }\n\n  // Expose cache invalidation if needed externally\n  invalidateUserProfileCache() {\n    taskApiInstance.invalidateCache('user_profile');\n  }\n}\n\n// --- Instantiate and Export ---\nconst authApi = new AuthAPI();\nconst userApi = new UserAPI();\n// Task API instance is already created: taskApiInstance\n\n// Consolidated API object\nconst api = {\n  tasks: taskApiInstance,\n  // Use the shared instance\n  auth: authApi,\n  user: userApi,\n  // Expose utility functions directly if convenient\n  isAuthenticated,\n  getCurrentUserId,\n  login,\n  // The async helper\n  logout // The async helper\n};\n\n// Export individuals and the consolidated object\nexport { apiClient,\n// The configured axios instance\ntaskApiInstance as taskApi,\n// Export instance with clear name\nauthApi, userApi, isAuthenticated,\n// Async version\ngetCurrentUserId,\n// Async version\nlogin,\n// Async version\nlogout // Async version\n};\n\n// Default export for easy import\nexport default api;","map":{"version":3,"names":["axios","AsyncStorage","base64","API_URL","console","warn","AUTH_TOKEN_KEY","REFRESH_TOKEN_KEY","MAX_RETRIES","RETRY_DELAY_MS","RETRY_CODES","apiClient","create","baseURL","timeout","headers","interceptors","request","use","config","token","getItem","error","Promise","reject","isRefreshing","failedQueue","processQueue","forEach","prom","resolve","response","data","_error$response","_error$response2","_error$response3","_error$response3$data","_error$response4","originalRequest","skipRetryEndpoints","shouldSkipRetry","some","endpoint","_originalRequest$url","url","includes","status","_retry","jitter","Math","random","backoffFactor","min","pow","delay","log","round","_error$response$heade","retryAfter","retryAfterSeconds","parseInt","setTimeout","_hasRefreshed","_originalRequest$url2","_originalRequest$url3","removeItem","Error","push","then","catch","err","refreshToken","post","newAuthToken","setItem","defaults","common","refreshError","message","errorResponse","JSON","stringify","isAuthenticated","payload","split","decodedData","parse","decode","expirationTime","exp","Date","now","getCurrentUserId","id","sub","logout","login","credentials","TaskAPI","constructor","cache","Map","pendingRequests","requestQueue","processing","activeRequests","MAX_CONCURRENT","rateLimitPerSecond","requestTimestamps","cacheConfig","defaultExpiry","longExpiry","shortExpiry","buildQueryString","params","queryParts","key","Object","prototype","hasOwnProperty","call","undefined","encodeURIComponent","join","getTasks","queryString","cacheKey","getCachedData","get","shortCache","getTaskById","taskId","createTask","taskData","invalidateCache","startsWith","enqueueRequest","updateTask","put","deleteTask","delete","toggleTaskStatus","patch","bulkUpdateTasks","taskIds","updateData","bulkDeleteTasks","searchTasks","searchTerm","filters","search","getTaskStats","longCache","shouldRateLimit","filter","time","length","trackRequest","fetchFn","options","cached","expiryTime","timestamp","has","set","clear","deleted","invalidatedCount","keys","fn","priority","shift","result","AuthAPI","register","userData","forgotPassword","email","validateResetToken","resetPassword","newPassword","_error$response5","_error$response6","taskApiInstance","UserAPI","getProfile","updateProfile","changePassword","passwordData","invalidateUserProfileCache","authApi","userApi","api","tasks","auth","user","taskApi"],"sources":["D:/Projects/todo list/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\nimport AsyncStorage from '@react-native-async-storage/async-storage';\r\nimport base64 from 'base-64'; // For decoding JWT\r\n\r\n// --- Configuration ---\r\n// TODO: Configure your API URL properly.\r\n// Use react-native-config, a simple config file, or hardcode for testing.\r\nconst API_URL = 'YOUR_API_ENDPOINT_HERE'; // e.g., 'https://yourapi.com/api' or 'http://localhost:3000/api'\r\nif (API_URL === 'YOUR_API_ENDPOINT_HERE') {\r\n  console.warn('API_URL is not configured in api.js. Please set your API endpoint.');\r\n}\r\n\r\n// --- Constants ---\r\nconst AUTH_TOKEN_KEY = 'authToken';\r\nconst REFRESH_TOKEN_KEY = 'refreshToken';\r\nconst MAX_RETRIES = 3;\r\nconst RETRY_DELAY_MS = 1000;\r\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504]; // Network or server errors eligible for retry\r\n\r\n// --- Axios Instance ---\r\nconst apiClient = axios.create({\r\n  baseURL: API_URL,\r\n  timeout: 15000, // Increased timeout for potentially slower mobile networks\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n    'Accept': 'application/json', // Good practice for APIs\r\n  },\r\n  // withCredentials might be less relevant if using token auth, but keep if needed for cookies\r\n  // withCredentials: true,\r\n});\r\n\r\n// --- Request Interceptor (Async for AsyncStorage) ---\r\napiClient.interceptors.request.use(\r\n  async (config) => {\r\n    const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\r\n    if (token) {\r\n      config.headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  (error) => Promise.reject(error)\r\n);\r\n\r\n// Flag to prevent multiple concurrent token refresh attempts\r\nlet isRefreshing = false;\r\nlet failedQueue = []; // Store requests that failed due to 401\r\n\r\nconst processQueue = (error, token = null) => {\r\n  failedQueue.forEach(prom => {\r\n    if (error) {\r\n      prom.reject(error);\r\n    } else {\r\n      prom.resolve(token);\r\n    }\r\n  });\r\n  failedQueue = [];\r\n};\r\n\r\n// --- Response Interceptor (Async for AsyncStorage & Refresh Logic) ---\r\napiClient.interceptors.response.use(\r\n  (response) => response.data, // Return only the data part of the response\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n\r\n    // --- Retry Logic ---\r\n    const skipRetryEndpoints = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\r\n    const shouldSkipRetry = skipRetryEndpoints.some(endpoint => originalRequest.url?.includes(endpoint));\r\n    const status = error.response?.status;\r\n\r\n    // Check if eligible for retry\r\n    if (!shouldSkipRetry && (!originalRequest._retry || originalRequest._retry < MAX_RETRIES)) {\r\n      if (!error.response || RETRY_CODES.includes(status)) {\r\n        originalRequest._retry = (originalRequest._retry || 0) + 1;\r\n\r\n        const jitter = Math.random() * 0.3;\r\n        const backoffFactor = Math.min(Math.pow(2, originalRequest._retry - 1), 10); // Cap backoff\r\n        let delay = RETRY_DELAY_MS * backoffFactor * (1 + jitter);\r\n\r\n        console.log(`API retry ${originalRequest._retry}/${MAX_RETRIES} for ${originalRequest.url} after ${Math.round(delay)}ms (Status: ${status || 'Network Error'})`);\r\n\r\n        // Handle rate limiting specifically\r\n        if (status === 429) {\r\n          const retryAfter = error.response.headers?.['retry-after']; // Case-insensitive header check is handled by axios lowercasing keys\r\n          const retryAfterSeconds = retryAfter ? parseInt(retryAfter, 10) : null;\r\n          if (retryAfterSeconds) {\r\n            delay = retryAfterSeconds * 1000;\r\n            console.log(`Rate limited. Retrying after ${delay}ms (from Retry-After header)`);\r\n          } else {\r\n             console.log(`Rate limited. Retrying after calculated delay ${delay}ms`);\r\n          }\r\n        }\r\n\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        return apiClient(originalRequest); // Retry the request\r\n      }\r\n    }\r\n\r\n    // --- Token Refresh Logic (401 Unauthorized) ---\r\n    if (status === 401 && !originalRequest._hasRefreshed) {\r\n      // Avoid refresh loops for refresh endpoint itself or login\r\n      if (originalRequest.url?.includes('/auth/refresh') || originalRequest.url?.includes('/auth/login')) {\r\n        // Clear tokens if refresh/login itself fails with 401\r\n        await AsyncStorage.removeItem(AUTH_TOKEN_KEY);\r\n        await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\r\n        // Signal logout needed - calling code should handle navigation\r\n        return Promise.reject(new Error('Authentication failed'));\r\n      }\r\n\r\n      if (isRefreshing) {\r\n        // If refresh is already in progress, queue the original request\r\n        return new Promise((resolve, reject) => {\r\n          failedQueue.push({ resolve, reject });\r\n        })\r\n        .then(token => {\r\n          originalRequest.headers['Authorization'] = 'Bearer ' + token;\r\n          return apiClient(originalRequest); // Retry with new token\r\n        })\r\n        .catch(err => {\r\n          return Promise.reject(err); // Propagate the error from refresh failure\r\n        });\r\n      }\r\n\r\n      originalRequest._hasRefreshed = true; // Mark this request attempt\r\n      isRefreshing = true;\r\n\r\n      try {\r\n        const refreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);\r\n        if (!refreshToken) {\r\n          throw new Error('No refresh token available');\r\n        }\r\n\r\n        // Use axios directly to avoid interceptor loop for refresh token request\r\n        const { data } = await axios.post(`${API_URL}/auth/refresh`, {\r\n          refreshToken\r\n        }, {\r\n          headers: { 'Content-Type': 'application/json' }\r\n          // No Authorization header needed for refresh token typically\r\n        });\r\n\r\n        const newAuthToken = data.token; // Adjust based on your refresh response structure\r\n        await AsyncStorage.setItem(AUTH_TOKEN_KEY, newAuthToken);\r\n\r\n        // If your API also returns a new refresh token, store it\r\n        if (data.refreshToken) {\r\n           await AsyncStorage.setItem(REFRESH_TOKEN_KEY, data.refreshToken);\r\n        }\r\n\r\n        // Apply the new token to the original request and subsequent queued requests\r\n        apiClient.defaults.headers.common['Authorization'] = `Bearer ${newAuthToken}`;\r\n        originalRequest.headers['Authorization'] = `Bearer ${newAuthToken}`;\r\n        processQueue(null, newAuthToken); // Resolve queued requests\r\n\r\n        return apiClient(originalRequest); // Retry the original request with the new token\r\n\r\n      } catch (refreshError) {\r\n        console.error('Token refresh failed:', refreshError.message);\r\n        await AsyncStorage.removeItem(AUTH_TOKEN_KEY);\r\n        await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\r\n        processQueue(refreshError, null); // Reject queued requests\r\n        // Signal logout needed - calling code should handle navigation\r\n        // We throw a specific error or the original one for context\r\n        return Promise.reject(new Error('Session expired. Please log in again.'));\r\n      } finally {\r\n        isRefreshing = false;\r\n      }\r\n    }\r\n\r\n    // --- Standardized Error Handling ---\r\n    const errorResponse = {\r\n      status: error.response?.status,\r\n      message: error.response?.data?.message || error.message || 'An unknown error occurred',\r\n      data: error.response?.data,\r\n      config: originalRequest // Include original request config for debugging\r\n    };\r\n\r\n    console.error('API Error:', JSON.stringify(errorResponse, null, 2)); // Log detailed error\r\n    return Promise.reject(errorResponse); // Reject with standardized error object\r\n  }\r\n);\r\n\r\n\r\n// --- Authentication Utilities (Async) ---\r\nconst isAuthenticated = async () => {\r\n  const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\r\n  if (!token) return false;\r\n\r\n  try {\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return false;\r\n\r\n    const decodedData = JSON.parse(base64.decode(payload));\r\n    const expirationTime = decodedData.exp * 1000; // Convert JWT exp (seconds) to milliseconds\r\n\r\n    return expirationTime > Date.now();\r\n  } catch (error) {\r\n    console.error('Error checking token validity:', error);\r\n    // If token is malformed, consider it invalid\r\n    await AsyncStorage.removeItem(AUTH_TOKEN_KEY); // Clean up bad token\r\n    await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\r\n    return false;\r\n  }\r\n};\r\n\r\nconst getCurrentUserId = async () => {\r\n  const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\r\n  if (!token) return null;\r\n\r\n  try {\r\n    const payload = token.split('.')[1];\r\n    if (!payload) return null;\r\n\r\n    const decodedData = JSON.parse(base64.decode(payload));\r\n    return decodedData.id || decodedData.sub; // Common JWT fields for user ID\r\n  } catch (error) {\r\n    console.error('Error extracting user ID from token:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Logout helper (Async)\r\nconst logout = async () => {\r\n  const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);\r\n  const refreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);\r\n\r\n  // Clear local tokens immediately\r\n  await AsyncStorage.removeItem(AUTH_TOKEN_KEY);\r\n  await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);\r\n  // Clear Authorization header from default Axios instance settings\r\n  delete apiClient.defaults.headers.common['Authorization'];\r\n\r\n  // Attempt to invalidate tokens on the server (best effort)\r\n  try {\r\n    // Send relevant tokens if your logout endpoint requires them\r\n    await apiClient.post('/auth/logout', { refreshToken }); // Adjust payload as needed\r\n  } catch (error) {\r\n    // Log error but don't prevent client-side logout\r\n    console.warn('Error during server logout API call:', error.message);\r\n  }\r\n  // NOTE: Navigation to login screen must be handled by the calling code (e.g., in App state management)\r\n};\r\n\r\n// Login helper (Async)\r\nconst login = async (credentials) => {\r\n  try {\r\n    const data = await apiClient.post('/auth/login', credentials);\r\n    if (data.token) {\r\n      await AsyncStorage.setItem(AUTH_TOKEN_KEY, data.token);\r\n      // Set default header for subsequent requests in this session\r\n      apiClient.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;\r\n    }\r\n    if (data.refreshToken) {\r\n      await AsyncStorage.setItem(REFRESH_TOKEN_KEY, data.refreshToken);\r\n    }\r\n    return data; // Return user data or confirmation\r\n  } catch (error) {\r\n    // Error already processed by interceptor, just re-throw\r\n    throw error;\r\n  }\r\n};\r\n\r\n// --- Enhanced Task API (Mostly unchanged, adapted query params) ---\r\nclass TaskAPI {\r\n  constructor() {\r\n    // Caching, queuing, rate limiting logic remains the same\r\n    this.cache = new Map();\r\n    this.pendingRequests = new Map();\r\n    this.requestQueue = [];\r\n    this.processing = false;\r\n    this.activeRequests = 0;\r\n    this.MAX_CONCURRENT = 5; // Adjusted for potentially less stable mobile networks\r\n    this.rateLimitPerSecond = 8; // Adjusted for mobile context\r\n    this.requestTimestamps = [];\r\n    this.cacheConfig = {\r\n      defaultExpiry: 30000,\r\n      longExpiry: 5 * 60 * 1000,\r\n      shortExpiry: 10000\r\n    };\r\n  }\r\n\r\n  // Helper to build query strings safely\r\n  buildQueryString(params) {\r\n      const queryParts = [];\r\n      for (const key in params) {\r\n          if (Object.prototype.hasOwnProperty.call(params, key) && params[key] !== undefined) {\r\n              queryParts.push(`${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`);\r\n          }\r\n      }\r\n      return queryParts.join('&');\r\n  }\r\n\r\n  // --- Caching, Queuing, Rate Limiting Methods (Keep as is from original) ---\r\n  // shouldRateLimit, trackRequest, getCachedData, invalidateCache,\r\n  // enqueueRequest, processQueue...\r\n  // (These methods are platform-independent JavaScript logic)\r\n\r\n  // --- API Methods using buildQueryString ---\r\n  getTasks(params = {}) {\r\n    const queryString = this.buildQueryString(params);\r\n    const cacheKey = `tasks_${queryString || 'all'}`; // Handle empty query string\r\n    return this.getCachedData(cacheKey, () =>\r\n      apiClient.get(`/tasks${queryString ? `?${queryString}` : ''}`)\r\n    , { shortCache: true });\r\n  }\r\n\r\n  getTaskById(taskId) {\r\n    const cacheKey = `task_${taskId}`;\r\n    return this.getCachedData(cacheKey, () =>\r\n      apiClient.get(`/tasks/${taskId}`)\r\n    );\r\n  }\r\n\r\n  createTask(taskData) {\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    return this.enqueueRequest(() =>\r\n      apiClient.post('/tasks', taskData)\r\n    , 'high');\r\n  }\r\n\r\n  updateTask(taskId, taskData) {\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    return this.enqueueRequest(() =>\r\n      apiClient.put(`/tasks/${taskId}`, taskData)\r\n    );\r\n  }\r\n\r\n  deleteTask(taskId) {\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    return this.enqueueRequest(() =>\r\n      apiClient.delete(`/tasks/${taskId}`)\r\n    );\r\n  }\r\n\r\n  toggleTaskStatus(taskId) {\r\n    this.invalidateCache(`task_${taskId}`);\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    return this.enqueueRequest(() =>\r\n      apiClient.patch(`/tasks/${taskId}/toggle`)\r\n    );\r\n  }\r\n\r\n  bulkUpdateTasks(taskIds, updateData) {\r\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    return this.enqueueRequest(() =>\r\n      apiClient.put('/tasks/bulk-update', { taskIds, updateData })\r\n    , 'high');\r\n  }\r\n\r\n  bulkDeleteTasks(taskIds) {\r\n    taskIds.forEach(id => this.invalidateCache(`task_${id}`));\r\n    this.invalidateCache((key) => key.startsWith('tasks_'));\r\n    return this.enqueueRequest(() =>\r\n      apiClient.delete('/tasks/bulk-delete', { data: { taskIds } }) // Pass data for DELETE body\r\n    , 'high');\r\n  }\r\n\r\n  searchTasks(searchTerm, filters = {}) {\r\n    const params = { search: searchTerm, ...filters };\r\n    const queryString = this.buildQueryString(params);\r\n    const cacheKey = `search_${queryString}`;\r\n    return this.getCachedData(cacheKey, () =>\r\n      apiClient.get(`/tasks/search${queryString ? `?${queryString}` : ''}`)\r\n    , { shortCache: true });\r\n  }\r\n\r\n  getTaskStats() {\r\n    return this.getCachedData('task_stats', () =>\r\n      apiClient.get('/tasks/stats')\r\n    , { longCache: true });\r\n  }\r\n\r\n  // --- Add back the methods from the original implementation ---\r\n  // (Assume these methods are identical unless they use web-specific APIs)\r\n  shouldRateLimit() {\r\n    const now = Date.now();\r\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\r\n    return this.requestTimestamps.length >= this.rateLimitPerSecond;\r\n  }\r\n\r\n  trackRequest() {\r\n    this.requestTimestamps.push(Date.now());\r\n  }\r\n\r\n  getCachedData(key, fetchFn, options = {}) {\r\n    const cached = this.cache.get(key);\r\n    const expiryTime = options.longCache\r\n      ? this.cacheConfig.longExpiry\r\n      : (options.shortCache ? this.cacheConfig.shortExpiry : this.cacheConfig.defaultExpiry);\r\n\r\n    if (cached && Date.now() - cached.timestamp < expiryTime) {\r\n      console.log(`Cache hit for key: ${key}`);\r\n      return Promise.resolve(cached.data);\r\n    }\r\n    console.log(`Cache miss for key: ${key}`);\r\n\r\n    if (this.pendingRequests.has(key)) {\r\n       console.log(`Request already pending for key: ${key}`);\r\n      return this.pendingRequests.get(key);\r\n    }\r\n\r\n    console.log(`Fetching data for key: ${key}`);\r\n    const request = this.enqueueRequest(() => fetchFn())\r\n      .then(data => {\r\n        console.log(`Data fetched successfully for key: ${key}, caching.`);\r\n        this.cache.set(key, { data, timestamp: Date.now() });\r\n        this.pendingRequests.delete(key);\r\n        return data;\r\n      })\r\n      .catch(error => {\r\n         console.error(`Error fetching data for key: ${key}`, error);\r\n        this.pendingRequests.delete(key);\r\n        // Don't cache errors unless specifically designed to\r\n        throw error;\r\n      });\r\n\r\n    this.pendingRequests.set(key, request);\r\n    return request;\r\n  }\r\n\r\n  invalidateCache(key = null) {\r\n     console.log(`Invalidating cache for: ${key === null ? 'all' : (typeof key === 'function' ? 'matching keys' : key)}`);\r\n    if (key === null) {\r\n      this.cache.clear();\r\n      console.log(\"Cleared all cache.\");\r\n    } else if (typeof key === 'string') {\r\n      const deleted = this.cache.delete(key);\r\n      if(deleted) console.log(`Invalidated cache for key: ${key}`);\r\n    } else if (typeof key === 'function') { // Invalidate based on a predicate function\r\n      let invalidatedCount = 0;\r\n      for (const cacheKey of this.cache.keys()) {\r\n        if (key(cacheKey)) {\r\n          this.cache.delete(cacheKey);\r\n          invalidatedCount++;\r\n        }\r\n      }\r\n      console.log(`Invalidated ${invalidatedCount} cache entries based on predicate.`);\r\n    }\r\n  }\r\n\r\n  enqueueRequest(fn, priority = 'normal') {\r\n    return new Promise((resolve, reject) => {\r\n      const request = { fn, resolve, reject, priority, timestamp: Date.now() };\r\n\r\n       // Simple queueing for now, add priority logic if needed from original\r\n      this.requestQueue.push(request);\r\n      console.log(`Request queued (${priority}). Queue size: ${this.requestQueue.length}`);\r\n\r\n      // Start processing if not already running and within limits\r\n      this.processQueue();\r\n    });\r\n  }\r\n\r\n  async processQueue() {\r\n    // Prevent multiple concurrent processing loops, ensure only run if needed\r\n    if (this.processing || this.requestQueue.length === 0 || this.activeRequests >= this.MAX_CONCURRENT) {\r\n        if(this.requestQueue.length === 0 && this.activeRequests === 0) {\r\n            this.processing = false; // Ensure processing stops if queue empty and no active reqs\r\n        }\r\n        return;\r\n    }\r\n\r\n    this.processing = true; // Mark as processing\r\n\r\n    while (this.requestQueue.length > 0 && this.activeRequests < this.MAX_CONCURRENT) {\r\n      if (this.shouldRateLimit()) {\r\n        console.log(`Rate limit reached. Delaying queue processing.`);\r\n        // Use setTimeout to yield and check again later, preventing a busy-wait loop\r\n        setTimeout(() => {\r\n            this.processing = false; // Allow processQueue to be called again\r\n            this.processQueue();\r\n        }, 100); // Check again shortly\r\n        return; // Exit the current loop iteration\r\n      }\r\n\r\n      const request = this.requestQueue.shift(); // Get the next request\r\n       console.log(`Processing request. Active: ${this.activeRequests + 1}/${this.MAX_CONCURRENT}. Queue: ${this.requestQueue.length}`);\r\n      this.activeRequests++;\r\n      this.trackRequest(); // Track for rate limiting\r\n\r\n      // Execute the request asynchronously without blocking the loop\r\n      // Use an IIAFE (Immediately Invoked Async Function Expression) or simple async call\r\n      (async () => {\r\n          try {\r\n              const result = await request.fn();\r\n              request.resolve(result);\r\n          } catch (error) {\r\n              request.reject(error);\r\n          } finally {\r\n              this.activeRequests--;\r\n              console.log(`Request finished. Active: ${this.activeRequests}. Queue: ${this.requestQueue.length}`);\r\n              // Immediately try to process the next item if conditions allow\r\n               this.processing = false; // Reset processing flag before potentially recursive call\r\n               this.processQueue();\r\n          }\r\n      })(); // Execute immediately\r\n    }\r\n\r\n    // If the loop finished because MAX_CONCURRENT was reached but queue still has items,\r\n    // the finally block of the last finished request will trigger processQueue again.\r\n    // If loop finished because queue is empty, set processing to false.\r\n     if (this.requestQueue.length === 0) {\r\n       this.processing = false;\r\n       console.log(\"Request queue empty.\");\r\n     } else if(this.activeRequests === 0) {\r\n        // Edge case: if loop exited but active requests somehow became 0\r\n        this.processing = false;\r\n        this.processQueue(); // Try again\r\n     }\r\n     // If processing is true here, it means MAX_CONCURRENT was hit, and we are waiting for requests to finish.\r\n  }\r\n}\r\n\r\n\r\n// --- Auth API (Async Storage aware) ---\r\nclass AuthAPI {\r\n  login(credentials) {\r\n    // Uses the async login helper function\r\n    return login(credentials);\r\n  }\r\n\r\n  async register(userData) {\r\n    // Assumes registration doesn't immediately log in / return tokens handled by login()\r\n    return apiClient.post('/auth/register', userData);\r\n  }\r\n\r\n  logout() {\r\n    // Uses the async logout helper function\r\n    return logout();\r\n  }\r\n\r\n  async forgotPassword(email) {\r\n    return apiClient.post('/auth/forgot-password', { email });\r\n  }\r\n\r\n  async validateResetToken(token) {\r\n    return apiClient.get(`/auth/reset-password/${token}`);\r\n  }\r\n\r\n  async resetPassword(token, newPassword) {\r\n    return apiClient.post('/auth/reset-password', { token, newPassword });\r\n  }\r\n\r\n  // Note: Refresh token logic is primarily handled by the interceptor now.\r\n  // This method could be kept for manual refresh triggers if needed.\r\n  async refreshToken() {\r\n    const refreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);\r\n    if (!refreshToken) {\r\n      return Promise.reject(new Error('No refresh token available for manual refresh'));\r\n    }\r\n    try {\r\n      const { data } = await axios.post(`${API_URL}/auth/refresh`, { refreshToken });\r\n      if (data.token) {\r\n        await AsyncStorage.setItem(AUTH_TOKEN_KEY, data.token);\r\n        apiClient.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;\r\n      }\r\n      if (data.refreshToken) {\r\n        await AsyncStorage.setItem(REFRESH_TOKEN_KEY, data.refreshToken);\r\n      }\r\n      return data;\r\n    } catch(error) {\r\n        console.error(\"Manual token refresh failed\", error);\r\n         // Decide if logout is necessary based on the error (e.g., 401 on refresh)\r\n        if (error.response?.status === 401 || error.response?.status === 403) {\r\n            await logout(); // Trigger logout if refresh token is invalid\r\n            throw new Error(\"Session expired. Please log in again.\");\r\n        }\r\n        throw error; // Re-throw other errors\r\n    }\r\n  }\r\n\r\n  isAuthenticated() {\r\n    // Uses the async isAuthenticated helper\r\n    return isAuthenticated();\r\n  }\r\n\r\n  getCurrentUserId() {\r\n    // Uses the async getCurrentUserId helper\r\n    return getCurrentUserId();\r\n  }\r\n}\r\n\r\n// --- User API (Using TaskAPI's cache methods via instance) ---\r\nconst taskApiInstance = new TaskAPI(); // Create instance to share caching mechanism\r\n\r\nclass UserAPI {\r\n  async getProfile() {\r\n    // Use taskApiInstance's caching method\r\n    return taskApiInstance.getCachedData('user_profile', () =>\r\n      apiClient.get('/user/profile')\r\n    , { defaultExpiry: 60000 }); // Cache profile slightly longer maybe\r\n  }\r\n\r\n  async updateProfile(userData) {\r\n    taskApiInstance.invalidateCache('user_profile');\r\n    return apiClient.put('/user/profile', userData);\r\n  }\r\n\r\n  async changePassword(passwordData) {\r\n    // Password change likely doesn't affect cached profile data unless you cache specific flags\r\n    return apiClient.put('/user/password', passwordData);\r\n  }\r\n\r\n  // Expose cache invalidation if needed externally\r\n  invalidateUserProfileCache() {\r\n      taskApiInstance.invalidateCache('user_profile');\r\n  }\r\n}\r\n\r\n// --- Instantiate and Export ---\r\nconst authApi = new AuthAPI();\r\nconst userApi = new UserAPI();\r\n// Task API instance is already created: taskApiInstance\r\n\r\n// Consolidated API object\r\nconst api = {\r\n  tasks: taskApiInstance, // Use the shared instance\r\n  auth: authApi,\r\n  user: userApi,\r\n  // Expose utility functions directly if convenient\r\n  isAuthenticated,\r\n  getCurrentUserId,\r\n  login, // The async helper\r\n  logout, // The async helper\r\n};\r\n\r\n// Export individuals and the consolidated object\r\nexport {\r\n  apiClient,    // The configured axios instance\r\n  taskApiInstance as taskApi, // Export instance with clear name\r\n  authApi,\r\n  userApi,\r\n  isAuthenticated, // Async version\r\n  getCurrentUserId, // Async version\r\n  login, // Async version\r\n  logout, // Async version\r\n};\r\n\r\n// Default export for easy import\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}