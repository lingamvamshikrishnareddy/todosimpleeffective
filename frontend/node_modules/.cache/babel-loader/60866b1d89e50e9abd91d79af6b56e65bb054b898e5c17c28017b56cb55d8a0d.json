{"ast":null,"code":"var _jsxFileName = \"D:\\\\Projects\\\\todo list\\\\frontend\\\\src\\\\components\\\\TaskKanban.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { DndContext, PointerSensor, useSensor, useSensors, DragOverlay, closestCorners,\n// Or closestCenter, depending on desired behavior\nKeyboardSensor } from '@dnd-kit/core';\nimport { sortableKeyboardCoordinates, arrayMove } from '@dnd-kit/sortable';\nimport { restrictToWindowEdges, restrictToParentElement } from '@dnd-kit/modifiers';\nimport KanbanColumn from './KanbanColumn';\nimport SortableTask from './SortableTask'; // Assuming SortableTask is used for overlay too\nimport './TaskKanban.css';\n\n// Define the columns and their corresponding statuses\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst KANBAN_COLUMNS = {\n  backlog: {\n    id: 'backlog',\n    title: 'Backlog',\n    status: 'backlog'\n  },\n  active: {\n    id: 'active',\n    title: 'Active',\n    status: 'active'\n  },\n  'under-review': {\n    id: 'under-review',\n    title: 'Under Review',\n    status: 'under-review'\n  },\n  completed: {\n    id: 'completed',\n    title: 'Completed',\n    status: 'completed'\n  }\n};\nconst TaskKanban = ({\n  tasks = [],\n  onEdit,\n  onDelete,\n  onStatusChange\n}) => {\n  _s();\n  const [columns, setColumns] = useState(() => {\n    // Initialize columns with empty taskIds arrays\n    const initialCols = {};\n    Object.values(KANBAN_COLUMNS).forEach(colInfo => {\n      initialCols[colInfo.id] = {\n        ...colInfo,\n        taskIds: []\n      };\n    });\n    return initialCols;\n  });\n  const [activeTask, setActiveTask] = useState(null); // Store the full task being dragged\n\n  // Group tasks into columns when tasks prop changes\n  useEffect(() => {\n    const newColumns = {};\n    Object.values(KANBAN_COLUMNS).forEach(colInfo => {\n      newColumns[colInfo.id] = {\n        ...colInfo,\n        taskIds: []\n      };\n    });\n    tasks.forEach(task => {\n      var _Object$values$find;\n      const taskId = task._id || task.id;\n      // Default to 'active' if status is missing or doesn't match a column\n      const taskStatus = task.status || 'active';\n      const targetColumnId = ((_Object$values$find = Object.values(KANBAN_COLUMNS).find(c => c.status === taskStatus)) === null || _Object$values$find === void 0 ? void 0 : _Object$values$find.id) || 'active';\n      if (newColumns[targetColumnId]) {\n        if (!newColumns[targetColumnId].taskIds.includes(taskId)) {\n          newColumns[targetColumnId].taskIds.push(taskId);\n        }\n      } else {\n        // Fallback if status somehow doesn't match known columns\n        if (!newColumns.active.taskIds.includes(taskId)) {\n          newColumns.active.taskIds.push(taskId);\n        }\n      }\n    });\n    setColumns(newColumns);\n  }, [tasks]); // Rerun when tasks array changes\n\n  // Find task by ID helper (memoized)\n  const getTaskById = useCallback(id => {\n    return tasks.find(task => (task._id || task.id) === id);\n  }, [tasks]);\n\n  // Setup sensors for drag detection\n  const sensors = useSensors(useSensor(PointerSensor, {\n    // Require the mouse to move more pixels before initiating a drag\n    // Helps distinguish between clicks and drags\n    activationConstraint: {\n      distance: 8 // Increased from 5\n    }\n  }), useSensor(KeyboardSensor, {\n    coordinateGetter: sortableKeyboardCoordinates\n  }));\n  const findColumnContainingTask = taskId => {\n    if (!taskId) return null;\n    return Object.values(columns).find(column => column.taskIds.includes(taskId));\n  };\n  const handleDragStart = event => {\n    const {\n      active\n    } = event;\n    const task = getTaskById(active.id);\n    setActiveTask(task); // Set the full task object for the overlay\n  };\n  const handleDragOver = event => {\n    var _over$data$current;\n    const {\n      active,\n      over\n    } = event;\n    if (!over || !active) return;\n    const activeId = active.id;\n    const overId = over.id;\n\n    // Prevent dropping on itself\n    if (activeId === overId) return;\n    const activeColumn = findColumnContainingTask(activeId);\n    const overColumn = findColumnContainingTask(overId) || (((_over$data$current = over.data.current) === null || _over$data$current === void 0 ? void 0 : _over$data$current.type) === 'column' ? columns[overId.replace('column:', '')] : null);\n    if (!activeColumn || !overColumn || activeColumn === overColumn) {\n      return; // Not dragging over a different valid column or task in a different column\n    }\n\n    // Preview the move\n    setColumns(prev => {\n      var _over$data$current2;\n      const activeItems = prev[activeColumn.id].taskIds;\n      const overItems = prev[overColumn.id].taskIds;\n      const activeIndex = activeItems.indexOf(activeId);\n      let overIndex = overItems.indexOf(overId);\n\n      // If dropping onto a column directly, find where to place it\n      if (overIndex === -1 && ((_over$data$current2 = over.data.current) === null || _over$data$current2 === void 0 ? void 0 : _over$data$current2.type) === 'column') {\n        // Drop at the end if dropping on the column container itself\n        overIndex = overItems.length;\n      } else if (overIndex === -1) {\n        var _over$data$current3, _over$data$current3$s, _over$data$current3$s2;\n        // Dropping onto a task within the target column\n        const overTaskElement = (_over$data$current3 = over.data.current) === null || _over$data$current3 === void 0 ? void 0 : (_over$data$current3$s = _over$data$current3.sortable) === null || _over$data$current3$s === void 0 ? void 0 : (_over$data$current3$s2 = _over$data$current3$s.node) === null || _over$data$current3$s2 === void 0 ? void 0 : _over$data$current3$s2.current;\n        if (overTaskElement) {\n          const isBelowOverItem = active.rect.current.translated && active.rect.current.translated.top > overTaskElement.offsetTop + overTaskElement.offsetHeight / 2;\n          overIndex = overItems.indexOf(overId) + (isBelowOverItem ? 1 : 0);\n        } else {\n          // Fallback if task element data isn't available\n          overIndex = overItems.length;\n        }\n      }\n\n      // Optimistic update preview\n      let newColumns = {\n        ...prev\n      };\n      newColumns[activeColumn.id] = {\n        ...prev[activeColumn.id],\n        taskIds: activeItems.filter(id => id !== activeId)\n      };\n\n      // Insert into new column preview\n      const updatedOverItems = [...overItems.slice(0, overIndex), activeId, ...overItems.slice(overIndex)];\n      newColumns[overColumn.id] = {\n        ...prev[overColumn.id],\n        taskIds: updatedOverItems\n      };\n      return newColumns;\n    });\n  };\n  const handleDragEnd = event => {\n    var _over$data$current4;\n    const {\n      active,\n      over\n    } = event;\n    setActiveTask(null); // Clear overlay task\n\n    if (!over) return; // Dropped outside any droppable\n\n    const activeId = active.id;\n    const overId = over.id;\n    const activeColumn = findColumnContainingTask(activeId);\n    // Determine destination: could be a column ID or a task ID\n    let overColumn;\n    if (((_over$data$current4 = over.data.current) === null || _over$data$current4 === void 0 ? void 0 : _over$data$current4.type) === 'column') {\n      overColumn = columns[overId.replace('column:', '')];\n    } else {\n      overColumn = findColumnContainingTask(overId);\n    }\n    if (!activeColumn || !overColumn) {\n      console.warn(\"Could not determine source or destination column.\");\n      // Optionally revert if state was optimistically updated in handleDragOver\n      // For simplicity now, we rely on the final update here.\n      return;\n    }\n    const activeColumnId = activeColumn.id;\n    const overColumnId = overColumn.id;\n\n    // If dropped in a different column\n    if (activeColumnId !== overColumnId) {\n      var _KANBAN_COLUMNS$overC;\n      const newStatus = ((_KANBAN_COLUMNS$overC = KANBAN_COLUMNS[overColumnId]) === null || _KANBAN_COLUMNS$overC === void 0 ? void 0 : _KANBAN_COLUMNS$overC.status) || 'active'; // Map col ID back to status\n\n      // Update local state (already previewed in handleDragOver, now finalize)\n      setColumns(prev => {\n        var _prev$activeColumnId, _prev$overColumnId;\n        const sourceTaskIds = ((_prev$activeColumnId = prev[activeColumnId]) === null || _prev$activeColumnId === void 0 ? void 0 : _prev$activeColumnId.taskIds) || [];\n        const destinationTaskIds = ((_prev$overColumnId = prev[overColumnId]) === null || _prev$overColumnId === void 0 ? void 0 : _prev$overColumnId.taskIds) || [];\n\n        // Ensure task is removed from source\n        const filteredSourceTaskIds = sourceTaskIds.filter(id => id !== activeId);\n\n        // Find correct insert position in destination\n        let overIndex = destinationTaskIds.indexOf(overId); // Index if dropped ON a task\n        if (overIndex === -1) {\n          // If dropped on the column or invalid task, add to the end\n          overIndex = destinationTaskIds.length;\n        } else {\n          var _over$data$current5, _over$data$current5$s, _over$data$current5$s2;\n          // Adjust index based on drop position relative to the task dropped on\n          const overTaskElement = (_over$data$current5 = over.data.current) === null || _over$data$current5 === void 0 ? void 0 : (_over$data$current5$s = _over$data$current5.sortable) === null || _over$data$current5$s === void 0 ? void 0 : (_over$data$current5$s2 = _over$data$current5$s.node) === null || _over$data$current5$s2 === void 0 ? void 0 : _over$data$current5$s2.current;\n          if (overTaskElement && active.rect.current.translated) {\n            const isBelowOverItem = active.rect.current.translated.top > overTaskElement.offsetTop + overTaskElement.offsetHeight / 2;\n            overIndex = overIndex + (isBelowOverItem ? 1 : 0);\n          }\n        }\n\n        // Ensure task isn't duplicated if already exists (can happen with rapid moves)\n        const uniqueDestinationTaskIds = destinationTaskIds.filter(id => id !== activeId);\n        const finalDestinationTaskIds = [...uniqueDestinationTaskIds.slice(0, overIndex), activeId, ...uniqueDestinationTaskIds.slice(overIndex)];\n        return {\n          ...prev,\n          [activeColumnId]: {\n            ...prev[activeColumnId],\n            taskIds: filteredSourceTaskIds\n          },\n          [overColumnId]: {\n            ...prev[overColumnId],\n            taskIds: finalDestinationTaskIds\n          }\n        };\n      });\n\n      // Call API to update task status\n      console.log(`Task ${activeId} moved from ${activeColumnId} to ${overColumnId}. New status: ${newStatus}`);\n      onStatusChange(activeId, newStatus);\n    } else {\n      // Task was moved within the same column (reordering)\n      const taskIds = columns[activeColumnId].taskIds;\n      const oldIndex = taskIds.indexOf(activeId);\n      const newIndex = taskIds.indexOf(overId); // overId will be a task ID here\n\n      if (oldIndex !== newIndex && oldIndex !== -1 && newIndex !== -1) {\n        setColumns(prev => ({\n          ...prev,\n          [activeColumnId]: {\n            ...prev[activeColumnId],\n            taskIds: arrayMove(taskIds, oldIndex, newIndex)\n          }\n        }));\n        // OPTIONAL: Call a backend endpoint here if you need to persist the order\n        // e.g., onReorder(activeColumnId, arrayMove(taskIds, oldIndex, newIndex));\n        console.log(`Task ${activeId} reordered within ${activeColumnId}.`);\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(DndContext, {\n    sensors: sensors,\n    collisionDetection: closestCorners // Strategy for detecting collision\n    ,\n    onDragStart: handleDragStart,\n    onDragOver: handleDragOver // Use for optimistic updates/previews\n    ,\n    onDragEnd: handleDragEnd,\n    modifiers: [restrictToWindowEdges, restrictToParentElement],\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"kanban-board\",\n      children: Object.values(columns).map(column => /*#__PURE__*/_jsxDEV(KanbanColumn, {\n        id: column.id // Pass the plain column ID\n        ,\n        title: column.title,\n        taskIds: column.taskIds,\n        tasks: tasks // Pass the full tasks array\n        ,\n        getTaskById: getTaskById // Pass the getter function\n        ,\n        onEdit: onEdit,\n        onDelete: onDelete\n      }, column.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 269,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 267,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(DragOverlay, {\n      children: activeTask ?\n      /*#__PURE__*/\n      // Render the actual SortableTask component for a more accurate overlay\n      _jsxDEV(SortableTask, {\n        id: activeTask._id || activeTask.id,\n        task: activeTask,\n        isOverlay: true // Add a prop to style overlay differently if needed\n        // Pass dummy handlers or disable actions for overlay\n        ,\n        onEdit: () => {},\n        onDelete: () => {}\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 284,\n        columnNumber: 11\n      }, this) : null\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 259,\n    columnNumber: 5\n  }, this);\n};\n_s(TaskKanban, \"zOKzuX3IhuAC8uM7glW0SExwMnM=\", false, function () {\n  return [useSensors, useSensor, useSensor];\n});\n_c = TaskKanban;\nexport default TaskKanban;\nvar _c;\n$RefreshReg$(_c, \"TaskKanban\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","DndContext","PointerSensor","useSensor","useSensors","DragOverlay","closestCorners","KeyboardSensor","sortableKeyboardCoordinates","arrayMove","restrictToWindowEdges","restrictToParentElement","KanbanColumn","SortableTask","jsxDEV","_jsxDEV","KANBAN_COLUMNS","backlog","id","title","status","active","completed","TaskKanban","tasks","onEdit","onDelete","onStatusChange","_s","columns","setColumns","initialCols","Object","values","forEach","colInfo","taskIds","activeTask","setActiveTask","newColumns","task","_Object$values$find","taskId","_id","taskStatus","targetColumnId","find","c","includes","push","getTaskById","sensors","activationConstraint","distance","coordinateGetter","findColumnContainingTask","column","handleDragStart","event","handleDragOver","_over$data$current","over","activeId","overId","activeColumn","overColumn","data","current","type","replace","prev","_over$data$current2","activeItems","overItems","activeIndex","indexOf","overIndex","length","_over$data$current3","_over$data$current3$s","_over$data$current3$s2","overTaskElement","sortable","node","isBelowOverItem","rect","translated","top","offsetTop","offsetHeight","filter","updatedOverItems","slice","handleDragEnd","_over$data$current4","console","warn","activeColumnId","overColumnId","_KANBAN_COLUMNS$overC","newStatus","_prev$activeColumnId","_prev$overColumnId","sourceTaskIds","destinationTaskIds","filteredSourceTaskIds","_over$data$current5","_over$data$current5$s","_over$data$current5$s2","uniqueDestinationTaskIds","finalDestinationTaskIds","log","oldIndex","newIndex","collisionDetection","onDragStart","onDragOver","onDragEnd","modifiers","children","className","map","fileName","_jsxFileName","lineNumber","columnNumber","isOverlay","_c","$RefreshReg$"],"sources":["D:/Projects/todo list/frontend/src/components/TaskKanban.js"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\r\nimport {\r\n  DndContext,\r\n  PointerSensor,\r\n  useSensor,\r\n  useSensors,\r\n  DragOverlay,\r\n  closestCorners, // Or closestCenter, depending on desired behavior\r\n  KeyboardSensor\r\n} from '@dnd-kit/core';\r\nimport { sortableKeyboardCoordinates, arrayMove } from '@dnd-kit/sortable';\r\nimport { restrictToWindowEdges, restrictToParentElement } from '@dnd-kit/modifiers';\r\nimport KanbanColumn from './KanbanColumn';\r\nimport SortableTask from './SortableTask'; // Assuming SortableTask is used for overlay too\r\nimport './TaskKanban.css';\r\n\r\n// Define the columns and their corresponding statuses\r\nconst KANBAN_COLUMNS = {\r\n  backlog: { id: 'backlog', title: 'Backlog', status: 'backlog' },\r\n  active: { id: 'active', title: 'Active', status: 'active' },\r\n  'under-review': { id: 'under-review', title: 'Under Review', status: 'under-review' },\r\n  completed: { id: 'completed', title: 'Completed', status: 'completed' },\r\n};\r\n\r\nconst TaskKanban = ({ tasks = [], onEdit, onDelete, onStatusChange }) => {\r\n  const [columns, setColumns] = useState(() => {\r\n      // Initialize columns with empty taskIds arrays\r\n      const initialCols = {};\r\n      Object.values(KANBAN_COLUMNS).forEach(colInfo => {\r\n          initialCols[colInfo.id] = { ...colInfo, taskIds: [] };\r\n      });\r\n      return initialCols;\r\n  });\r\n  const [activeTask, setActiveTask] = useState(null); // Store the full task being dragged\r\n\r\n  // Group tasks into columns when tasks prop changes\r\n  useEffect(() => {\r\n    const newColumns = {};\r\n     Object.values(KANBAN_COLUMNS).forEach(colInfo => {\r\n        newColumns[colInfo.id] = { ...colInfo, taskIds: [] };\r\n    });\r\n\r\n\r\n    tasks.forEach(task => {\r\n      const taskId = task._id || task.id;\r\n      // Default to 'active' if status is missing or doesn't match a column\r\n      const taskStatus = task.status || 'active';\r\n      const targetColumnId = Object.values(KANBAN_COLUMNS).find(c => c.status === taskStatus)?.id || 'active';\r\n\r\n       if (newColumns[targetColumnId]) {\r\n         if (!newColumns[targetColumnId].taskIds.includes(taskId)) {\r\n            newColumns[targetColumnId].taskIds.push(taskId);\r\n         }\r\n       } else {\r\n          // Fallback if status somehow doesn't match known columns\r\n          if (!newColumns.active.taskIds.includes(taskId)) {\r\n             newColumns.active.taskIds.push(taskId);\r\n          }\r\n       }\r\n    });\r\n\r\n    setColumns(newColumns);\r\n  }, [tasks]); // Rerun when tasks array changes\r\n\r\n  // Find task by ID helper (memoized)\r\n  const getTaskById = useCallback((id) => {\r\n    return tasks.find(task => (task._id || task.id) === id);\r\n  }, [tasks]);\r\n\r\n  // Setup sensors for drag detection\r\n  const sensors = useSensors(\r\n    useSensor(PointerSensor, {\r\n      // Require the mouse to move more pixels before initiating a drag\r\n      // Helps distinguish between clicks and drags\r\n      activationConstraint: {\r\n        distance: 8, // Increased from 5\r\n      },\r\n    }),\r\n    useSensor(KeyboardSensor, {\r\n        coordinateGetter: sortableKeyboardCoordinates,\r\n    })\r\n  );\r\n\r\n  const findColumnContainingTask = (taskId) => {\r\n    if (!taskId) return null;\r\n    return Object.values(columns).find(column => column.taskIds.includes(taskId));\r\n  };\r\n\r\n  const handleDragStart = (event) => {\r\n    const { active } = event;\r\n    const task = getTaskById(active.id);\r\n    setActiveTask(task); // Set the full task object for the overlay\r\n  };\r\n\r\n  const handleDragOver = (event) => {\r\n      const { active, over } = event;\r\n      if (!over || !active) return;\r\n\r\n      const activeId = active.id;\r\n      const overId = over.id;\r\n\r\n      // Prevent dropping on itself\r\n      if (activeId === overId) return;\r\n\r\n      const activeColumn = findColumnContainingTask(activeId);\r\n      const overColumn = findColumnContainingTask(overId) || (over.data.current?.type === 'column' ? columns[overId.replace('column:', '')] : null);\r\n\r\n      if (!activeColumn || !overColumn || activeColumn === overColumn) {\r\n          return; // Not dragging over a different valid column or task in a different column\r\n      }\r\n\r\n      // Preview the move\r\n      setColumns(prev => {\r\n          const activeItems = prev[activeColumn.id].taskIds;\r\n          const overItems = prev[overColumn.id].taskIds;\r\n\r\n          const activeIndex = activeItems.indexOf(activeId);\r\n          let overIndex = overItems.indexOf(overId);\r\n\r\n          // If dropping onto a column directly, find where to place it\r\n           if (overIndex === -1 && over.data.current?.type === 'column') {\r\n               // Drop at the end if dropping on the column container itself\r\n               overIndex = overItems.length;\r\n           } else if (overIndex === -1) {\r\n               // Dropping onto a task within the target column\r\n               const overTaskElement = over.data.current?.sortable?.node?.current;\r\n               if (overTaskElement) {\r\n                    const isBelowOverItem = active.rect.current.translated &&\r\n                                            active.rect.current.translated.top > overTaskElement.offsetTop + overTaskElement.offsetHeight / 2;\r\n                    overIndex = overItems.indexOf(overId) + (isBelowOverItem ? 1 : 0);\r\n               } else {\r\n                   // Fallback if task element data isn't available\r\n                   overIndex = overItems.length;\r\n               }\r\n\r\n           }\r\n\r\n\r\n          // Optimistic update preview\r\n          let newColumns = { ...prev };\r\n          newColumns[activeColumn.id] = {\r\n              ...prev[activeColumn.id],\r\n              taskIds: activeItems.filter(id => id !== activeId)\r\n          };\r\n\r\n          // Insert into new column preview\r\n          const updatedOverItems = [\r\n              ...overItems.slice(0, overIndex),\r\n              activeId,\r\n              ...overItems.slice(overIndex)\r\n          ];\r\n          newColumns[overColumn.id] = {\r\n              ...prev[overColumn.id],\r\n              taskIds: updatedOverItems\r\n          };\r\n\r\n          return newColumns;\r\n      });\r\n  };\r\n\r\n\r\n  const handleDragEnd = (event) => {\r\n    const { active, over } = event;\r\n    setActiveTask(null); // Clear overlay task\r\n\r\n    if (!over) return; // Dropped outside any droppable\r\n\r\n    const activeId = active.id;\r\n    const overId = over.id;\r\n\r\n    const activeColumn = findColumnContainingTask(activeId);\r\n    // Determine destination: could be a column ID or a task ID\r\n    let overColumn;\r\n    if (over.data.current?.type === 'column') {\r\n        overColumn = columns[overId.replace('column:', '')];\r\n    } else {\r\n        overColumn = findColumnContainingTask(overId);\r\n    }\r\n\r\n\r\n    if (!activeColumn || !overColumn) {\r\n        console.warn(\"Could not determine source or destination column.\");\r\n        // Optionally revert if state was optimistically updated in handleDragOver\r\n        // For simplicity now, we rely on the final update here.\r\n        return;\r\n    }\r\n\r\n    const activeColumnId = activeColumn.id;\r\n    const overColumnId = overColumn.id;\r\n\r\n    // If dropped in a different column\r\n    if (activeColumnId !== overColumnId) {\r\n        const newStatus = KANBAN_COLUMNS[overColumnId]?.status || 'active'; // Map col ID back to status\r\n\r\n        // Update local state (already previewed in handleDragOver, now finalize)\r\n        setColumns(prev => {\r\n            const sourceTaskIds = prev[activeColumnId]?.taskIds || [];\r\n            const destinationTaskIds = prev[overColumnId]?.taskIds || [];\r\n\r\n            // Ensure task is removed from source\r\n            const filteredSourceTaskIds = sourceTaskIds.filter(id => id !== activeId);\r\n\r\n            // Find correct insert position in destination\r\n             let overIndex = destinationTaskIds.indexOf(overId); // Index if dropped ON a task\r\n             if (overIndex === -1) {\r\n                 // If dropped on the column or invalid task, add to the end\r\n                 overIndex = destinationTaskIds.length;\r\n             } else {\r\n                 // Adjust index based on drop position relative to the task dropped on\r\n                 const overTaskElement = over.data.current?.sortable?.node?.current;\r\n                 if (overTaskElement && active.rect.current.translated) {\r\n                     const isBelowOverItem = active.rect.current.translated.top > overTaskElement.offsetTop + overTaskElement.offsetHeight / 2;\r\n                     overIndex = overIndex + (isBelowOverItem ? 1 : 0);\r\n                 }\r\n             }\r\n\r\n             // Ensure task isn't duplicated if already exists (can happen with rapid moves)\r\n             const uniqueDestinationTaskIds = destinationTaskIds.filter(id => id !== activeId);\r\n\r\n             const finalDestinationTaskIds = [\r\n                ...uniqueDestinationTaskIds.slice(0, overIndex),\r\n                activeId,\r\n                ...uniqueDestinationTaskIds.slice(overIndex)\r\n             ];\r\n\r\n            return {\r\n              ...prev,\r\n              [activeColumnId]: { ...prev[activeColumnId], taskIds: filteredSourceTaskIds },\r\n              [overColumnId]: { ...prev[overColumnId], taskIds: finalDestinationTaskIds },\r\n            };\r\n        });\r\n\r\n      // Call API to update task status\r\n      console.log(`Task ${activeId} moved from ${activeColumnId} to ${overColumnId}. New status: ${newStatus}`);\r\n      onStatusChange(activeId, newStatus);\r\n\r\n    } else {\r\n      // Task was moved within the same column (reordering)\r\n      const taskIds = columns[activeColumnId].taskIds;\r\n      const oldIndex = taskIds.indexOf(activeId);\r\n      const newIndex = taskIds.indexOf(overId); // overId will be a task ID here\r\n\r\n      if (oldIndex !== newIndex && oldIndex !== -1 && newIndex !== -1) {\r\n        setColumns(prev => ({\r\n          ...prev,\r\n          [activeColumnId]: {\r\n            ...prev[activeColumnId],\r\n            taskIds: arrayMove(taskIds, oldIndex, newIndex),\r\n          },\r\n        }));\r\n        // OPTIONAL: Call a backend endpoint here if you need to persist the order\r\n        // e.g., onReorder(activeColumnId, arrayMove(taskIds, oldIndex, newIndex));\r\n        console.log(`Task ${activeId} reordered within ${activeColumnId}.`);\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <DndContext\r\n      sensors={sensors}\r\n      collisionDetection={closestCorners} // Strategy for detecting collision\r\n      onDragStart={handleDragStart}\r\n      onDragOver={handleDragOver} // Use for optimistic updates/previews\r\n      onDragEnd={handleDragEnd}\r\n      modifiers={[restrictToWindowEdges, restrictToParentElement]}\r\n    >\r\n      <div className=\"kanban-board\">\r\n        {Object.values(columns).map(column => (\r\n          <KanbanColumn\r\n            key={column.id}\r\n            id={column.id} // Pass the plain column ID\r\n            title={column.title}\r\n            taskIds={column.taskIds}\r\n            tasks={tasks} // Pass the full tasks array\r\n            getTaskById={getTaskById} // Pass the getter function\r\n            onEdit={onEdit}\r\n            onDelete={onDelete}\r\n          />\r\n        ))}\r\n      </div>\r\n      <DragOverlay>\r\n        {activeTask ? (\r\n          // Render the actual SortableTask component for a more accurate overlay\r\n          <SortableTask\r\n             id={activeTask._id || activeTask.id}\r\n             task={activeTask}\r\n             isOverlay={true} // Add a prop to style overlay differently if needed\r\n             // Pass dummy handlers or disable actions for overlay\r\n             onEdit={() => {}}\r\n             onDelete={() => {}}\r\n           />\r\n        ) : null}\r\n      </DragOverlay>\r\n    </DndContext>\r\n  );\r\n};\r\n\r\nexport default TaskKanban;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}