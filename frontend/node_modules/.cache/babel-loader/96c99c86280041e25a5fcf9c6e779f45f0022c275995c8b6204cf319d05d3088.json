{"ast":null,"code":"import axios from 'axios';\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\n\n// Enhanced configuration with environment-specific settings\nconst API_CONFIG = {\n  baseURL: API_URL,\n  timeout: 15000,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true,\n  maxRetries: 3,\n  retryDelay: 1000,\n  rateLimitPerSecond: 10,\n  maxConcurrentRequests: 6,\n  cache: {\n    defaultExpiry: 30 * 1000,\n    // 30 seconds\n    longExpiry: 5 * 60 * 1000,\n    // 5 minutes\n    shortExpiry: 10 * 1000 // 10 seconds\n  }\n};\n\n// Enhanced error types for better error handling\nclass APIError extends Error {\n  constructor(message, status, code, originalError) {\n    super(message);\n    this.name = 'APIError';\n    this.status = status;\n    this.code = code;\n    this.originalError = originalError;\n    this.timestamp = new Date().toISOString();\n  }\n}\nclass NetworkError extends APIError {\n  constructor(message, originalError) {\n    super(message, null, 'NETWORK_ERROR', originalError);\n    this.name = 'NetworkError';\n  }\n}\nclass AuthenticationError extends APIError {\n  constructor(message, status = 401) {\n    super(message, status, 'AUTH_ERROR');\n    this.name = 'AuthenticationError';\n  }\n}\nclass RateLimitError extends APIError {\n  constructor(message, retryAfter) {\n    super(message, 429, 'RATE_LIMIT_ERROR');\n    this.name = 'RateLimitError';\n    this.retryAfter = retryAfter;\n  }\n}\n\n// Enhanced token management with better security practices\nclass TokenManager {\n  constructor() {\n    this.isRefreshing = false;\n    this.failedQueue = [];\n  }\n  getAuthToken() {\n    try {\n      return localStorage.getItem('authToken');\n    } catch (error) {\n      console.warn('Failed to access localStorage for auth token:', error);\n      return null;\n    }\n  }\n  getRefreshToken() {\n    try {\n      return localStorage.getItem('refreshToken');\n    } catch (error) {\n      console.warn('Failed to access localStorage for refresh token:', error);\n      return null;\n    }\n  }\n  setTokens(authToken, refreshToken) {\n    try {\n      if (authToken) localStorage.setItem('authToken', authToken);\n      if (refreshToken) localStorage.setItem('refreshToken', refreshToken);\n    } catch (error) {\n      console.error('Failed to store tokens:', error);\n      throw new Error('Token storage failed');\n    }\n  }\n  clearTokens() {\n    try {\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('refreshToken');\n    } catch (error) {\n      console.warn('Failed to clear tokens from localStorage:', error);\n    }\n  }\n  isTokenValid(token) {\n    if (!token) return false;\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n      const payload = JSON.parse(atob(parts[1]));\n      const expirationTime = payload.exp * 1000;\n      const bufferTime = 5 * 60 * 1000; // 5 minutes buffer\n\n      return expirationTime > Date.now() + bufferTime;\n    } catch (error) {\n      console.error('Error validating token:', error);\n      return false;\n    }\n  }\n  getUserIdFromToken(token = null) {\n    const authToken = token || this.getAuthToken();\n    if (!authToken) return null;\n    try {\n      const payload = JSON.parse(atob(authToken.split('.')[1]));\n      return payload.id || payload.sub || payload.userId;\n    } catch (error) {\n      console.error('Error extracting user ID from token:', error);\n      return null;\n    }\n  }\n  isAuthenticated() {\n    const token = this.getAuthToken();\n    return token && this.isTokenValid(token);\n  }\n  async refreshTokens() {\n    if (this.isRefreshing) {\n      return new Promise((resolve, reject) => {\n        this.failedQueue.push({\n          resolve,\n          reject\n        });\n      });\n    }\n    this.isRefreshing = true;\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      this.isRefreshing = false;\n      throw new AuthenticationError('No refresh token available');\n    }\n    try {\n      const response = await axios.post(`${API_URL}/auth/refresh`, {\n        refreshToken\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        withCredentials: true,\n        timeout: 10000\n      });\n      const {\n        token,\n        refreshToken: newRefreshToken\n      } = response.data;\n      this.setTokens(token, newRefreshToken);\n\n      // Process failed queue\n      this.failedQueue.forEach(({\n        resolve\n      }) => resolve(token));\n      this.failedQueue = [];\n      return token;\n    } catch (error) {\n      // Process failed queue with error\n      this.failedQueue.forEach(({\n        reject\n      }) => reject(error));\n      this.failedQueue = [];\n      this.clearTokens();\n      throw new AuthenticationError('Token refresh failed');\n    } finally {\n      this.isRefreshing = false;\n    }\n  }\n}\n\n// Create axios instance with enhanced configuration\nconst apiClient = axios.create(API_CONFIG);\nconst tokenManager = new TokenManager();\n\n// Enhanced request interceptor\napiClient.interceptors.request.use(config => {\n  const token = tokenManager.getAuthToken();\n  if (token && tokenManager.isTokenValid(token)) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n\n  // Add request ID for debugging\n  config.metadata = {\n    requestId: Math.random().toString(36).substr(2, 9),\n    startTime: Date.now()\n  };\n  return config;\n}, error => {\n  console.error('Request interceptor error:', error);\n  return Promise.reject(new NetworkError('Request configuration failed', error));\n});\n\n// Enhanced response interceptor with comprehensive error handling\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\nconst SKIP_RETRY_ENDPOINTS = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\napiClient.interceptors.response.use(response => {\n  // Log successful requests in development\n  if (process.env.NODE_ENV === 'development') {\n    var _response$config$meta, _response$config$meth;\n    const duration = Date.now() - ((_response$config$meta = response.config.metadata) === null || _response$config$meta === void 0 ? void 0 : _response$config$meta.startTime);\n    console.log(`âœ… ${(_response$config$meth = response.config.method) === null || _response$config$meth === void 0 ? void 0 : _response$config$meth.toUpperCase()} ${response.config.url} (${duration}ms)`);\n  }\n  return response.data;\n}, async error => {\n  var _originalRequest$meta, _error$response, _error$response2;\n  const originalRequest = error.config;\n  const requestId = originalRequest === null || originalRequest === void 0 ? void 0 : (_originalRequest$meta = originalRequest.metadata) === null || _originalRequest$meta === void 0 ? void 0 : _originalRequest$meta.requestId;\n\n  // Enhanced error logging\n  console.error(`âŒ API Error [${requestId}]:`, {\n    url: originalRequest === null || originalRequest === void 0 ? void 0 : originalRequest.url,\n    method: originalRequest === null || originalRequest === void 0 ? void 0 : originalRequest.method,\n    status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n    message: error.message,\n    data: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data\n  });\n\n  // Handle network errors\n  if (!error.response) {\n    throw new NetworkError('Network request failed', error);\n  }\n  const {\n    status,\n    data\n  } = error.response;\n\n  // Handle authentication errors\n  if (status === 401 && !originalRequest._authRetried) {\n    var _originalRequest$url, _originalRequest$url2;\n    // Skip refresh for certain endpoints\n    if ((_originalRequest$url = originalRequest.url) !== null && _originalRequest$url !== void 0 && _originalRequest$url.includes('/auth/refresh') || (_originalRequest$url2 = originalRequest.url) !== null && _originalRequest$url2 !== void 0 && _originalRequest$url2.includes('/auth/login')) {\n      throw new AuthenticationError('Authentication failed');\n    }\n    originalRequest._authRetried = true;\n    try {\n      const newToken = await tokenManager.refreshTokens();\n      originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\n      return apiClient(originalRequest);\n    } catch (refreshError) {\n      // Redirect to login only if not already there\n      if (typeof window !== 'undefined' && window.location.pathname !== '/login') {\n        window.location.href = '/login';\n      }\n      throw new AuthenticationError('Session expired. Please login again.');\n    }\n  }\n\n  // Handle rate limiting\n  if (status === 429) {\n    const retryAfter = error.response.headers['retry-after'];\n    const delay = retryAfter ? parseInt(retryAfter, 10) * 1000 : 2000;\n    throw new RateLimitError('Rate limit exceeded', delay);\n  }\n\n  // Handle retry logic for specific error codes\n  const shouldSkipRetry = SKIP_RETRY_ENDPOINTS.some(endpoint => {\n    var _originalRequest$url3;\n    return (_originalRequest$url3 = originalRequest.url) === null || _originalRequest$url3 === void 0 ? void 0 : _originalRequest$url3.includes(endpoint);\n  });\n  if (!shouldSkipRetry && RETRY_CODES.includes(status)) {\n    const retryCount = originalRequest._retryCount || 0;\n    if (retryCount < API_CONFIG.maxRetries) {\n      originalRequest._retryCount = retryCount + 1;\n      const backoffDelay = Math.min(API_CONFIG.retryDelay * Math.pow(2, retryCount) * (1 + Math.random() * 0.3), 10000);\n      console.log(`ðŸ”„ Retrying request ${retryCount + 1}/${API_CONFIG.maxRetries} after ${Math.round(backoffDelay)}ms`);\n      await new Promise(resolve => setTimeout(resolve, backoffDelay));\n      return apiClient(originalRequest);\n    }\n  }\n\n  // Create standardized error response\n  const errorMessage = (data === null || data === void 0 ? void 0 : data.message) || error.message || 'An unknown error occurred';\n  throw new APIError(errorMessage, status, data === null || data === void 0 ? void 0 : data.code, error);\n});\n\n// Enhanced base API class with better architecture\nclass BaseAPI {\n  constructor(client = apiClient) {\n    this.client = client;\n    this.cache = new Map();\n    this.pendingRequests = new Map();\n    this.requestQueue = [];\n    this.processing = false;\n    this.activeRequests = 0;\n    this.requestTimestamps = [];\n\n    // Bind methods to preserve context\n    this.processQueue = this.processQueue.bind(this);\n    this.enqueueRequest = this.enqueueRequest.bind(this);\n  }\n\n  // Rate limiting\n  shouldRateLimit() {\n    const now = Date.now();\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\n    return this.requestTimestamps.length >= API_CONFIG.rateLimitPerSecond;\n  }\n  trackRequest() {\n    this.requestTimestamps.push(Date.now());\n  }\n\n  // Cache management\n  getCachedData(key, fetchFn, options = {}) {\n    const cached = this.cache.get(key);\n    const expiryTime = options.longCache ? API_CONFIG.cache.longExpiry : options.shortCache ? API_CONFIG.cache.shortExpiry : API_CONFIG.cache.defaultExpiry;\n    if (cached && !cached.isError && Date.now() - cached.timestamp < expiryTime) {\n      return Promise.resolve(cached.data);\n    }\n\n    // Check for cached errors (short-term error caching to prevent hammering)\n    if (cached !== null && cached !== void 0 && cached.isError && Date.now() - cached.timestamp < 5000) {\n      return Promise.reject(cached.error);\n    }\n    if (this.pendingRequests.has(key)) {\n      return this.pendingRequests.get(key);\n    }\n    const requestPromise = this.enqueueRequest(fetchFn).then(data => {\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now(),\n        isError: false\n      });\n      this.pendingRequests.delete(key);\n      return data;\n    }).catch(error => {\n      // Cache errors for a short period to prevent repeated failed requests\n      this.cache.set(key, {\n        error,\n        timestamp: Date.now(),\n        isError: true\n      });\n      this.pendingRequests.delete(key);\n      throw error;\n    });\n    this.pendingRequests.set(key, requestPromise);\n    return requestPromise;\n  }\n  invalidateCache(keyOrPredicate = null) {\n    if (keyOrPredicate === null) {\n      this.cache.clear();\n      console.log('ðŸ—‘ï¸ Cache cleared entirely');\n    } else if (typeof keyOrPredicate === 'string') {\n      this.cache.delete(keyOrPredicate);\n      console.log(`ðŸ—‘ï¸ Cache invalidated for key: ${keyOrPredicate}`);\n    } else if (typeof keyOrPredicate === 'function') {\n      let invalidatedCount = 0;\n      for (const cacheKey of this.cache.keys()) {\n        if (keyOrPredicate(cacheKey)) {\n          this.cache.delete(cacheKey);\n          invalidatedCount++;\n        }\n      }\n      console.log(`ðŸ—‘ï¸ Cache invalidated for ${invalidatedCount} keys matching predicate`);\n    }\n  }\n\n  // Enhanced queue management\n  enqueueRequest(fn, priority = 'normal') {\n    return new Promise((resolve, reject) => {\n      const request = {\n        fn,\n        resolve,\n        reject,\n        priority,\n        timestamp: Date.now(),\n        id: Math.random().toString(36).substr(2, 9)\n      };\n\n      // Insert based on priority\n      if (priority === 'high') {\n        this.requestQueue.unshift(request);\n      } else if (priority === 'normal') {\n        const lowPriorityIndex = this.requestQueue.findIndex(r => r.priority === 'low');\n        if (lowPriorityIndex !== -1) {\n          this.requestQueue.splice(lowPriorityIndex, 0, request);\n        } else {\n          this.requestQueue.push(request);\n        }\n      } else {\n        this.requestQueue.push(request); // low priority\n      }\n      this.processQueue();\n    });\n  }\n  async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n    const processNext = async () => {\n      if (this.requestQueue.length === 0) return;\n      if (this.shouldRateLimit()) {\n        setTimeout(processNext, 100 + Math.random() * 50);\n        return;\n      }\n      const request = this.requestQueue.shift();\n      if (!request) return;\n      this.activeRequests++;\n      this.trackRequest();\n      try {\n        const result = await request.fn();\n        request.resolve(result);\n      } catch (error) {\n        request.reject(error);\n      } finally {\n        this.activeRequests--;\n        // Continue processing if there are more requests\n        if (this.requestQueue.length > 0) {\n          processNext();\n        }\n      }\n    };\n\n    // Start multiple processors up to the concurrent limit\n    const processors = [];\n    while (this.activeRequests < API_CONFIG.maxConcurrentRequests && this.requestQueue.length > 0 && !this.shouldRateLimit()) {\n      processors.push(processNext());\n    }\n    if (processors.length > 0) {\n      await Promise.allSettled(processors);\n    }\n\n    // Continue processing if needed\n    if (this.requestQueue.length > 0 && this.activeRequests < API_CONFIG.maxConcurrentRequests) {\n      this.processing = false;\n      this.processQueue();\n    } else {\n      this.processing = false;\n    }\n  }\n\n  // Utility method for building query strings\n  buildQueryString(params) {\n    const queryParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && value !== '') {\n        if (Array.isArray(value)) {\n          value.forEach(v => queryParams.append(key, v));\n        } else {\n          queryParams.append(key, value);\n        }\n      }\n    });\n    return queryParams.toString();\n  }\n}\n\n// Enhanced TaskAPI with better error handling and validation\nclass TaskAPI extends BaseAPI {\n  async getTasks(params = {}) {\n    try {\n      const queryString = this.buildQueryString(params);\n      const cacheKey = `tasks_${queryString || 'all'}`;\n      return await this.getCachedData(cacheKey, () => this.client.get(`/tasks?${queryString}`), {\n        shortCache: true\n      });\n    } catch (error) {\n      console.error('Failed to fetch tasks:', error);\n      throw error;\n    }\n  }\n  async getTaskById(taskId) {\n    if (!taskId) {\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\n    }\n    const cacheKey = `task_${taskId}`;\n    return this.getCachedData(cacheKey, () => this.client.get(`/tasks/${taskId}`));\n  }\n  async createTask(taskData) {\n    if (!taskData || typeof taskData !== 'object') {\n      throw new APIError('Valid task data is required', 400, 'INVALID_TASK_DATA');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.post('/tasks', taskData), 'high');\n\n      // Invalidate related caches\n      this.invalidateCache(key => key.startsWith('tasks_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error('Failed to create task:', error);\n      throw error;\n    }\n  }\n  async updateTask(taskId, taskData) {\n    if (!taskId) {\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\n    }\n    if (!taskData || typeof taskData !== 'object') {\n      throw new APIError('Valid task data is required', 400, 'INVALID_TASK_DATA');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.put(`/tasks/${taskId}`, taskData));\n\n      // Invalidate caches\n      this.invalidateCache(`task_${taskId}`);\n      this.invalidateCache(key => key.startsWith('tasks_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`Failed to update task ${taskId}:`, error);\n      throw error;\n    }\n  }\n  async deleteTask(taskId) {\n    if (!taskId) {\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.delete(`/tasks/${taskId}`));\n\n      // Invalidate caches\n      this.invalidateCache(`task_${taskId}`);\n      this.invalidateCache(key => key.startsWith('tasks_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`Failed to delete task ${taskId}:`, error);\n      throw error;\n    }\n  }\n  async toggleTaskStatus(taskId) {\n    if (!taskId) {\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.patch(`/tasks/${taskId}/toggle`));\n\n      // Invalidate caches\n      this.invalidateCache(`task_${taskId}`);\n      this.invalidateCache(key => key.startsWith('tasks_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error(`Failed to toggle task status ${taskId}:`, error);\n      throw error;\n    }\n  }\n  async searchTasks(searchTerm, filters = {}) {\n    if (!searchTerm || typeof searchTerm !== 'string') {\n      throw new APIError('Search term is required', 400, 'INVALID_SEARCH_TERM');\n    }\n    const params = {\n      search: searchTerm,\n      ...filters\n    };\n    const queryString = this.buildQueryString(params);\n    const cacheKey = `search_${queryString}`;\n    return this.getCachedData(cacheKey, () => this.client.get(`/tasks/search?${queryString}`), {\n      shortCache: true\n    });\n  }\n  async getTaskStats() {\n    return this.getCachedData('task_stats', () => this.client.get('/tasks/stats'), {\n      longCache: true\n    });\n  }\n  async bulkUpdateTasks(taskIds, updateData) {\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\n      throw new APIError('Task IDs array is required', 400, 'INVALID_TASK_IDS');\n    }\n    if (!updateData || typeof updateData !== 'object') {\n      throw new APIError('Update data is required', 400, 'INVALID_UPDATE_DATA');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.put('/tasks/bulk-update', {\n        taskIds,\n        updateData\n      }), 'high');\n\n      // Invalidate caches\n      taskIds.forEach(id => this.invalidateCache(`task_${id}`));\n      this.invalidateCache(key => key.startsWith('tasks_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error('Failed to bulk update tasks:', error);\n      throw error;\n    }\n  }\n  async bulkDeleteTasks(taskIds) {\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\n      throw new APIError('Task IDs array is required', 400, 'INVALID_TASK_IDS');\n    }\n    try {\n      const result = await this.enqueueRequest(() => this.client.delete('/tasks/bulk-delete', {\n        data: {\n          taskIds\n        }\n      }), 'high');\n\n      // Invalidate caches\n      taskIds.forEach(id => this.invalidateCache(`task_${id}`));\n      this.invalidateCache(key => key.startsWith('tasks_'));\n      this.invalidateCache('task_stats');\n      return result;\n    } catch (error) {\n      console.error('Failed to bulk delete tasks:', error);\n      throw error;\n    }\n  }\n}\n\n// Enhanced AuthAPI with comprehensive authentication handling\nclass AuthAPI {\n  constructor(client = apiClient) {\n    this.client = client;\n    this.tokenManager = tokenManager;\n  }\n  async login(credentials) {\n    if (!(credentials !== null && credentials !== void 0 && credentials.email) || !(credentials !== null && credentials !== void 0 && credentials.password)) {\n      throw new APIError('Email and password are required', 400, 'INVALID_CREDENTIALS');\n    }\n    try {\n      const data = await this.client.post('/auth/login', credentials);\n      if (data.token) {\n        this.tokenManager.setTokens(data.token, data.refreshToken);\n      }\n      return data;\n    } catch (error) {\n      console.error('Login failed:', error);\n      throw error;\n    }\n  }\n  async register(userData) {\n    if (!(userData !== null && userData !== void 0 && userData.email) || !(userData !== null && userData !== void 0 && userData.password)) {\n      throw new APIError('Email and password are required', 400, 'INVALID_USER_DATA');\n    }\n    try {\n      return await this.client.post('/auth/register', userData);\n    } catch (error) {\n      console.error('Registration failed:', error);\n      throw error;\n    }\n  }\n  async logout() {\n    try {\n      await this.client.post('/auth/logout');\n    } catch (error) {\n      console.warn('Logout API call failed:', error);\n      // Continue with client-side logout even if server logout fails\n    } finally {\n      this.tokenManager.clearTokens();\n    }\n  }\n  async forgotPassword(email) {\n    if (!email) {\n      throw new APIError('Email is required', 400, 'INVALID_EMAIL');\n    }\n    return this.client.post('/auth/forgot-password', {\n      email\n    });\n  }\n  async validateResetToken(token) {\n    if (!token) {\n      throw new APIError('Reset token is required', 400, 'INVALID_TOKEN');\n    }\n    return this.client.get(`/auth/reset-password/${token}`);\n  }\n  async resetPassword(token, newPassword) {\n    if (!token || !newPassword) {\n      throw new APIError('Token and new password are required', 400, 'INVALID_RESET_DATA');\n    }\n    return this.client.post('/auth/reset-password', {\n      token,\n      newPassword\n    });\n  }\n  async refreshToken() {\n    return this.tokenManager.refreshTokens();\n  }\n  isAuthenticated() {\n    return this.tokenManager.isAuthenticated();\n  }\n  getCurrentUserId() {\n    return this.tokenManager.getUserIdFromToken();\n  }\n}\n\n// Enhanced UserAPI with caching and validation\nclass UserAPI extends BaseAPI {\n  async getProfile() {\n    return this.getCachedData('user_profile', () => this.client.get('/user/profile'), {\n      longCache: true\n    });\n  }\n  async updateProfile(userData) {\n    if (!userData || typeof userData !== 'object') {\n      throw new APIError('User data is required', 400, 'INVALID_USER_DATA');\n    }\n    try {\n      const result = await this.client.put('/user/profile', userData);\n      this.invalidateCache('user_profile');\n      return result;\n    } catch (error) {\n      console.error('Failed to update profile:', error);\n      throw error;\n    }\n  }\n  async changePassword(passwordData) {\n    if (!(passwordData !== null && passwordData !== void 0 && passwordData.currentPassword) || !(passwordData !== null && passwordData !== void 0 && passwordData.newPassword)) {\n      throw new APIError('Current and new passwords are required', 400, 'INVALID_PASSWORD_DATA');\n    }\n    return this.client.put('/user/password', passwordData);\n  }\n  async uploadAvatar(file) {\n    if (!file) {\n      throw new APIError('File is required', 400, 'INVALID_FILE');\n    }\n    const formData = new FormData();\n    formData.append('avatar', file);\n    try {\n      const result = await this.client.post('/user/avatar', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n      this.invalidateCache('user_profile');\n      return result;\n    } catch (error) {\n      console.error('Failed to upload avatar:', error);\n      throw error;\n    }\n  }\n}\n\n// Create API instances\nconst taskApi = new TaskAPI();\nconst authApi = new AuthAPI();\nconst userApi = new UserAPI();\n\n// Consolidated API object\nconst api = {\n  tasks: taskApi,\n  auth: authApi,\n  user: userApi,\n  // Utility functions\n  isAuthenticated: () => tokenManager.isAuthenticated(),\n  getCurrentUserId: () => tokenManager.getUserIdFromToken(),\n  clearCache: () => {\n    taskApi.invalidateCache();\n    userApi.invalidateCache();\n  },\n  // Error classes for external use\n  errors: {\n    APIError,\n    NetworkError,\n    AuthenticationError,\n    RateLimitError\n  }\n};\n\n// Export everything\nexport { apiClient, taskApi, authApi, userApi, tokenManager, APIError, NetworkError, AuthenticationError, RateLimitError };\nexport default api;","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","API_CONFIG","baseURL","timeout","headers","withCredentials","maxRetries","retryDelay","rateLimitPerSecond","maxConcurrentRequests","cache","defaultExpiry","longExpiry","shortExpiry","APIError","Error","constructor","message","status","code","originalError","name","timestamp","Date","toISOString","NetworkError","AuthenticationError","RateLimitError","retryAfter","TokenManager","isRefreshing","failedQueue","getAuthToken","localStorage","getItem","error","console","warn","getRefreshToken","setTokens","authToken","refreshToken","setItem","clearTokens","removeItem","isTokenValid","token","parts","split","length","payload","JSON","parse","atob","expirationTime","exp","bufferTime","now","getUserIdFromToken","id","sub","userId","isAuthenticated","refreshTokens","Promise","resolve","reject","push","response","post","newRefreshToken","data","forEach","apiClient","create","tokenManager","interceptors","request","use","config","metadata","requestId","Math","random","toString","substr","startTime","RETRY_CODES","SKIP_RETRY_ENDPOINTS","NODE_ENV","_response$config$meta","_response$config$meth","duration","log","method","toUpperCase","url","_originalRequest$meta","_error$response","_error$response2","originalRequest","_authRetried","_originalRequest$url","_originalRequest$url2","includes","newToken","refreshError","window","location","pathname","href","delay","parseInt","shouldSkipRetry","some","endpoint","_originalRequest$url3","retryCount","_retryCount","backoffDelay","min","pow","round","setTimeout","errorMessage","BaseAPI","client","Map","pendingRequests","requestQueue","processing","activeRequests","requestTimestamps","processQueue","bind","enqueueRequest","shouldRateLimit","filter","time","trackRequest","getCachedData","key","fetchFn","options","cached","get","expiryTime","longCache","shortCache","isError","has","requestPromise","then","set","delete","catch","invalidateCache","keyOrPredicate","clear","invalidatedCount","cacheKey","keys","fn","priority","unshift","lowPriorityIndex","findIndex","r","splice","processNext","shift","result","processors","allSettled","buildQueryString","params","queryParams","URLSearchParams","Object","entries","value","undefined","Array","isArray","v","append","TaskAPI","getTasks","queryString","getTaskById","taskId","createTask","taskData","startsWith","updateTask","put","deleteTask","toggleTaskStatus","patch","searchTasks","searchTerm","filters","search","getTaskStats","bulkUpdateTasks","taskIds","updateData","bulkDeleteTasks","AuthAPI","login","credentials","email","password","register","userData","logout","forgotPassword","validateResetToken","resetPassword","newPassword","getCurrentUserId","UserAPI","getProfile","updateProfile","changePassword","passwordData","currentPassword","uploadAvatar","file","formData","FormData","taskApi","authApi","userApi","api","tasks","auth","user","clearCache","errors"],"sources":["D:/Projects/todo list/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL || '/api';\r\n\r\n// Enhanced configuration with environment-specific settings\r\nconst API_CONFIG = {\r\n  baseURL: API_URL,\r\n  timeout: 15000,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n  withCredentials: true,\r\n  maxRetries: 3,\r\n  retryDelay: 1000,\r\n  rateLimitPerSecond: 10,\r\n  maxConcurrentRequests: 6,\r\n  cache: {\r\n    defaultExpiry: 30 * 1000,  // 30 seconds\r\n    longExpiry: 5 * 60 * 1000, // 5 minutes\r\n    shortExpiry: 10 * 1000,    // 10 seconds\r\n  }\r\n};\r\n\r\n// Enhanced error types for better error handling\r\nclass APIError extends Error {\r\n  constructor(message, status, code, originalError) {\r\n    super(message);\r\n    this.name = 'APIError';\r\n    this.status = status;\r\n    this.code = code;\r\n    this.originalError = originalError;\r\n    this.timestamp = new Date().toISOString();\r\n  }\r\n}\r\n\r\nclass NetworkError extends APIError {\r\n  constructor(message, originalError) {\r\n    super(message, null, 'NETWORK_ERROR', originalError);\r\n    this.name = 'NetworkError';\r\n  }\r\n}\r\n\r\nclass AuthenticationError extends APIError {\r\n  constructor(message, status = 401) {\r\n    super(message, status, 'AUTH_ERROR');\r\n    this.name = 'AuthenticationError';\r\n  }\r\n}\r\n\r\nclass RateLimitError extends APIError {\r\n  constructor(message, retryAfter) {\r\n    super(message, 429, 'RATE_LIMIT_ERROR');\r\n    this.name = 'RateLimitError';\r\n    this.retryAfter = retryAfter;\r\n  }\r\n}\r\n\r\n// Enhanced token management with better security practices\r\nclass TokenManager {\r\n  constructor() {\r\n    this.isRefreshing = false;\r\n    this.failedQueue = [];\r\n  }\r\n\r\n  getAuthToken() {\r\n    try {\r\n      return localStorage.getItem('authToken');\r\n    } catch (error) {\r\n      console.warn('Failed to access localStorage for auth token:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  getRefreshToken() {\r\n    try {\r\n      return localStorage.getItem('refreshToken');\r\n    } catch (error) {\r\n      console.warn('Failed to access localStorage for refresh token:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  setTokens(authToken, refreshToken) {\r\n    try {\r\n      if (authToken) localStorage.setItem('authToken', authToken);\r\n      if (refreshToken) localStorage.setItem('refreshToken', refreshToken);\r\n    } catch (error) {\r\n      console.error('Failed to store tokens:', error);\r\n      throw new Error('Token storage failed');\r\n    }\r\n  }\r\n\r\n  clearTokens() {\r\n    try {\r\n      localStorage.removeItem('authToken');\r\n      localStorage.removeItem('refreshToken');\r\n    } catch (error) {\r\n      console.warn('Failed to clear tokens from localStorage:', error);\r\n    }\r\n  }\r\n\r\n  isTokenValid(token) {\r\n    if (!token) return false;\r\n    \r\n    try {\r\n      const parts = token.split('.');\r\n      if (parts.length !== 3) return false;\r\n      \r\n      const payload = JSON.parse(atob(parts[1]));\r\n      const expirationTime = payload.exp * 1000;\r\n      const bufferTime = 5 * 60 * 1000; // 5 minutes buffer\r\n      \r\n      return expirationTime > (Date.now() + bufferTime);\r\n    } catch (error) {\r\n      console.error('Error validating token:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  getUserIdFromToken(token = null) {\r\n    const authToken = token || this.getAuthToken();\r\n    if (!authToken) return null;\r\n    \r\n    try {\r\n      const payload = JSON.parse(atob(authToken.split('.')[1]));\r\n      return payload.id || payload.sub || payload.userId;\r\n    } catch (error) {\r\n      console.error('Error extracting user ID from token:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  isAuthenticated() {\r\n    const token = this.getAuthToken();\r\n    return token && this.isTokenValid(token);\r\n  }\r\n\r\n  async refreshTokens() {\r\n    if (this.isRefreshing) {\r\n      return new Promise((resolve, reject) => {\r\n        this.failedQueue.push({ resolve, reject });\r\n      });\r\n    }\r\n\r\n    this.isRefreshing = true;\r\n    const refreshToken = this.getRefreshToken();\r\n\r\n    if (!refreshToken) {\r\n      this.isRefreshing = false;\r\n      throw new AuthenticationError('No refresh token available');\r\n    }\r\n\r\n    try {\r\n      const response = await axios.post(`${API_URL}/auth/refresh`, {\r\n        refreshToken\r\n      }, {\r\n        headers: { 'Content-Type': 'application/json' },\r\n        withCredentials: true,\r\n        timeout: 10000\r\n      });\r\n\r\n      const { token, refreshToken: newRefreshToken } = response.data;\r\n      this.setTokens(token, newRefreshToken);\r\n\r\n      // Process failed queue\r\n      this.failedQueue.forEach(({ resolve }) => resolve(token));\r\n      this.failedQueue = [];\r\n\r\n      return token;\r\n    } catch (error) {\r\n      // Process failed queue with error\r\n      this.failedQueue.forEach(({ reject }) => reject(error));\r\n      this.failedQueue = [];\r\n      \r\n      this.clearTokens();\r\n      throw new AuthenticationError('Token refresh failed');\r\n    } finally {\r\n      this.isRefreshing = false;\r\n    }\r\n  }\r\n}\r\n\r\n// Create axios instance with enhanced configuration\r\nconst apiClient = axios.create(API_CONFIG);\r\n\r\nconst tokenManager = new TokenManager();\r\n\r\n// Enhanced request interceptor\r\napiClient.interceptors.request.use(\r\n  (config) => {\r\n    const token = tokenManager.getAuthToken();\r\n    if (token && tokenManager.isTokenValid(token)) {\r\n      config.headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    \r\n    // Add request ID for debugging\r\n    config.metadata = { \r\n      requestId: Math.random().toString(36).substr(2, 9),\r\n      startTime: Date.now()\r\n    };\r\n    \r\n    return config;\r\n  },\r\n  (error) => {\r\n    console.error('Request interceptor error:', error);\r\n    return Promise.reject(new NetworkError('Request configuration failed', error));\r\n  }\r\n);\r\n\r\n// Enhanced response interceptor with comprehensive error handling\r\nconst RETRY_CODES = [408, 429, 500, 502, 503, 504];\r\nconst SKIP_RETRY_ENDPOINTS = ['/tasks/bulk-delete', '/tasks/bulk-update', '/auth/logout'];\r\n\r\napiClient.interceptors.response.use(\r\n  (response) => {\r\n    // Log successful requests in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      const duration = Date.now() - response.config.metadata?.startTime;\r\n      console.log(`âœ… ${response.config.method?.toUpperCase()} ${response.config.url} (${duration}ms)`);\r\n    }\r\n    return response.data;\r\n  },\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    const requestId = originalRequest?.metadata?.requestId;\r\n    \r\n    // Enhanced error logging\r\n    console.error(`âŒ API Error [${requestId}]:`, {\r\n      url: originalRequest?.url,\r\n      method: originalRequest?.method,\r\n      status: error.response?.status,\r\n      message: error.message,\r\n      data: error.response?.data\r\n    });\r\n\r\n    // Handle network errors\r\n    if (!error.response) {\r\n      throw new NetworkError('Network request failed', error);\r\n    }\r\n\r\n    const { status, data } = error.response;\r\n    \r\n    // Handle authentication errors\r\n    if (status === 401 && !originalRequest._authRetried) {\r\n      // Skip refresh for certain endpoints\r\n      if (originalRequest.url?.includes('/auth/refresh') || \r\n          originalRequest.url?.includes('/auth/login')) {\r\n        throw new AuthenticationError('Authentication failed');\r\n      }\r\n\r\n      originalRequest._authRetried = true;\r\n      \r\n      try {\r\n        const newToken = await tokenManager.refreshTokens();\r\n        originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\r\n        return apiClient(originalRequest);\r\n      } catch (refreshError) {\r\n        // Redirect to login only if not already there\r\n        if (typeof window !== 'undefined' && \r\n            window.location.pathname !== '/login') {\r\n          window.location.href = '/login';\r\n        }\r\n        throw new AuthenticationError('Session expired. Please login again.');\r\n      }\r\n    }\r\n\r\n    // Handle rate limiting\r\n    if (status === 429) {\r\n      const retryAfter = error.response.headers['retry-after'];\r\n      const delay = retryAfter ? parseInt(retryAfter, 10) * 1000 : 2000;\r\n      throw new RateLimitError('Rate limit exceeded', delay);\r\n    }\r\n\r\n    // Handle retry logic for specific error codes\r\n    const shouldSkipRetry = SKIP_RETRY_ENDPOINTS.some(endpoint => \r\n      originalRequest.url?.includes(endpoint));\r\n    \r\n    if (!shouldSkipRetry && RETRY_CODES.includes(status)) {\r\n      const retryCount = originalRequest._retryCount || 0;\r\n      \r\n      if (retryCount < API_CONFIG.maxRetries) {\r\n        originalRequest._retryCount = retryCount + 1;\r\n        \r\n        const backoffDelay = Math.min(\r\n          API_CONFIG.retryDelay * Math.pow(2, retryCount) * (1 + Math.random() * 0.3),\r\n          10000\r\n        );\r\n        \r\n        console.log(`ðŸ”„ Retrying request ${retryCount + 1}/${API_CONFIG.maxRetries} after ${Math.round(backoffDelay)}ms`);\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, backoffDelay));\r\n        return apiClient(originalRequest);\r\n      }\r\n    }\r\n\r\n    // Create standardized error response\r\n    const errorMessage = data?.message || error.message || 'An unknown error occurred';\r\n    throw new APIError(errorMessage, status, data?.code, error);\r\n  }\r\n);\r\n\r\n// Enhanced base API class with better architecture\r\nclass BaseAPI {\r\n  constructor(client = apiClient) {\r\n    this.client = client;\r\n    this.cache = new Map();\r\n    this.pendingRequests = new Map();\r\n    this.requestQueue = [];\r\n    this.processing = false;\r\n    this.activeRequests = 0;\r\n    this.requestTimestamps = [];\r\n    \r\n    // Bind methods to preserve context\r\n    this.processQueue = this.processQueue.bind(this);\r\n    this.enqueueRequest = this.enqueueRequest.bind(this);\r\n  }\r\n\r\n  // Rate limiting\r\n  shouldRateLimit() {\r\n    const now = Date.now();\r\n    this.requestTimestamps = this.requestTimestamps.filter(time => now - time < 1000);\r\n    return this.requestTimestamps.length >= API_CONFIG.rateLimitPerSecond;\r\n  }\r\n\r\n  trackRequest() {\r\n    this.requestTimestamps.push(Date.now());\r\n  }\r\n\r\n  // Cache management\r\n  getCachedData(key, fetchFn, options = {}) {\r\n    const cached = this.cache.get(key);\r\n    const expiryTime = options.longCache\r\n      ? API_CONFIG.cache.longExpiry\r\n      : (options.shortCache ? API_CONFIG.cache.shortExpiry : API_CONFIG.cache.defaultExpiry);\r\n\r\n    if (cached && !cached.isError && Date.now() - cached.timestamp < expiryTime) {\r\n      return Promise.resolve(cached.data);\r\n    }\r\n\r\n    // Check for cached errors (short-term error caching to prevent hammering)\r\n    if (cached?.isError && Date.now() - cached.timestamp < 5000) {\r\n      return Promise.reject(cached.error);\r\n    }\r\n\r\n    if (this.pendingRequests.has(key)) {\r\n      return this.pendingRequests.get(key);\r\n    }\r\n\r\n    const requestPromise = this.enqueueRequest(fetchFn)\r\n      .then(data => {\r\n        this.cache.set(key, { data, timestamp: Date.now(), isError: false });\r\n        this.pendingRequests.delete(key);\r\n        return data;\r\n      })\r\n      .catch(error => {\r\n        // Cache errors for a short period to prevent repeated failed requests\r\n        this.cache.set(key, { \r\n          error, \r\n          timestamp: Date.now(), \r\n          isError: true \r\n        });\r\n        this.pendingRequests.delete(key);\r\n        throw error;\r\n      });\r\n\r\n    this.pendingRequests.set(key, requestPromise);\r\n    return requestPromise;\r\n  }\r\n\r\n  invalidateCache(keyOrPredicate = null) {\r\n    if (keyOrPredicate === null) {\r\n      this.cache.clear();\r\n      console.log('ðŸ—‘ï¸ Cache cleared entirely');\r\n    } else if (typeof keyOrPredicate === 'string') {\r\n      this.cache.delete(keyOrPredicate);\r\n      console.log(`ðŸ—‘ï¸ Cache invalidated for key: ${keyOrPredicate}`);\r\n    } else if (typeof keyOrPredicate === 'function') {\r\n      let invalidatedCount = 0;\r\n      for (const cacheKey of this.cache.keys()) {\r\n        if (keyOrPredicate(cacheKey)) {\r\n          this.cache.delete(cacheKey);\r\n          invalidatedCount++;\r\n        }\r\n      }\r\n      console.log(`ðŸ—‘ï¸ Cache invalidated for ${invalidatedCount} keys matching predicate`);\r\n    }\r\n  }\r\n\r\n  // Enhanced queue management\r\n  enqueueRequest(fn, priority = 'normal') {\r\n    return new Promise((resolve, reject) => {\r\n      const request = { \r\n        fn, \r\n        resolve, \r\n        reject, \r\n        priority, \r\n        timestamp: Date.now(),\r\n        id: Math.random().toString(36).substr(2, 9)\r\n      };\r\n\r\n      // Insert based on priority\r\n      if (priority === 'high') {\r\n        this.requestQueue.unshift(request);\r\n      } else if (priority === 'normal') {\r\n        const lowPriorityIndex = this.requestQueue.findIndex(r => r.priority === 'low');\r\n        if (lowPriorityIndex !== -1) {\r\n          this.requestQueue.splice(lowPriorityIndex, 0, request);\r\n        } else {\r\n          this.requestQueue.push(request);\r\n        }\r\n      } else {\r\n        this.requestQueue.push(request); // low priority\r\n      }\r\n\r\n      this.processQueue();\r\n    });\r\n  }\r\n\r\n  async processQueue() {\r\n    if (this.processing) return;\r\n    this.processing = true;\r\n\r\n    const processNext = async () => {\r\n      if (this.requestQueue.length === 0) return;\r\n\r\n      if (this.shouldRateLimit()) {\r\n        setTimeout(processNext, 100 + Math.random() * 50);\r\n        return;\r\n      }\r\n\r\n      const request = this.requestQueue.shift();\r\n      if (!request) return;\r\n\r\n      this.activeRequests++;\r\n      this.trackRequest();\r\n\r\n      try {\r\n        const result = await request.fn();\r\n        request.resolve(result);\r\n      } catch (error) {\r\n        request.reject(error);\r\n      } finally {\r\n        this.activeRequests--;\r\n        // Continue processing if there are more requests\r\n        if (this.requestQueue.length > 0) {\r\n          processNext();\r\n        }\r\n      }\r\n    };\r\n\r\n    // Start multiple processors up to the concurrent limit\r\n    const processors = [];\r\n    while (this.activeRequests < API_CONFIG.maxConcurrentRequests && \r\n           this.requestQueue.length > 0 && \r\n           !this.shouldRateLimit()) {\r\n      processors.push(processNext());\r\n    }\r\n\r\n    if (processors.length > 0) {\r\n      await Promise.allSettled(processors);\r\n    }\r\n\r\n    // Continue processing if needed\r\n    if (this.requestQueue.length > 0 && \r\n        this.activeRequests < API_CONFIG.maxConcurrentRequests) {\r\n      this.processing = false;\r\n      this.processQueue();\r\n    } else {\r\n      this.processing = false;\r\n    }\r\n  }\r\n\r\n  // Utility method for building query strings\r\n  buildQueryString(params) {\r\n    const queryParams = new URLSearchParams();\r\n    Object.entries(params).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null && value !== '') {\r\n        if (Array.isArray(value)) {\r\n          value.forEach(v => queryParams.append(key, v));\r\n        } else {\r\n          queryParams.append(key, value);\r\n        }\r\n      }\r\n    });\r\n    return queryParams.toString();\r\n  }\r\n}\r\n\r\n// Enhanced TaskAPI with better error handling and validation\r\nclass TaskAPI extends BaseAPI {\r\n  async getTasks(params = {}) {\r\n    try {\r\n      const queryString = this.buildQueryString(params);\r\n      const cacheKey = `tasks_${queryString || 'all'}`;\r\n      \r\n      return await this.getCachedData(\r\n        cacheKey, \r\n        () => this.client.get(`/tasks?${queryString}`),\r\n        { shortCache: true }\r\n      );\r\n    } catch (error) {\r\n      console.error('Failed to fetch tasks:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getTaskById(taskId) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\r\n    }\r\n\r\n    const cacheKey = `task_${taskId}`;\r\n    return this.getCachedData(cacheKey, () => this.client.get(`/tasks/${taskId}`));\r\n  }\r\n\r\n  async createTask(taskData) {\r\n    if (!taskData || typeof taskData !== 'object') {\r\n      throw new APIError('Valid task data is required', 400, 'INVALID_TASK_DATA');\r\n    }\r\n\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.post('/tasks', taskData), \r\n        'high'\r\n      );\r\n      \r\n      // Invalidate related caches\r\n      this.invalidateCache(key => key.startsWith('tasks_'));\r\n      this.invalidateCache('task_stats');\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Failed to create task:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateTask(taskId, taskData) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\r\n    }\r\n    if (!taskData || typeof taskData !== 'object') {\r\n      throw new APIError('Valid task data is required', 400, 'INVALID_TASK_DATA');\r\n    }\r\n\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.put(`/tasks/${taskId}`, taskData)\r\n      );\r\n      \r\n      // Invalidate caches\r\n      this.invalidateCache(`task_${taskId}`);\r\n      this.invalidateCache(key => key.startsWith('tasks_'));\r\n      this.invalidateCache('task_stats');\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error(`Failed to update task ${taskId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deleteTask(taskId) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\r\n    }\r\n\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.delete(`/tasks/${taskId}`)\r\n      );\r\n      \r\n      // Invalidate caches\r\n      this.invalidateCache(`task_${taskId}`);\r\n      this.invalidateCache(key => key.startsWith('tasks_'));\r\n      this.invalidateCache('task_stats');\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error(`Failed to delete task ${taskId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async toggleTaskStatus(taskId) {\r\n    if (!taskId) {\r\n      throw new APIError('Task ID is required', 400, 'INVALID_TASK_ID');\r\n    }\r\n\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.patch(`/tasks/${taskId}/toggle`)\r\n      );\r\n      \r\n      // Invalidate caches\r\n      this.invalidateCache(`task_${taskId}`);\r\n      this.invalidateCache(key => key.startsWith('tasks_'));\r\n      this.invalidateCache('task_stats');\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error(`Failed to toggle task status ${taskId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async searchTasks(searchTerm, filters = {}) {\r\n    if (!searchTerm || typeof searchTerm !== 'string') {\r\n      throw new APIError('Search term is required', 400, 'INVALID_SEARCH_TERM');\r\n    }\r\n\r\n    const params = { search: searchTerm, ...filters };\r\n    const queryString = this.buildQueryString(params);\r\n    const cacheKey = `search_${queryString}`;\r\n    \r\n    return this.getCachedData(\r\n      cacheKey,\r\n      () => this.client.get(`/tasks/search?${queryString}`),\r\n      { shortCache: true }\r\n    );\r\n  }\r\n\r\n  async getTaskStats() {\r\n    return this.getCachedData(\r\n      'task_stats',\r\n      () => this.client.get('/tasks/stats'),\r\n      { longCache: true }\r\n    );\r\n  }\r\n\r\n  async bulkUpdateTasks(taskIds, updateData) {\r\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\r\n      throw new APIError('Task IDs array is required', 400, 'INVALID_TASK_IDS');\r\n    }\r\n    if (!updateData || typeof updateData !== 'object') {\r\n      throw new APIError('Update data is required', 400, 'INVALID_UPDATE_DATA');\r\n    }\r\n\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.put('/tasks/bulk-update', { taskIds, updateData }),\r\n        'high'\r\n      );\r\n      \r\n      // Invalidate caches\r\n      taskIds.forEach(id => this.invalidateCache(`task_${id}`));\r\n      this.invalidateCache(key => key.startsWith('tasks_'));\r\n      this.invalidateCache('task_stats');\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Failed to bulk update tasks:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async bulkDeleteTasks(taskIds) {\r\n    if (!Array.isArray(taskIds) || taskIds.length === 0) {\r\n      throw new APIError('Task IDs array is required', 400, 'INVALID_TASK_IDS');\r\n    }\r\n\r\n    try {\r\n      const result = await this.enqueueRequest(\r\n        () => this.client.delete('/tasks/bulk-delete', { data: { taskIds } }),\r\n        'high'\r\n      );\r\n      \r\n      // Invalidate caches\r\n      taskIds.forEach(id => this.invalidateCache(`task_${id}`));\r\n      this.invalidateCache(key => key.startsWith('tasks_'));\r\n      this.invalidateCache('task_stats');\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Failed to bulk delete tasks:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Enhanced AuthAPI with comprehensive authentication handling\r\nclass AuthAPI {\r\n  constructor(client = apiClient) {\r\n    this.client = client;\r\n    this.tokenManager = tokenManager;\r\n  }\r\n\r\n  async login(credentials) {\r\n    if (!credentials?.email || !credentials?.password) {\r\n      throw new APIError('Email and password are required', 400, 'INVALID_CREDENTIALS');\r\n    }\r\n\r\n    try {\r\n      const data = await this.client.post('/auth/login', credentials);\r\n      \r\n      if (data.token) {\r\n        this.tokenManager.setTokens(data.token, data.refreshToken);\r\n      }\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      console.error('Login failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async register(userData) {\r\n    if (!userData?.email || !userData?.password) {\r\n      throw new APIError('Email and password are required', 400, 'INVALID_USER_DATA');\r\n    }\r\n\r\n    try {\r\n      return await this.client.post('/auth/register', userData);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async logout() {\r\n    try {\r\n      await this.client.post('/auth/logout');\r\n    } catch (error) {\r\n      console.warn('Logout API call failed:', error);\r\n      // Continue with client-side logout even if server logout fails\r\n    } finally {\r\n      this.tokenManager.clearTokens();\r\n    }\r\n  }\r\n\r\n  async forgotPassword(email) {\r\n    if (!email) {\r\n      throw new APIError('Email is required', 400, 'INVALID_EMAIL');\r\n    }\r\n\r\n    return this.client.post('/auth/forgot-password', { email });\r\n  }\r\n\r\n  async validateResetToken(token) {\r\n    if (!token) {\r\n      throw new APIError('Reset token is required', 400, 'INVALID_TOKEN');\r\n    }\r\n\r\n    return this.client.get(`/auth/reset-password/${token}`);\r\n  }\r\n\r\n  async resetPassword(token, newPassword) {\r\n    if (!token || !newPassword) {\r\n      throw new APIError('Token and new password are required', 400, 'INVALID_RESET_DATA');\r\n    }\r\n\r\n    return this.client.post('/auth/reset-password', { token, newPassword });\r\n  }\r\n\r\n  async refreshToken() {\r\n    return this.tokenManager.refreshTokens();\r\n  }\r\n\r\n  isAuthenticated() {\r\n    return this.tokenManager.isAuthenticated();\r\n  }\r\n\r\n  getCurrentUserId() {\r\n    return this.tokenManager.getUserIdFromToken();\r\n  }\r\n}\r\n\r\n// Enhanced UserAPI with caching and validation\r\nclass UserAPI extends BaseAPI {\r\n  async getProfile() {\r\n    return this.getCachedData(\r\n      'user_profile',\r\n      () => this.client.get('/user/profile'),\r\n      { longCache: true }\r\n    );\r\n  }\r\n\r\n  async updateProfile(userData) {\r\n    if (!userData || typeof userData !== 'object') {\r\n      throw new APIError('User data is required', 400, 'INVALID_USER_DATA');\r\n    }\r\n\r\n    try {\r\n      const result = await this.client.put('/user/profile', userData);\r\n      this.invalidateCache('user_profile');\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Failed to update profile:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async changePassword(passwordData) {\r\n    if (!passwordData?.currentPassword || !passwordData?.newPassword) {\r\n      throw new APIError('Current and new passwords are required', 400, 'INVALID_PASSWORD_DATA');\r\n    }\r\n\r\n    return this.client.put('/user/password', passwordData);\r\n  }\r\n\r\n  async uploadAvatar(file) {\r\n    if (!file) {\r\n      throw new APIError('File is required', 400, 'INVALID_FILE');\r\n    }\r\n\r\n    const formData = new FormData();\r\n    formData.append('avatar', file);\r\n\r\n    try {\r\n      const result = await this.client.post('/user/avatar', formData, {\r\n        headers: { 'Content-Type': 'multipart/form-data' }\r\n      });\r\n      this.invalidateCache('user_profile');\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Failed to upload avatar:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Create API instances\r\nconst taskApi = new TaskAPI();\r\nconst authApi = new AuthAPI();\r\nconst userApi = new UserAPI();\r\n\r\n// Consolidated API object\r\nconst api = {\r\n  tasks: taskApi,\r\n  auth: authApi,\r\n  user: userApi,\r\n  // Utility functions\r\n  isAuthenticated: () => tokenManager.isAuthenticated(),\r\n  getCurrentUserId: () => tokenManager.getUserIdFromToken(),\r\n  clearCache: () => {\r\n    taskApi.invalidateCache();\r\n    userApi.invalidateCache();\r\n  },\r\n  // Error classes for external use\r\n  errors: {\r\n    APIError,\r\n    NetworkError,\r\n    AuthenticationError,\r\n    RateLimitError\r\n  }\r\n};\r\n\r\n// Export everything\r\nexport {\r\n  apiClient,\r\n  taskApi,\r\n  authApi,\r\n  userApi,\r\n  tokenManager,\r\n  APIError,\r\n  NetworkError,\r\n  AuthenticationError,\r\n  RateLimitError\r\n};\r\n\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}